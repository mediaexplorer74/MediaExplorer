// File is generated by Source/core/inspector/CodeGeneratorInspector.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


#include "config.h"
#include "InspectorBackendDispatcher.h"

#include "core/inspector/InspectorFrontendChannel.h"
#include "core/inspector/JSONParser.h"
#include "platform/JSONValues.h"
#include "wtf/text/CString.h"
#include "wtf/text/WTFString.h"

namespace blink {

const char InspectorBackendDispatcher::commandNames[] = {
    "Inspector.enable\0"
    "Inspector.disable\0"
    "Memory.getDOMCounters\0"
    "Page.enable\0"
    "Page.disable\0"
    "Page.addScriptToEvaluateOnLoad\0"
    "Page.removeScriptToEvaluateOnLoad\0"
    "Page.reload\0"
    "Page.navigate\0"
    "Page.getResourceTree\0"
    "Page.getResourceContent\0"
    "Page.searchInResource\0"
    "Page.setDocumentContent\0"
    "Page.setDeviceOrientationOverride\0"
    "Page.clearDeviceOrientationOverride\0"
    "Page.setTouchEmulationEnabled\0"
    "Page.startScreencast\0"
    "Page.stopScreencast\0"
    "Page.setShowViewportSizeOnResize\0"
    "Page.setOverlayMessage\0"
    "Rendering.setShowPaintRects\0"
    "Rendering.setShowDebugBorders\0"
    "Rendering.setShowFPSCounter\0"
    "Rendering.setContinuousPaintingEnabled\0"
    "Rendering.setShowScrollBottleneckRects\0"
    "Emulation.resetScrollAndPageScaleFactor\0"
    "Emulation.setPageScaleFactor\0"
    "Emulation.setScriptExecutionDisabled\0"
    "Emulation.setTouchEmulationEnabled\0"
    "Emulation.setEmulatedMedia\0"
    "Runtime.evaluate\0"
    "Runtime.callFunctionOn\0"
    "Runtime.getProperties\0"
    "Runtime.releaseObject\0"
    "Runtime.releaseObjectGroup\0"
    "Runtime.run\0"
    "Runtime.enable\0"
    "Runtime.disable\0"
    "Runtime.isRunRequired\0"
    "Runtime.setCustomObjectFormatterEnabled\0"
    "Console.enable\0"
    "Console.disable\0"
    "Console.clearMessages\0"
    "Network.enable\0"
    "Network.disable\0"
    "Network.setUserAgentOverride\0"
    "Network.setExtraHTTPHeaders\0"
    "Network.getResponseBody\0"
    "Network.replayXHR\0"
    "Network.setMonitoringXHREnabled\0"
    "Network.canClearBrowserCache\0"
    "Network.canClearBrowserCookies\0"
    "Network.emulateNetworkConditions\0"
    "Network.setCacheDisabled\0"
    "Network.setDataSizeLimitsForTest\0"
    "Database.enable\0"
    "Database.disable\0"
    "Database.getDatabaseTableNames\0"
    "Database.executeSQL\0"
    "IndexedDB.enable\0"
    "IndexedDB.disable\0"
    "IndexedDB.requestDatabaseNames\0"
    "IndexedDB.requestDatabase\0"
    "IndexedDB.requestData\0"
    "IndexedDB.clearObjectStore\0"
    "CacheStorage.requestCacheNames\0"
    "CacheStorage.requestEntries\0"
    "CacheStorage.deleteCache\0"
    "CacheStorage.deleteEntry\0"
    "DOMStorage.enable\0"
    "DOMStorage.disable\0"
    "DOMStorage.getDOMStorageItems\0"
    "DOMStorage.setDOMStorageItem\0"
    "DOMStorage.removeDOMStorageItem\0"
    "ApplicationCache.getFramesWithManifests\0"
    "ApplicationCache.enable\0"
    "ApplicationCache.getManifestForFrame\0"
    "ApplicationCache.getApplicationCacheForFrame\0"
    "FileSystem.enable\0"
    "FileSystem.disable\0"
    "FileSystem.requestFileSystemRoot\0"
    "FileSystem.requestDirectoryContent\0"
    "FileSystem.requestMetadata\0"
    "FileSystem.requestFileContent\0"
    "FileSystem.deleteEntry\0"
    "DOM.enable\0"
    "DOM.disable\0"
    "DOM.getDocument\0"
    "DOM.requestChildNodes\0"
    "DOM.querySelector\0"
    "DOM.querySelectorAll\0"
    "DOM.setNodeName\0"
    "DOM.setNodeValue\0"
    "DOM.removeNode\0"
    "DOM.setAttributeValue\0"
    "DOM.setAttributesAsText\0"
    "DOM.removeAttribute\0"
    "DOM.getOuterHTML\0"
    "DOM.setOuterHTML\0"
    "DOM.performSearch\0"
    "DOM.getSearchResults\0"
    "DOM.discardSearchResults\0"
    "DOM.requestNode\0"
    "DOM.setInspectModeEnabled\0"
    "DOM.highlightRect\0"
    "DOM.highlightQuad\0"
    "DOM.highlightNode\0"
    "DOM.hideHighlight\0"
    "DOM.highlightFrame\0"
    "DOM.pushNodeByPathToFrontend\0"
    "DOM.pushNodesByBackendIdsToFrontend\0"
    "DOM.setInspectedNode\0"
    "DOM.resolveNode\0"
    "DOM.getAttributes\0"
    "DOM.copyTo\0"
    "DOM.moveTo\0"
    "DOM.undo\0"
    "DOM.redo\0"
    "DOM.markUndoableState\0"
    "DOM.focus\0"
    "DOM.setFileInputFiles\0"
    "DOM.getBoxModel\0"
    "DOM.getNodeForLocation\0"
    "DOM.getRelayoutBoundary\0"
    "DOM.getHighlightObjectForTest\0"
    "CSS.enable\0"
    "CSS.disable\0"
    "CSS.getMatchedStylesForNode\0"
    "CSS.getInlineStylesForNode\0"
    "CSS.getComputedStyleForNode\0"
    "CSS.getPlatformFontsForNode\0"
    "CSS.getStyleSheetText\0"
    "CSS.setStyleSheetText\0"
    "CSS.setRuleSelector\0"
    "CSS.setStyleText\0"
    "CSS.setMediaText\0"
    "CSS.createStyleSheet\0"
    "CSS.addRule\0"
    "CSS.forcePseudoState\0"
    "CSS.getMediaQueries\0"
    "CSS.setEffectivePropertyValueForNode\0"
    "Timeline.enable\0"
    "Timeline.disable\0"
    "Timeline.start\0"
    "Timeline.stop\0"
    "Debugger.enable\0"
    "Debugger.disable\0"
    "Debugger.setBreakpointsActive\0"
    "Debugger.setSkipAllPauses\0"
    "Debugger.setBreakpointByUrl\0"
    "Debugger.setBreakpoint\0"
    "Debugger.removeBreakpoint\0"
    "Debugger.continueToLocation\0"
    "Debugger.stepOver\0"
    "Debugger.stepInto\0"
    "Debugger.stepOut\0"
    "Debugger.pause\0"
    "Debugger.resume\0"
    "Debugger.stepIntoAsync\0"
    "Debugger.searchInContent\0"
    "Debugger.canSetScriptSource\0"
    "Debugger.setScriptSource\0"
    "Debugger.restartFrame\0"
    "Debugger.getScriptSource\0"
    "Debugger.getFunctionDetails\0"
    "Debugger.getGeneratorObjectDetails\0"
    "Debugger.getCollectionEntries\0"
    "Debugger.setPauseOnExceptions\0"
    "Debugger.evaluateOnCallFrame\0"
    "Debugger.compileScript\0"
    "Debugger.runScript\0"
    "Debugger.setVariableValue\0"
    "Debugger.getStepInPositions\0"
    "Debugger.getBacktrace\0"
    "Debugger.skipStackFrames\0"
    "Debugger.setAsyncCallStackDepth\0"
    "Debugger.enablePromiseTracker\0"
    "Debugger.disablePromiseTracker\0"
    "Debugger.getPromiseById\0"
    "Debugger.flushAsyncOperationEvents\0"
    "Debugger.setAsyncOperationBreakpoint\0"
    "Debugger.removeAsyncOperationBreakpoint\0"
    "DOMDebugger.setDOMBreakpoint\0"
    "DOMDebugger.removeDOMBreakpoint\0"
    "DOMDebugger.setEventListenerBreakpoint\0"
    "DOMDebugger.removeEventListenerBreakpoint\0"
    "DOMDebugger.setInstrumentationBreakpoint\0"
    "DOMDebugger.removeInstrumentationBreakpoint\0"
    "DOMDebugger.setXHRBreakpoint\0"
    "DOMDebugger.removeXHRBreakpoint\0"
    "DOMDebugger.getEventListeners\0"
    "Profiler.enable\0"
    "Profiler.disable\0"
    "Profiler.setSamplingInterval\0"
    "Profiler.start\0"
    "Profiler.stop\0"
    "HeapProfiler.enable\0"
    "HeapProfiler.disable\0"
    "HeapProfiler.startTrackingHeapObjects\0"
    "HeapProfiler.stopTrackingHeapObjects\0"
    "HeapProfiler.takeHeapSnapshot\0"
    "HeapProfiler.collectGarbage\0"
    "HeapProfiler.getObjectByHeapObjectId\0"
    "HeapProfiler.addInspectedHeapObject\0"
    "HeapProfiler.getHeapObjectId\0"
    "Worker.enable\0"
    "Worker.disable\0"
    "Worker.sendMessageToWorker\0"
    "Worker.connectToWorker\0"
    "Worker.disconnectFromWorker\0"
    "Worker.setAutoconnectToWorkers\0"
    "Input.dispatchTouchEvent\0"
    "LayerTree.enable\0"
    "LayerTree.disable\0"
    "LayerTree.compositingReasons\0"
    "LayerTree.makeSnapshot\0"
    "LayerTree.loadSnapshot\0"
    "LayerTree.releaseSnapshot\0"
    "LayerTree.profileSnapshot\0"
    "LayerTree.replaySnapshot\0"
    "LayerTree.snapshotCommandLog\0"
    "DeviceOrientation.setDeviceOrientationOverride\0"
    "DeviceOrientation.clearDeviceOrientationOverride\0"
    "ScreenOrientation.setScreenOrientationOverride\0"
    "ScreenOrientation.clearScreenOrientationOverride\0"
    "Tracing.start\0"
    "Tracing.end\0"
    "Animation.enable\0"
    "Animation.disable\0"
    "Animation.getPlaybackRate\0"
    "Animation.setPlaybackRate\0"
    "Animation.setCurrentTime\0"
    "Animation.setTiming\0"
    "Accessibility.getAXNode\0"
};

const unsigned short InspectorBackendDispatcher::commandNamesIndex[] = {
    0,
    17,
    35,
    57,
    69,
    82,
    113,
    147,
    159,
    173,
    194,
    218,
    240,
    264,
    298,
    334,
    364,
    385,
    405,
    438,
    461,
    489,
    519,
    547,
    586,
    625,
    665,
    694,
    731,
    766,
    793,
    810,
    833,
    855,
    877,
    904,
    916,
    931,
    947,
    969,
    1009,
    1024,
    1040,
    1062,
    1077,
    1093,
    1122,
    1150,
    1174,
    1192,
    1224,
    1253,
    1284,
    1317,
    1342,
    1375,
    1391,
    1408,
    1439,
    1459,
    1476,
    1494,
    1525,
    1551,
    1573,
    1600,
    1631,
    1659,
    1684,
    1709,
    1727,
    1746,
    1776,
    1805,
    1837,
    1877,
    1901,
    1938,
    1983,
    2001,
    2020,
    2053,
    2088,
    2115,
    2145,
    2168,
    2179,
    2191,
    2207,
    2229,
    2247,
    2268,
    2284,
    2301,
    2316,
    2338,
    2362,
    2382,
    2399,
    2416,
    2434,
    2455,
    2480,
    2496,
    2522,
    2540,
    2558,
    2576,
    2594,
    2613,
    2642,
    2678,
    2699,
    2715,
    2733,
    2744,
    2755,
    2764,
    2773,
    2795,
    2805,
    2827,
    2843,
    2866,
    2890,
    2920,
    2931,
    2943,
    2971,
    2998,
    3026,
    3054,
    3076,
    3098,
    3118,
    3135,
    3152,
    3173,
    3185,
    3206,
    3226,
    3263,
    3279,
    3296,
    3311,
    3325,
    3341,
    3358,
    3388,
    3414,
    3442,
    3465,
    3491,
    3519,
    3537,
    3555,
    3572,
    3587,
    3603,
    3626,
    3651,
    3679,
    3704,
    3726,
    3751,
    3779,
    3814,
    3844,
    3874,
    3903,
    3926,
    3945,
    3971,
    3999,
    4021,
    4046,
    4078,
    4108,
    4139,
    4163,
    4198,
    4235,
    4275,
    4304,
    4336,
    4375,
    4417,
    4458,
    4502,
    4531,
    4563,
    4593,
    4609,
    4626,
    4655,
    4670,
    4684,
    4704,
    4725,
    4763,
    4800,
    4830,
    4858,
    4895,
    4931,
    4960,
    4974,
    4989,
    5016,
    5039,
    5067,
    5098,
    5123,
    5140,
    5158,
    5187,
    5210,
    5233,
    5259,
    5285,
    5310,
    5339,
    5386,
    5435,
    5482,
    5531,
    5545,
    5557,
    5574,
    5592,
    5618,
    5644,
    5669,
    5689,
};

const char* InspectorBackendDispatcher::commandName(MethodNames index) {
    static_assert(static_cast<int>(kMethodNamesEnumSize) == WTF_ARRAY_LENGTH(commandNamesIndex), "MethodNames enum should have the same number of elements as commandNamesIndex");
    return commandNames + commandNamesIndex[index];
}

class InspectorBackendDispatcherImpl : public InspectorBackendDispatcher {
public:
    InspectorBackendDispatcherImpl(InspectorFrontendChannel* inspectorFrontendChannel)
        : m_inspectorFrontendChannel(inspectorFrontendChannel)
        , m_inspectorAgent(0)
        , m_memoryAgent(0)
        , m_pageAgent(0)
        , m_renderingAgent(0)
        , m_emulationAgent(0)
        , m_runtimeAgent(0)
        , m_consoleAgent(0)
        , m_networkAgent(0)
        , m_databaseAgent(0)
        , m_indexedDBAgent(0)
        , m_cacheStorageAgent(0)
        , m_domStorageAgent(0)
        , m_applicationCacheAgent(0)
        , m_fileSystemAgent(0)
        , m_domAgent(0)
        , m_cssAgent(0)
        , m_timelineAgent(0)
        , m_debuggerAgent(0)
        , m_domDebuggerAgent(0)
        , m_profilerAgent(0)
        , m_heapProfilerAgent(0)
        , m_workerAgent(0)
        , m_serviceWorkerAgent(0)
        , m_inputAgent(0)
        , m_layerTreeAgent(0)
        , m_deviceOrientationAgent(0)
        , m_screenOrientationAgent(0)
        , m_tracingAgent(0)
        , m_powerAgent(0)
        , m_animationAgent(0)
        , m_accessibilityAgent(0)
        , m_securityAgent(0)
    {
        // Initialize dispatch map.
        const CallHandler handlers[] = {
              &InspectorBackendDispatcherImpl::Inspector_enable,
            &InspectorBackendDispatcherImpl::Inspector_disable,
            &InspectorBackendDispatcherImpl::Memory_getDOMCounters,
            &InspectorBackendDispatcherImpl::Page_enable,
            &InspectorBackendDispatcherImpl::Page_disable,
            &InspectorBackendDispatcherImpl::Page_addScriptToEvaluateOnLoad,
            &InspectorBackendDispatcherImpl::Page_removeScriptToEvaluateOnLoad,
            &InspectorBackendDispatcherImpl::Page_reload,
            &InspectorBackendDispatcherImpl::Page_navigate,
            &InspectorBackendDispatcherImpl::Page_getResourceTree,
            &InspectorBackendDispatcherImpl::Page_getResourceContent,
            &InspectorBackendDispatcherImpl::Page_searchInResource,
            &InspectorBackendDispatcherImpl::Page_setDocumentContent,
            &InspectorBackendDispatcherImpl::Page_setDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::Page_clearDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::Page_setTouchEmulationEnabled,
            &InspectorBackendDispatcherImpl::Page_startScreencast,
            &InspectorBackendDispatcherImpl::Page_stopScreencast,
            &InspectorBackendDispatcherImpl::Page_setShowViewportSizeOnResize,
            &InspectorBackendDispatcherImpl::Page_setOverlayMessage,
            &InspectorBackendDispatcherImpl::Rendering_setShowPaintRects,
            &InspectorBackendDispatcherImpl::Rendering_setShowDebugBorders,
            &InspectorBackendDispatcherImpl::Rendering_setShowFPSCounter,
            &InspectorBackendDispatcherImpl::Rendering_setContinuousPaintingEnabled,
            &InspectorBackendDispatcherImpl::Rendering_setShowScrollBottleneckRects,
            &InspectorBackendDispatcherImpl::Emulation_resetScrollAndPageScaleFactor,
            &InspectorBackendDispatcherImpl::Emulation_setPageScaleFactor,
            &InspectorBackendDispatcherImpl::Emulation_setScriptExecutionDisabled,
            &InspectorBackendDispatcherImpl::Emulation_setTouchEmulationEnabled,
            &InspectorBackendDispatcherImpl::Emulation_setEmulatedMedia,
            &InspectorBackendDispatcherImpl::Runtime_evaluate,
            &InspectorBackendDispatcherImpl::Runtime_callFunctionOn,
            &InspectorBackendDispatcherImpl::Runtime_getProperties,
            &InspectorBackendDispatcherImpl::Runtime_releaseObject,
            &InspectorBackendDispatcherImpl::Runtime_releaseObjectGroup,
            &InspectorBackendDispatcherImpl::Runtime_run,
            &InspectorBackendDispatcherImpl::Runtime_enable,
            &InspectorBackendDispatcherImpl::Runtime_disable,
            &InspectorBackendDispatcherImpl::Runtime_isRunRequired,
            &InspectorBackendDispatcherImpl::Runtime_setCustomObjectFormatterEnabled,
            &InspectorBackendDispatcherImpl::Console_enable,
            &InspectorBackendDispatcherImpl::Console_disable,
            &InspectorBackendDispatcherImpl::Console_clearMessages,
            &InspectorBackendDispatcherImpl::Network_enable,
            &InspectorBackendDispatcherImpl::Network_disable,
            &InspectorBackendDispatcherImpl::Network_setUserAgentOverride,
            &InspectorBackendDispatcherImpl::Network_setExtraHTTPHeaders,
            &InspectorBackendDispatcherImpl::Network_getResponseBody,
            &InspectorBackendDispatcherImpl::Network_replayXHR,
            &InspectorBackendDispatcherImpl::Network_setMonitoringXHREnabled,
            &InspectorBackendDispatcherImpl::Network_canClearBrowserCache,
            &InspectorBackendDispatcherImpl::Network_canClearBrowserCookies,
            &InspectorBackendDispatcherImpl::Network_emulateNetworkConditions,
            &InspectorBackendDispatcherImpl::Network_setCacheDisabled,
            &InspectorBackendDispatcherImpl::Network_setDataSizeLimitsForTest,
            &InspectorBackendDispatcherImpl::Database_enable,
            &InspectorBackendDispatcherImpl::Database_disable,
            &InspectorBackendDispatcherImpl::Database_getDatabaseTableNames,
            &InspectorBackendDispatcherImpl::Database_executeSQL,
            &InspectorBackendDispatcherImpl::IndexedDB_enable,
            &InspectorBackendDispatcherImpl::IndexedDB_disable,
            &InspectorBackendDispatcherImpl::IndexedDB_requestDatabaseNames,
            &InspectorBackendDispatcherImpl::IndexedDB_requestDatabase,
            &InspectorBackendDispatcherImpl::IndexedDB_requestData,
            &InspectorBackendDispatcherImpl::IndexedDB_clearObjectStore,
            &InspectorBackendDispatcherImpl::CacheStorage_requestCacheNames,
            &InspectorBackendDispatcherImpl::CacheStorage_requestEntries,
            &InspectorBackendDispatcherImpl::CacheStorage_deleteCache,
            &InspectorBackendDispatcherImpl::CacheStorage_deleteEntry,
            &InspectorBackendDispatcherImpl::DOMStorage_enable,
            &InspectorBackendDispatcherImpl::DOMStorage_disable,
            &InspectorBackendDispatcherImpl::DOMStorage_getDOMStorageItems,
            &InspectorBackendDispatcherImpl::DOMStorage_setDOMStorageItem,
            &InspectorBackendDispatcherImpl::DOMStorage_removeDOMStorageItem,
            &InspectorBackendDispatcherImpl::ApplicationCache_getFramesWithManifests,
            &InspectorBackendDispatcherImpl::ApplicationCache_enable,
            &InspectorBackendDispatcherImpl::ApplicationCache_getManifestForFrame,
            &InspectorBackendDispatcherImpl::ApplicationCache_getApplicationCacheForFrame,
            &InspectorBackendDispatcherImpl::FileSystem_enable,
            &InspectorBackendDispatcherImpl::FileSystem_disable,
            &InspectorBackendDispatcherImpl::FileSystem_requestFileSystemRoot,
            &InspectorBackendDispatcherImpl::FileSystem_requestDirectoryContent,
            &InspectorBackendDispatcherImpl::FileSystem_requestMetadata,
            &InspectorBackendDispatcherImpl::FileSystem_requestFileContent,
            &InspectorBackendDispatcherImpl::FileSystem_deleteEntry,
            &InspectorBackendDispatcherImpl::DOM_enable,
            &InspectorBackendDispatcherImpl::DOM_disable,
            &InspectorBackendDispatcherImpl::DOM_getDocument,
            &InspectorBackendDispatcherImpl::DOM_requestChildNodes,
            &InspectorBackendDispatcherImpl::DOM_querySelector,
            &InspectorBackendDispatcherImpl::DOM_querySelectorAll,
            &InspectorBackendDispatcherImpl::DOM_setNodeName,
            &InspectorBackendDispatcherImpl::DOM_setNodeValue,
            &InspectorBackendDispatcherImpl::DOM_removeNode,
            &InspectorBackendDispatcherImpl::DOM_setAttributeValue,
            &InspectorBackendDispatcherImpl::DOM_setAttributesAsText,
            &InspectorBackendDispatcherImpl::DOM_removeAttribute,
            &InspectorBackendDispatcherImpl::DOM_getOuterHTML,
            &InspectorBackendDispatcherImpl::DOM_setOuterHTML,
            &InspectorBackendDispatcherImpl::DOM_performSearch,
            &InspectorBackendDispatcherImpl::DOM_getSearchResults,
            &InspectorBackendDispatcherImpl::DOM_discardSearchResults,
            &InspectorBackendDispatcherImpl::DOM_requestNode,
            &InspectorBackendDispatcherImpl::DOM_setInspectModeEnabled,
            &InspectorBackendDispatcherImpl::DOM_highlightRect,
            &InspectorBackendDispatcherImpl::DOM_highlightQuad,
            &InspectorBackendDispatcherImpl::DOM_highlightNode,
            &InspectorBackendDispatcherImpl::DOM_hideHighlight,
            &InspectorBackendDispatcherImpl::DOM_highlightFrame,
            &InspectorBackendDispatcherImpl::DOM_pushNodeByPathToFrontend,
            &InspectorBackendDispatcherImpl::DOM_pushNodesByBackendIdsToFrontend,
            &InspectorBackendDispatcherImpl::DOM_setInspectedNode,
            &InspectorBackendDispatcherImpl::DOM_resolveNode,
            &InspectorBackendDispatcherImpl::DOM_getAttributes,
            &InspectorBackendDispatcherImpl::DOM_copyTo,
            &InspectorBackendDispatcherImpl::DOM_moveTo,
            &InspectorBackendDispatcherImpl::DOM_undo,
            &InspectorBackendDispatcherImpl::DOM_redo,
            &InspectorBackendDispatcherImpl::DOM_markUndoableState,
            &InspectorBackendDispatcherImpl::DOM_focus,
            &InspectorBackendDispatcherImpl::DOM_setFileInputFiles,
            &InspectorBackendDispatcherImpl::DOM_getBoxModel,
            &InspectorBackendDispatcherImpl::DOM_getNodeForLocation,
            &InspectorBackendDispatcherImpl::DOM_getRelayoutBoundary,
            &InspectorBackendDispatcherImpl::DOM_getHighlightObjectForTest,
            &InspectorBackendDispatcherImpl::CSS_enable,
            &InspectorBackendDispatcherImpl::CSS_disable,
            &InspectorBackendDispatcherImpl::CSS_getMatchedStylesForNode,
            &InspectorBackendDispatcherImpl::CSS_getInlineStylesForNode,
            &InspectorBackendDispatcherImpl::CSS_getComputedStyleForNode,
            &InspectorBackendDispatcherImpl::CSS_getPlatformFontsForNode,
            &InspectorBackendDispatcherImpl::CSS_getStyleSheetText,
            &InspectorBackendDispatcherImpl::CSS_setStyleSheetText,
            &InspectorBackendDispatcherImpl::CSS_setRuleSelector,
            &InspectorBackendDispatcherImpl::CSS_setStyleText,
            &InspectorBackendDispatcherImpl::CSS_setMediaText,
            &InspectorBackendDispatcherImpl::CSS_createStyleSheet,
            &InspectorBackendDispatcherImpl::CSS_addRule,
            &InspectorBackendDispatcherImpl::CSS_forcePseudoState,
            &InspectorBackendDispatcherImpl::CSS_getMediaQueries,
            &InspectorBackendDispatcherImpl::CSS_setEffectivePropertyValueForNode,
            &InspectorBackendDispatcherImpl::Timeline_enable,
            &InspectorBackendDispatcherImpl::Timeline_disable,
            &InspectorBackendDispatcherImpl::Timeline_start,
            &InspectorBackendDispatcherImpl::Timeline_stop,
            &InspectorBackendDispatcherImpl::Debugger_enable,
            &InspectorBackendDispatcherImpl::Debugger_disable,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpointsActive,
            &InspectorBackendDispatcherImpl::Debugger_setSkipAllPauses,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpointByUrl,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_removeBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_continueToLocation,
            &InspectorBackendDispatcherImpl::Debugger_stepOver,
            &InspectorBackendDispatcherImpl::Debugger_stepInto,
            &InspectorBackendDispatcherImpl::Debugger_stepOut,
            &InspectorBackendDispatcherImpl::Debugger_pause,
            &InspectorBackendDispatcherImpl::Debugger_resume,
            &InspectorBackendDispatcherImpl::Debugger_stepIntoAsync,
            &InspectorBackendDispatcherImpl::Debugger_searchInContent,
            &InspectorBackendDispatcherImpl::Debugger_canSetScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_setScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_restartFrame,
            &InspectorBackendDispatcherImpl::Debugger_getScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_getFunctionDetails,
            &InspectorBackendDispatcherImpl::Debugger_getGeneratorObjectDetails,
            &InspectorBackendDispatcherImpl::Debugger_getCollectionEntries,
            &InspectorBackendDispatcherImpl::Debugger_setPauseOnExceptions,
            &InspectorBackendDispatcherImpl::Debugger_evaluateOnCallFrame,
            &InspectorBackendDispatcherImpl::Debugger_compileScript,
            &InspectorBackendDispatcherImpl::Debugger_runScript,
            &InspectorBackendDispatcherImpl::Debugger_setVariableValue,
            &InspectorBackendDispatcherImpl::Debugger_getStepInPositions,
            &InspectorBackendDispatcherImpl::Debugger_getBacktrace,
            &InspectorBackendDispatcherImpl::Debugger_skipStackFrames,
            &InspectorBackendDispatcherImpl::Debugger_setAsyncCallStackDepth,
            &InspectorBackendDispatcherImpl::Debugger_enablePromiseTracker,
            &InspectorBackendDispatcherImpl::Debugger_disablePromiseTracker,
            &InspectorBackendDispatcherImpl::Debugger_getPromiseById,
            &InspectorBackendDispatcherImpl::Debugger_flushAsyncOperationEvents,
            &InspectorBackendDispatcherImpl::Debugger_setAsyncOperationBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_removeAsyncOperationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setDOMBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeDOMBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setEventListenerBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeEventListenerBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setInstrumentationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeInstrumentationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setXHRBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeXHRBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_getEventListeners,
            &InspectorBackendDispatcherImpl::Profiler_enable,
            &InspectorBackendDispatcherImpl::Profiler_disable,
            &InspectorBackendDispatcherImpl::Profiler_setSamplingInterval,
            &InspectorBackendDispatcherImpl::Profiler_start,
            &InspectorBackendDispatcherImpl::Profiler_stop,
            &InspectorBackendDispatcherImpl::HeapProfiler_enable,
            &InspectorBackendDispatcherImpl::HeapProfiler_disable,
            &InspectorBackendDispatcherImpl::HeapProfiler_startTrackingHeapObjects,
            &InspectorBackendDispatcherImpl::HeapProfiler_stopTrackingHeapObjects,
            &InspectorBackendDispatcherImpl::HeapProfiler_takeHeapSnapshot,
            &InspectorBackendDispatcherImpl::HeapProfiler_collectGarbage,
            &InspectorBackendDispatcherImpl::HeapProfiler_getObjectByHeapObjectId,
            &InspectorBackendDispatcherImpl::HeapProfiler_addInspectedHeapObject,
            &InspectorBackendDispatcherImpl::HeapProfiler_getHeapObjectId,
            &InspectorBackendDispatcherImpl::Worker_enable,
            &InspectorBackendDispatcherImpl::Worker_disable,
            &InspectorBackendDispatcherImpl::Worker_sendMessageToWorker,
            &InspectorBackendDispatcherImpl::Worker_connectToWorker,
            &InspectorBackendDispatcherImpl::Worker_disconnectFromWorker,
            &InspectorBackendDispatcherImpl::Worker_setAutoconnectToWorkers,
            &InspectorBackendDispatcherImpl::Input_dispatchTouchEvent,
            &InspectorBackendDispatcherImpl::LayerTree_enable,
            &InspectorBackendDispatcherImpl::LayerTree_disable,
            &InspectorBackendDispatcherImpl::LayerTree_compositingReasons,
            &InspectorBackendDispatcherImpl::LayerTree_makeSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_loadSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_releaseSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_profileSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_replaySnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_snapshotCommandLog,
            &InspectorBackendDispatcherImpl::DeviceOrientation_setDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::DeviceOrientation_clearDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::ScreenOrientation_setScreenOrientationOverride,
            &InspectorBackendDispatcherImpl::ScreenOrientation_clearScreenOrientationOverride,
            &InspectorBackendDispatcherImpl::Tracing_start,
            &InspectorBackendDispatcherImpl::Tracing_end,
            &InspectorBackendDispatcherImpl::Animation_enable,
            &InspectorBackendDispatcherImpl::Animation_disable,
            &InspectorBackendDispatcherImpl::Animation_getPlaybackRate,
            &InspectorBackendDispatcherImpl::Animation_setPlaybackRate,
            &InspectorBackendDispatcherImpl::Animation_setCurrentTime,
            &InspectorBackendDispatcherImpl::Animation_setTiming,
            &InspectorBackendDispatcherImpl::Accessibility_getAXNode,
        };
        for (size_t i = 0; i < kMethodNamesEnumSize; ++i)
            m_dispatchMap.add(commandName(static_cast<MethodNames>(i)), handlers[i]);

        // Initialize common errors.
        m_commonErrors.insert(ParseError, -32700);
        m_commonErrors.insert(InvalidRequest, -32600);
        m_commonErrors.insert(MethodNotFound, -32601);
        m_commonErrors.insert(InvalidParams, -32602);
        m_commonErrors.insert(InternalError, -32603);
        m_commonErrors.insert(ServerError, -32000);
    }

    virtual void clearFrontend() { m_inspectorFrontendChannel = 0; }
    virtual void dispatch(const String& message);
    virtual void reportProtocolError(int callId, CommonErrorCode, const String& errorMessage, PassRefPtr<JSONValue> data) const;
    using InspectorBackendDispatcher::reportProtocolError;

    void sendResponse(int callId, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData, PassRefPtr<JSONObject> result);
    bool isActive() { return m_inspectorFrontendChannel; }

    virtual void registerAgent(InspectorCommandHandler* inspectorAgent) { ASSERT(!m_inspectorAgent); m_inspectorAgent = inspectorAgent; }
    virtual void registerAgent(MemoryCommandHandler* memoryAgent) { ASSERT(!m_memoryAgent); m_memoryAgent = memoryAgent; }
    virtual void registerAgent(PageCommandHandler* pageAgent) { ASSERT(!m_pageAgent); m_pageAgent = pageAgent; }
    virtual void registerAgent(RenderingCommandHandler* renderingAgent) { ASSERT(!m_renderingAgent); m_renderingAgent = renderingAgent; }
    virtual void registerAgent(EmulationCommandHandler* emulationAgent) { ASSERT(!m_emulationAgent); m_emulationAgent = emulationAgent; }
    virtual void registerAgent(RuntimeCommandHandler* runtimeAgent) { ASSERT(!m_runtimeAgent); m_runtimeAgent = runtimeAgent; }
    virtual void registerAgent(ConsoleCommandHandler* consoleAgent) { ASSERT(!m_consoleAgent); m_consoleAgent = consoleAgent; }
    virtual void registerAgent(NetworkCommandHandler* networkAgent) { ASSERT(!m_networkAgent); m_networkAgent = networkAgent; }
    virtual void registerAgent(DatabaseCommandHandler* databaseAgent) { ASSERT(!m_databaseAgent); m_databaseAgent = databaseAgent; }
    virtual void registerAgent(IndexedDBCommandHandler* indexedDBAgent) { ASSERT(!m_indexedDBAgent); m_indexedDBAgent = indexedDBAgent; }
    virtual void registerAgent(CacheStorageCommandHandler* cacheStorageAgent) { ASSERT(!m_cacheStorageAgent); m_cacheStorageAgent = cacheStorageAgent; }
    virtual void registerAgent(DOMStorageCommandHandler* domStorageAgent) { ASSERT(!m_domStorageAgent); m_domStorageAgent = domStorageAgent; }
    virtual void registerAgent(ApplicationCacheCommandHandler* applicationCacheAgent) { ASSERT(!m_applicationCacheAgent); m_applicationCacheAgent = applicationCacheAgent; }
    virtual void registerAgent(FileSystemCommandHandler* fileSystemAgent) { ASSERT(!m_fileSystemAgent); m_fileSystemAgent = fileSystemAgent; }
    virtual void registerAgent(DOMCommandHandler* domAgent) { ASSERT(!m_domAgent); m_domAgent = domAgent; }
    virtual void registerAgent(CSSCommandHandler* cssAgent) { ASSERT(!m_cssAgent); m_cssAgent = cssAgent; }
    virtual void registerAgent(TimelineCommandHandler* timelineAgent) { ASSERT(!m_timelineAgent); m_timelineAgent = timelineAgent; }
    virtual void registerAgent(DebuggerCommandHandler* debuggerAgent) { ASSERT(!m_debuggerAgent); m_debuggerAgent = debuggerAgent; }
    virtual void registerAgent(DOMDebuggerCommandHandler* domDebuggerAgent) { ASSERT(!m_domDebuggerAgent); m_domDebuggerAgent = domDebuggerAgent; }
    virtual void registerAgent(ProfilerCommandHandler* profilerAgent) { ASSERT(!m_profilerAgent); m_profilerAgent = profilerAgent; }
    virtual void registerAgent(HeapProfilerCommandHandler* heapProfilerAgent) { ASSERT(!m_heapProfilerAgent); m_heapProfilerAgent = heapProfilerAgent; }
    virtual void registerAgent(WorkerCommandHandler* workerAgent) { ASSERT(!m_workerAgent); m_workerAgent = workerAgent; }
    virtual void registerAgent(ServiceWorkerCommandHandler* serviceWorkerAgent) { ASSERT(!m_serviceWorkerAgent); m_serviceWorkerAgent = serviceWorkerAgent; }
    virtual void registerAgent(InputCommandHandler* inputAgent) { ASSERT(!m_inputAgent); m_inputAgent = inputAgent; }
    virtual void registerAgent(LayerTreeCommandHandler* layerTreeAgent) { ASSERT(!m_layerTreeAgent); m_layerTreeAgent = layerTreeAgent; }
    virtual void registerAgent(DeviceOrientationCommandHandler* deviceOrientationAgent) { ASSERT(!m_deviceOrientationAgent); m_deviceOrientationAgent = deviceOrientationAgent; }
    virtual void registerAgent(ScreenOrientationCommandHandler* screenOrientationAgent) { ASSERT(!m_screenOrientationAgent); m_screenOrientationAgent = screenOrientationAgent; }
    virtual void registerAgent(TracingCommandHandler* tracingAgent) { ASSERT(!m_tracingAgent); m_tracingAgent = tracingAgent; }
    virtual void registerAgent(PowerCommandHandler* powerAgent) { ASSERT(!m_powerAgent); m_powerAgent = powerAgent; }
    virtual void registerAgent(AnimationCommandHandler* animationAgent) { ASSERT(!m_animationAgent); m_animationAgent = animationAgent; }
    virtual void registerAgent(AccessibilityCommandHandler* accessibilityAgent) { ASSERT(!m_accessibilityAgent); m_accessibilityAgent = accessibilityAgent; }
    virtual void registerAgent(SecurityCommandHandler* securityAgent) { ASSERT(!m_securityAgent); m_securityAgent = securityAgent; }
private:
    using CallHandler = void (InspectorBackendDispatcherImpl::*)(int callId, JSONObject* messageObject, JSONArray* protocolErrors);
    using DispatchMap = HashMap<String, CallHandler>;

    void Inspector_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Inspector_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Memory_getDOMCounters(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_addScriptToEvaluateOnLoad(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_removeScriptToEvaluateOnLoad(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_reload(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_navigate(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_getResourceTree(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_getResourceContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_searchInResource(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setDocumentContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setDeviceOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_clearDeviceOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setTouchEmulationEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_startScreencast(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_stopScreencast(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setShowViewportSizeOnResize(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setOverlayMessage(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setShowPaintRects(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setShowDebugBorders(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setShowFPSCounter(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setContinuousPaintingEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setShowScrollBottleneckRects(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_resetScrollAndPageScaleFactor(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setPageScaleFactor(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setScriptExecutionDisabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setTouchEmulationEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setEmulatedMedia(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_evaluate(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_callFunctionOn(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_getProperties(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_releaseObject(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_releaseObjectGroup(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_run(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_isRunRequired(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_setCustomObjectFormatterEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_clearMessages(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setUserAgentOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setExtraHTTPHeaders(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_getResponseBody(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_replayXHR(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setMonitoringXHREnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_canClearBrowserCache(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_canClearBrowserCookies(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_emulateNetworkConditions(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setCacheDisabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setDataSizeLimitsForTest(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_getDatabaseTableNames(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_executeSQL(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestDatabaseNames(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestDatabase(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestData(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_clearObjectStore(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CacheStorage_requestCacheNames(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CacheStorage_requestEntries(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CacheStorage_deleteCache(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CacheStorage_deleteEntry(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_getDOMStorageItems(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_setDOMStorageItem(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_removeDOMStorageItem(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getFramesWithManifests(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getManifestForFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getApplicationCacheForFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestFileSystemRoot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestDirectoryContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestMetadata(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestFileContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_deleteEntry(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getDocument(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_requestChildNodes(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_querySelector(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_querySelectorAll(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setNodeName(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setNodeValue(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_removeNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setAttributeValue(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setAttributesAsText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_removeAttribute(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getOuterHTML(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setOuterHTML(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_performSearch(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getSearchResults(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_discardSearchResults(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_requestNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setInspectModeEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightRect(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightQuad(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_hideHighlight(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_pushNodeByPathToFrontend(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_pushNodesByBackendIdsToFrontend(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setInspectedNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_resolveNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getAttributes(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_copyTo(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_moveTo(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_undo(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_redo(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_markUndoableState(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_focus(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setFileInputFiles(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getBoxModel(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getNodeForLocation(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getRelayoutBoundary(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getHighlightObjectForTest(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getMatchedStylesForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getInlineStylesForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getComputedStyleForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getPlatformFontsForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getStyleSheetText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setStyleSheetText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setRuleSelector(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setStyleText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setMediaText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_createStyleSheet(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_addRule(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_forcePseudoState(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getMediaQueries(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setEffectivePropertyValueForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Timeline_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Timeline_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Timeline_start(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Timeline_stop(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpointsActive(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setSkipAllPauses(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpointByUrl(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_removeBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_continueToLocation(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepOver(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepInto(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepOut(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_pause(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_resume(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepIntoAsync(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_searchInContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_canSetScriptSource(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setScriptSource(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_restartFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getScriptSource(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getFunctionDetails(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getGeneratorObjectDetails(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getCollectionEntries(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setPauseOnExceptions(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_evaluateOnCallFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_compileScript(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_runScript(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setVariableValue(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getStepInPositions(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getBacktrace(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_skipStackFrames(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setAsyncCallStackDepth(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_enablePromiseTracker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_disablePromiseTracker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getPromiseById(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_flushAsyncOperationEvents(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setAsyncOperationBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_removeAsyncOperationBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setDOMBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeDOMBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setEventListenerBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeEventListenerBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setInstrumentationBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeInstrumentationBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setXHRBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeXHRBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_getEventListeners(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_setSamplingInterval(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_start(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_stop(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_startTrackingHeapObjects(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_stopTrackingHeapObjects(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_takeHeapSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_collectGarbage(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_getObjectByHeapObjectId(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_addInspectedHeapObject(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_getHeapObjectId(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_sendMessageToWorker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_connectToWorker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_disconnectFromWorker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_setAutoconnectToWorkers(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Input_dispatchTouchEvent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_compositingReasons(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_makeSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_loadSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_releaseSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_profileSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_replaySnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_snapshotCommandLog(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DeviceOrientation_setDeviceOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DeviceOrientation_clearDeviceOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ScreenOrientation_setScreenOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ScreenOrientation_clearScreenOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Tracing_start(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Tracing_end(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_enable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_disable(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_getPlaybackRate(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_setPlaybackRate(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_setCurrentTime(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_setTiming(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Accessibility_getAXNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);

    InspectorFrontendChannel* m_inspectorFrontendChannel;
    InspectorCommandHandler* m_inspectorAgent;
    MemoryCommandHandler* m_memoryAgent;
    PageCommandHandler* m_pageAgent;
    RenderingCommandHandler* m_renderingAgent;
    EmulationCommandHandler* m_emulationAgent;
    RuntimeCommandHandler* m_runtimeAgent;
    ConsoleCommandHandler* m_consoleAgent;
    NetworkCommandHandler* m_networkAgent;
    DatabaseCommandHandler* m_databaseAgent;
    IndexedDBCommandHandler* m_indexedDBAgent;
    CacheStorageCommandHandler* m_cacheStorageAgent;
    DOMStorageCommandHandler* m_domStorageAgent;
    ApplicationCacheCommandHandler* m_applicationCacheAgent;
    FileSystemCommandHandler* m_fileSystemAgent;
    DOMCommandHandler* m_domAgent;
    CSSCommandHandler* m_cssAgent;
    TimelineCommandHandler* m_timelineAgent;
    DebuggerCommandHandler* m_debuggerAgent;
    DOMDebuggerCommandHandler* m_domDebuggerAgent;
    ProfilerCommandHandler* m_profilerAgent;
    HeapProfilerCommandHandler* m_heapProfilerAgent;
    WorkerCommandHandler* m_workerAgent;
    ServiceWorkerCommandHandler* m_serviceWorkerAgent;
    InputCommandHandler* m_inputAgent;
    LayerTreeCommandHandler* m_layerTreeAgent;
    DeviceOrientationCommandHandler* m_deviceOrientationAgent;
    ScreenOrientationCommandHandler* m_screenOrientationAgent;
    TracingCommandHandler* m_tracingAgent;
    PowerCommandHandler* m_powerAgent;
    AnimationCommandHandler* m_animationAgent;
    AccessibilityCommandHandler* m_accessibilityAgent;
    SecurityCommandHandler* m_securityAgent;

    template<typename R, typename V, typename V0>
    static R getPropertyValueImpl(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors, V0 initial_value, bool (*as_method)(JSONValue*, V*), const char* type_name);

    static int getInt(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static double getDouble(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static String getString(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static bool getBoolean(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static PassRefPtr<JSONObject> getObject(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static PassRefPtr<JSONArray> getArray(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);

    void sendResponse(int callId, ErrorString invocationError, PassRefPtr<JSONObject> result)
    {
        sendResponse(callId, invocationError, RefPtr<JSONValue>(), result);
    }
    void sendResponse(int callId, ErrorString invocationError)
    {
        sendResponse(callId, invocationError, RefPtr<JSONValue>(), JSONObject::create());
    }
    static const char InvalidParamsFormatString[];

    DispatchMap m_dispatchMap;
    Vector<int> m_commonErrors;
};

const char InspectorBackendDispatcherImpl::InvalidParamsFormatString[] = "Some arguments of method '%s' can't be processed";

void InspectorBackendDispatcherImpl::Inspector_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInspector_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inspectorAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Inspector_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInspector_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inspectorAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Memory_getDOMCounters(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_memoryAgent)
        protocolErrors->pushString("Memory handler is not available.");

    int out_documents;
    int out_nodes;
    int out_jsEventListeners;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kMemory_getDOMCountersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_memoryAgent->getDOMCounters(&error, &out_documents, &out_nodes, &out_jsEventListeners);
    if (!error.length()) {
        result->setNumber("documents", out_documents);
        result->setNumber("nodes", out_nodes);
        result->setNumber("jsEventListeners", out_jsEventListeners);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_addScriptToEvaluateOnLoad(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptSource = getString(paramsContainerPtr, "scriptSource", 0, protocolErrors);

    TypeBuilder::Page::ScriptIdentifier out_identifier;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_addScriptToEvaluateOnLoadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->addScriptToEvaluateOnLoad(&error, in_scriptSource, &out_identifier);
    if (!error.length()) {
        result->setString("identifier", out_identifier);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_removeScriptToEvaluateOnLoad(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_identifier = getString(paramsContainerPtr, "identifier", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_removeScriptToEvaluateOnLoadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->removeScriptToEvaluateOnLoad(&error, in_identifier);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_reload(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool ignoreCache_valueFound = false;
    bool in_ignoreCache = getBoolean(paramsContainerPtr, "ignoreCache", &ignoreCache_valueFound, protocolErrors);
    bool scriptToEvaluateOnLoad_valueFound = false;
    String in_scriptToEvaluateOnLoad = getString(paramsContainerPtr, "scriptToEvaluateOnLoad", &scriptToEvaluateOnLoad_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_reloadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->reload(&error, ignoreCache_valueFound ? &in_ignoreCache : 0, scriptToEvaluateOnLoad_valueFound ? &in_scriptToEvaluateOnLoad : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_navigate(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    TypeBuilder::Page::FrameId out_frameId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_navigateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->navigate(&error, in_url, &out_frameId);
    if (!error.length()) {
        result->setString("frameId", out_frameId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_getResourceTree(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<TypeBuilder::Page::FrameResourceTree> out_frameTree;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_getResourceTreeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->getResourceTree(&error, out_frameTree);
    if (!error.length()) {
        result->setValue("frameTree", out_frameTree);
    }
    sendResponse(callId, error, result);
}

InspectorBackendDispatcher::PageCommandHandler::GetResourceContentCallback::GetResourceContentCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::PageCommandHandler::GetResourceContentCallback::sendSuccess(const String& content, bool base64Encoded)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setString("content", content);
    jsonMessage->setBoolean("base64Encoded", base64Encoded);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Page_getResourceContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtrWillBeRawPtr<PageCommandHandler::GetResourceContentCallback> callback = adoptRefWillBeNoop(new PageCommandHandler::GetResourceContentCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_getResourceContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->getResourceContent(&error, in_frameId, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_searchInResource(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrors);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::SearchMatch> > out_result;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_searchInResourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->searchInResource(&error, in_frameId, in_url, in_query, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, out_result);
    if (!error.length()) {
        result->setValue("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_setDocumentContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_html = getString(paramsContainerPtr, "html", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setDocumentContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setDocumentContent(&error, in_frameId, in_html);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setDeviceOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_alpha = getDouble(paramsContainerPtr, "alpha", 0, protocolErrors);
    double in_beta = getDouble(paramsContainerPtr, "beta", 0, protocolErrors);
    double in_gamma = getDouble(paramsContainerPtr, "gamma", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->setDeviceOrientationOverride(&error, in_alpha, in_beta, in_gamma);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_clearDeviceOrientationOverride(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_clearDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->clearDeviceOrientationOverride(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setTouchEmulationEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);
    bool configuration_valueFound = false;
    String in_configuration = getString(paramsContainerPtr, "configuration", &configuration_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setTouchEmulationEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setTouchEmulationEnabled(&error, in_enabled, configuration_valueFound ? &in_configuration : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_startScreencast(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool format_valueFound = false;
    String in_format = getString(paramsContainerPtr, "format", &format_valueFound, protocolErrors);
    bool quality_valueFound = false;
    int in_quality = getInt(paramsContainerPtr, "quality", &quality_valueFound, protocolErrors);
    bool maxWidth_valueFound = false;
    int in_maxWidth = getInt(paramsContainerPtr, "maxWidth", &maxWidth_valueFound, protocolErrors);
    bool maxHeight_valueFound = false;
    int in_maxHeight = getInt(paramsContainerPtr, "maxHeight", &maxHeight_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_startScreencastCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->startScreencast(&error, format_valueFound ? &in_format : 0, quality_valueFound ? &in_quality : 0, maxWidth_valueFound ? &in_maxWidth : 0, maxHeight_valueFound ? &in_maxHeight : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_stopScreencast(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_stopScreencastCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->stopScreencast(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setShowViewportSizeOnResize(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);
    bool showGrid_valueFound = false;
    bool in_showGrid = getBoolean(paramsContainerPtr, "showGrid", &showGrid_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setShowViewportSizeOnResizeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setShowViewportSizeOnResize(&error, in_show, showGrid_valueFound ? &in_showGrid : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setOverlayMessage(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool message_valueFound = false;
    String in_message = getString(paramsContainerPtr, "message", &message_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setOverlayMessageCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setOverlayMessage(&error, message_valueFound ? &in_message : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setShowPaintRects(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_result = getBoolean(paramsContainerPtr, "result", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setShowPaintRectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setShowPaintRects(&error, in_result);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setShowDebugBorders(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setShowDebugBordersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setShowDebugBorders(&error, in_show);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setShowFPSCounter(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setShowFPSCounterCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setShowFPSCounter(&error, in_show);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setContinuousPaintingEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setContinuousPaintingEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setContinuousPaintingEnabled(&error, in_enabled);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setShowScrollBottleneckRects(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setShowScrollBottleneckRectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setShowScrollBottleneckRects(&error, in_show);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_resetScrollAndPageScaleFactor(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_resetScrollAndPageScaleFactorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->resetScrollAndPageScaleFactor(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setPageScaleFactor(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_pageScaleFactor = getDouble(paramsContainerPtr, "pageScaleFactor", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setPageScaleFactorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setPageScaleFactor(&error, in_pageScaleFactor);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setScriptExecutionDisabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_value = getBoolean(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setScriptExecutionDisabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setScriptExecutionDisabled(&error, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setTouchEmulationEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);
    bool configuration_valueFound = false;
    String in_configuration = getString(paramsContainerPtr, "configuration", &configuration_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setTouchEmulationEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setTouchEmulationEnabled(&error, in_enabled, configuration_valueFound ? &in_configuration : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setEmulatedMedia(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_media = getString(paramsContainerPtr, "media", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setEmulatedMediaCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setEmulatedMedia(&error, in_media);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_evaluate(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool includeCommandLineAPI_valueFound = false;
    bool in_includeCommandLineAPI = getBoolean(paramsContainerPtr, "includeCommandLineAPI", &includeCommandLineAPI_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool contextId_valueFound = false;
    int in_contextId = getInt(paramsContainerPtr, "contextId", &contextId_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;
    RefPtr<TypeBuilder::Debugger::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_evaluateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->evaluate(&error, in_expression, objectGroup_valueFound ? &in_objectGroup : 0, includeCommandLineAPI_valueFound ? &in_includeCommandLineAPI : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, contextId_valueFound ? &in_contextId : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", out_exceptionDetails);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_callFunctionOn(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    String in_functionDeclaration = getString(paramsContainerPtr, "functionDeclaration", 0, protocolErrors);
    bool arguments_valueFound = false;
    RefPtr<JSONArray> in_arguments = getArray(paramsContainerPtr, "arguments", &arguments_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_callFunctionOnCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->callFunctionOn(&error, in_objectId, in_functionDeclaration, arguments_valueFound ? &in_arguments : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_getProperties(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    bool ownProperties_valueFound = false;
    bool in_ownProperties = getBoolean(paramsContainerPtr, "ownProperties", &ownProperties_valueFound, protocolErrors);
    bool accessorPropertiesOnly_valueFound = false;
    bool in_accessorPropertiesOnly = getBoolean(paramsContainerPtr, "accessorPropertiesOnly", &accessorPropertiesOnly_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Runtime::PropertyDescriptor> > out_result;
    RefPtr<TypeBuilder::Array<TypeBuilder::Runtime::InternalPropertyDescriptor> > out_internalProperties;
    RefPtr<TypeBuilder::Debugger::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_getPropertiesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->getProperties(&error, in_objectId, ownProperties_valueFound ? &in_ownProperties : 0, accessorPropertiesOnly_valueFound ? &in_accessorPropertiesOnly : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, out_internalProperties, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_internalProperties)
            result->setValue("internalProperties", out_internalProperties);
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", out_exceptionDetails);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_releaseObject(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_releaseObjectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->releaseObject(&error, in_objectId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_releaseObjectGroup(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_releaseObjectGroupCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->releaseObjectGroup(&error, in_objectGroup);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_run(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_runCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->run(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_isRunRequired(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_isRunRequiredCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->isRunRequired(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_setCustomObjectFormatterEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_setCustomObjectFormatterEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->setCustomObjectFormatterEnabled(&error, in_enabled);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Console_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Console_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Console_clearMessages(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_clearMessagesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->clearMessages(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_setUserAgentOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_userAgent = getString(paramsContainerPtr, "userAgent", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setUserAgentOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setUserAgentOverride(&error, in_userAgent);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_setExtraHTTPHeaders(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_headers = getObject(paramsContainerPtr, "headers", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setExtraHTTPHeadersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setExtraHTTPHeaders(&error, in_headers);

    sendResponse(callId, error);
}

InspectorBackendDispatcher::NetworkCommandHandler::GetResponseBodyCallback::GetResponseBodyCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::NetworkCommandHandler::GetResponseBodyCallback::sendSuccess(const String& body, bool base64Encoded)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setString("body", body);
    jsonMessage->setBoolean("base64Encoded", base64Encoded);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Network_getResponseBody(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_requestId = getString(paramsContainerPtr, "requestId", 0, protocolErrors);
    RefPtrWillBeRawPtr<NetworkCommandHandler::GetResponseBodyCallback> callback = adoptRefWillBeNoop(new NetworkCommandHandler::GetResponseBodyCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_getResponseBodyCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->getResponseBody(&error, in_requestId, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_replayXHR(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_requestId = getString(paramsContainerPtr, "requestId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_replayXHRCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->replayXHR(&error, in_requestId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_setMonitoringXHREnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setMonitoringXHREnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setMonitoringXHREnabled(&error, in_enabled);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_canClearBrowserCache(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_canClearBrowserCacheCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_networkAgent->canClearBrowserCache(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Network_canClearBrowserCookies(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_canClearBrowserCookiesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_networkAgent->canClearBrowserCookies(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Network_emulateNetworkConditions(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_offline = getBoolean(paramsContainerPtr, "offline", 0, protocolErrors);
    double in_latency = getDouble(paramsContainerPtr, "latency", 0, protocolErrors);
    double in_downloadThroughput = getDouble(paramsContainerPtr, "downloadThroughput", 0, protocolErrors);
    double in_uploadThroughput = getDouble(paramsContainerPtr, "uploadThroughput", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_emulateNetworkConditionsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->emulateNetworkConditions(&error, in_offline, in_latency, in_downloadThroughput, in_uploadThroughput);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_setCacheDisabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_cacheDisabled = getBoolean(paramsContainerPtr, "cacheDisabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setCacheDisabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setCacheDisabled(&error, in_cacheDisabled);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_setDataSizeLimitsForTest(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_maxTotalSize = getInt(paramsContainerPtr, "maxTotalSize", 0, protocolErrors);
    int in_maxResourceSize = getInt(paramsContainerPtr, "maxResourceSize", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setDataSizeLimitsForTestCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setDataSizeLimitsForTest(&error, in_maxTotalSize, in_maxResourceSize);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Database_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Database_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Database_getDatabaseTableNames(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_databaseId = getString(paramsContainerPtr, "databaseId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_tableNames;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_getDatabaseTableNamesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_databaseAgent->getDatabaseTableNames(&error, in_databaseId, out_tableNames);
    if (!error.length()) {
        result->setValue("tableNames", out_tableNames);
    }
    sendResponse(callId, error, result);
}

InspectorBackendDispatcher::DatabaseCommandHandler::ExecuteSQLCallback::ExecuteSQLCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::DatabaseCommandHandler::ExecuteSQLCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<String> > columnNames, PassRefPtr<TypeBuilder::Array<JSONValue> > values, PassRefPtr<TypeBuilder::Database::Error> sqlError)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    if (columnNames)
        jsonMessage->setValue("columnNames", columnNames);
    if (values)
        jsonMessage->setValue("values", values);
    if (sqlError)
        jsonMessage->setValue("sqlError", sqlError);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Database_executeSQL(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_databaseId = getString(paramsContainerPtr, "databaseId", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    RefPtrWillBeRawPtr<DatabaseCommandHandler::ExecuteSQLCallback> callback = adoptRefWillBeNoop(new DatabaseCommandHandler::ExecuteSQLCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_executeSQLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->executeSQL(&error, in_databaseId, in_query, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->disable(&error);

    sendResponse(callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseNamesCallback::RequestDatabaseNamesCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseNamesCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<String> > databaseNames)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("databaseNames", databaseNames);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestDatabaseNames(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    RefPtrWillBeRawPtr<IndexedDBCommandHandler::RequestDatabaseNamesCallback> callback = adoptRefWillBeNoop(new IndexedDBCommandHandler::RequestDatabaseNamesCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDatabaseNamesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestDatabaseNames(&error, in_securityOrigin, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseCallback::RequestDatabaseCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseCallback::sendSuccess(PassRefPtr<TypeBuilder::IndexedDB::DatabaseWithObjectStores> databaseWithObjectStores)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("databaseWithObjectStores", databaseWithObjectStores);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestDatabase(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    RefPtrWillBeRawPtr<IndexedDBCommandHandler::RequestDatabaseCallback> callback = adoptRefWillBeNoop(new IndexedDBCommandHandler::RequestDatabaseCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDatabaseCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestDatabase(&error, in_securityOrigin, in_databaseName, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDataCallback::RequestDataCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDataCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::DataEntry> > objectStoreDataEntries, bool hasMore)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("objectStoreDataEntries", objectStoreDataEntries);
    jsonMessage->setBoolean("hasMore", hasMore);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestData(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    String in_objectStoreName = getString(paramsContainerPtr, "objectStoreName", 0, protocolErrors);
    String in_indexName = getString(paramsContainerPtr, "indexName", 0, protocolErrors);
    int in_skipCount = getInt(paramsContainerPtr, "skipCount", 0, protocolErrors);
    int in_pageSize = getInt(paramsContainerPtr, "pageSize", 0, protocolErrors);
    bool keyRange_valueFound = false;
    RefPtr<JSONObject> in_keyRange = getObject(paramsContainerPtr, "keyRange", &keyRange_valueFound, protocolErrors);
    RefPtrWillBeRawPtr<IndexedDBCommandHandler::RequestDataCallback> callback = adoptRefWillBeNoop(new IndexedDBCommandHandler::RequestDataCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDataCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestData(&error, in_securityOrigin, in_databaseName, in_objectStoreName, in_indexName, in_skipCount, in_pageSize, keyRange_valueFound ? &in_keyRange : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::ClearObjectStoreCallback::ClearObjectStoreCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::ClearObjectStoreCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_clearObjectStore(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    String in_objectStoreName = getString(paramsContainerPtr, "objectStoreName", 0, protocolErrors);
    RefPtrWillBeRawPtr<IndexedDBCommandHandler::ClearObjectStoreCallback> callback = adoptRefWillBeNoop(new IndexedDBCommandHandler::ClearObjectStoreCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_clearObjectStoreCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->clearObjectStore(&error, in_securityOrigin, in_databaseName, in_objectStoreName, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::CacheStorageCommandHandler::RequestCacheNamesCallback::RequestCacheNamesCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::CacheStorageCommandHandler::RequestCacheNamesCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<TypeBuilder::CacheStorage::Cache> > caches)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("caches", caches);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CacheStorage_requestCacheNames(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cacheStorageAgent)
        protocolErrors->pushString("CacheStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    RefPtrWillBeRawPtr<CacheStorageCommandHandler::RequestCacheNamesCallback> callback = adoptRefWillBeNoop(new CacheStorageCommandHandler::RequestCacheNamesCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCacheStorage_requestCacheNamesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cacheStorageAgent->requestCacheNames(&error, in_securityOrigin, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::CacheStorageCommandHandler::RequestEntriesCallback::RequestEntriesCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::CacheStorageCommandHandler::RequestEntriesCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<TypeBuilder::CacheStorage::DataEntry> > cacheDataEntries, bool hasMore)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("cacheDataEntries", cacheDataEntries);
    jsonMessage->setBoolean("hasMore", hasMore);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CacheStorage_requestEntries(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cacheStorageAgent)
        protocolErrors->pushString("CacheStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_cacheId = getString(paramsContainerPtr, "cacheId", 0, protocolErrors);
    int in_skipCount = getInt(paramsContainerPtr, "skipCount", 0, protocolErrors);
    int in_pageSize = getInt(paramsContainerPtr, "pageSize", 0, protocolErrors);
    RefPtrWillBeRawPtr<CacheStorageCommandHandler::RequestEntriesCallback> callback = adoptRefWillBeNoop(new CacheStorageCommandHandler::RequestEntriesCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCacheStorage_requestEntriesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cacheStorageAgent->requestEntries(&error, in_cacheId, in_skipCount, in_pageSize, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::CacheStorageCommandHandler::DeleteCacheCallback::DeleteCacheCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::CacheStorageCommandHandler::DeleteCacheCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CacheStorage_deleteCache(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cacheStorageAgent)
        protocolErrors->pushString("CacheStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_cacheId = getString(paramsContainerPtr, "cacheId", 0, protocolErrors);
    RefPtrWillBeRawPtr<CacheStorageCommandHandler::DeleteCacheCallback> callback = adoptRefWillBeNoop(new CacheStorageCommandHandler::DeleteCacheCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCacheStorage_deleteCacheCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cacheStorageAgent->deleteCache(&error, in_cacheId, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::CacheStorageCommandHandler::DeleteEntryCallback::DeleteEntryCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::CacheStorageCommandHandler::DeleteEntryCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CacheStorage_deleteEntry(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cacheStorageAgent)
        protocolErrors->pushString("CacheStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_cacheId = getString(paramsContainerPtr, "cacheId", 0, protocolErrors);
    String in_request = getString(paramsContainerPtr, "request", 0, protocolErrors);
    RefPtrWillBeRawPtr<CacheStorageCommandHandler::DeleteEntryCallback> callback = adoptRefWillBeNoop(new CacheStorageCommandHandler::DeleteEntryCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCacheStorage_deleteEntryCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cacheStorageAgent->deleteEntry(&error, in_cacheId, in_request, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_getDOMStorageItems(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Array<String> > > out_entries;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_getDOMStorageItemsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domStorageAgent->getDOMStorageItems(&error, in_storageId, out_entries);
    if (!error.length()) {
        result->setValue("entries", out_entries);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOMStorage_setDOMStorageItem(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);
    String in_key = getString(paramsContainerPtr, "key", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_setDOMStorageItemCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->setDOMStorageItem(&error, in_storageId, in_key, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_removeDOMStorageItem(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);
    String in_key = getString(paramsContainerPtr, "key", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_removeDOMStorageItemCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->removeDOMStorageItem(&error, in_storageId, in_key);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getFramesWithManifests(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::ApplicationCache::FrameWithManifest> > out_frameIds;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getFramesWithManifestsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getFramesWithManifests(&error, out_frameIds);
    if (!error.length()) {
        result->setValue("frameIds", out_frameIds);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::ApplicationCache_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_applicationCacheAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getManifestForFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    String out_manifestURL;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getManifestForFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getManifestForFrame(&error, in_frameId, &out_manifestURL);
    if (!error.length()) {
        result->setString("manifestURL", out_manifestURL);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getApplicationCacheForFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    RefPtr<TypeBuilder::ApplicationCache::ApplicationCache> out_applicationCache;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getApplicationCacheForFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getApplicationCacheForFrame(&error, in_frameId, out_applicationCache);
    if (!error.length()) {
        result->setValue("applicationCache", out_applicationCache);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::FileSystem_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::FileSystem_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->disable(&error);

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileSystemRootCallback::RequestFileSystemRootCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileSystemRootCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::FileSystem::Entry> root)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (root)
        jsonMessage->setValue("root", root);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestFileSystemRoot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_origin = getString(paramsContainerPtr, "origin", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::RequestFileSystemRootCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::RequestFileSystemRootCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestFileSystemRootCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestFileSystemRoot(&error, in_origin, in_type, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestDirectoryContentCallback::RequestDirectoryContentCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestDirectoryContentCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::Array<TypeBuilder::FileSystem::Entry> > entries)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (entries)
        jsonMessage->setValue("entries", entries);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestDirectoryContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::RequestDirectoryContentCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::RequestDirectoryContentCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestDirectoryContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestDirectoryContent(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestMetadataCallback::RequestMetadataCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestMetadataCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::FileSystem::Metadata> metadata)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (metadata)
        jsonMessage->setValue("metadata", metadata);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestMetadata(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::RequestMetadataCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::RequestMetadataCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestMetadataCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestMetadata(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileContentCallback::RequestFileContentCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileContentCallback::sendSuccess(int errorCode, const String* const content, const String* const charset)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (content)
        jsonMessage->setString("content", *content);
    if (charset)
        jsonMessage->setString("charset", *charset);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestFileContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    bool in_readAsText = getBoolean(paramsContainerPtr, "readAsText", 0, protocolErrors);
    bool start_valueFound = false;
    int in_start = getInt(paramsContainerPtr, "start", &start_valueFound, protocolErrors);
    bool end_valueFound = false;
    int in_end = getInt(paramsContainerPtr, "end", &end_valueFound, protocolErrors);
    bool charset_valueFound = false;
    String in_charset = getString(paramsContainerPtr, "charset", &charset_valueFound, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::RequestFileContentCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::RequestFileContentCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestFileContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestFileContent(&error, in_url, in_readAsText, start_valueFound ? &in_start : 0, end_valueFound ? &in_end : 0, charset_valueFound ? &in_charset : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::DeleteEntryCallback::DeleteEntryCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::DeleteEntryCallback::sendSuccess(int errorCode)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_deleteEntry(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::DeleteEntryCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::DeleteEntryCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_deleteEntryCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->deleteEntry(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getDocument(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::DOM::Node> out_root;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getDocumentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getDocument(&error, out_root);
    if (!error.length()) {
        result->setValue("root", out_root);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_requestChildNodes(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool depth_valueFound = false;
    int in_depth = getInt(paramsContainerPtr, "depth", &depth_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_requestChildNodesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->requestChildNodes(&error, in_nodeId, depth_valueFound ? &in_depth : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_querySelector(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_querySelectorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->querySelector(&error, in_nodeId, in_selector, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_querySelectorAll(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_querySelectorAllCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->querySelectorAll(&error, in_nodeId, in_selector, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setNodeName(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setNodeNameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->setNodeName(&error, in_nodeId, in_name, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setNodeValue(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setNodeValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setNodeValue(&error, in_nodeId, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_removeNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_removeNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->removeNode(&error, in_nodeId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setAttributeValue(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setAttributeValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setAttributeValue(&error, in_nodeId, in_name, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setAttributesAsText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);
    bool name_valueFound = false;
    String in_name = getString(paramsContainerPtr, "name", &name_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setAttributesAsTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setAttributesAsText(&error, in_nodeId, in_text, name_valueFound ? &in_name : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_removeAttribute(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_removeAttributeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->removeAttribute(&error, in_nodeId, in_name);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getOuterHTML(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    String out_outerHTML;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getOuterHTMLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getOuterHTML(&error, in_nodeId, &out_outerHTML);
    if (!error.length()) {
        result->setString("outerHTML", out_outerHTML);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setOuterHTML(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_outerHTML = getString(paramsContainerPtr, "outerHTML", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setOuterHTMLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setOuterHTML(&error, in_nodeId, in_outerHTML);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_performSearch(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    bool includeUserAgentShadowDOM_valueFound = false;
    bool in_includeUserAgentShadowDOM = getBoolean(paramsContainerPtr, "includeUserAgentShadowDOM", &includeUserAgentShadowDOM_valueFound, protocolErrors);

    String out_searchId;
    int out_resultCount;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_performSearchCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->performSearch(&error, in_query, includeUserAgentShadowDOM_valueFound ? &in_includeUserAgentShadowDOM : 0, &out_searchId, &out_resultCount);
    if (!error.length()) {
        result->setString("searchId", out_searchId);
        result->setNumber("resultCount", out_resultCount);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getSearchResults(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_searchId = getString(paramsContainerPtr, "searchId", 0, protocolErrors);
    int in_fromIndex = getInt(paramsContainerPtr, "fromIndex", 0, protocolErrors);
    int in_toIndex = getInt(paramsContainerPtr, "toIndex", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getSearchResultsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getSearchResults(&error, in_searchId, in_fromIndex, in_toIndex, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_discardSearchResults(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_searchId = getString(paramsContainerPtr, "searchId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_discardSearchResultsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->discardSearchResults(&error, in_searchId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_requestNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_requestNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->requestNode(&error, in_objectId, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setInspectModeEnabled(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);
    bool inspectUAShadowDOM_valueFound = false;
    bool in_inspectUAShadowDOM = getBoolean(paramsContainerPtr, "inspectUAShadowDOM", &inspectUAShadowDOM_valueFound, protocolErrors);
    bool highlightConfig_valueFound = false;
    RefPtr<JSONObject> in_highlightConfig = getObject(paramsContainerPtr, "highlightConfig", &highlightConfig_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setInspectModeEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setInspectModeEnabled(&error, in_enabled, inspectUAShadowDOM_valueFound ? &in_inspectUAShadowDOM : 0, highlightConfig_valueFound ? &in_highlightConfig : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightRect(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_x = getInt(paramsContainerPtr, "x", 0, protocolErrors);
    int in_y = getInt(paramsContainerPtr, "y", 0, protocolErrors);
    int in_width = getInt(paramsContainerPtr, "width", 0, protocolErrors);
    int in_height = getInt(paramsContainerPtr, "height", 0, protocolErrors);
    bool color_valueFound = false;
    RefPtr<JSONObject> in_color = getObject(paramsContainerPtr, "color", &color_valueFound, protocolErrors);
    bool outlineColor_valueFound = false;
    RefPtr<JSONObject> in_outlineColor = getObject(paramsContainerPtr, "outlineColor", &outlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightRectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightRect(&error, in_x, in_y, in_width, in_height, color_valueFound ? &in_color : 0, outlineColor_valueFound ? &in_outlineColor : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightQuad(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_quad = getArray(paramsContainerPtr, "quad", 0, protocolErrors);
    bool color_valueFound = false;
    RefPtr<JSONObject> in_color = getObject(paramsContainerPtr, "color", &color_valueFound, protocolErrors);
    bool outlineColor_valueFound = false;
    RefPtr<JSONObject> in_outlineColor = getObject(paramsContainerPtr, "outlineColor", &outlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightQuadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightQuad(&error, in_quad, color_valueFound ? &in_color : 0, outlineColor_valueFound ? &in_outlineColor : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_highlightConfig = getObject(paramsContainerPtr, "highlightConfig", 0, protocolErrors);
    bool nodeId_valueFound = false;
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", &nodeId_valueFound, protocolErrors);
    bool backendNodeId_valueFound = false;
    int in_backendNodeId = getInt(paramsContainerPtr, "backendNodeId", &backendNodeId_valueFound, protocolErrors);
    bool objectId_valueFound = false;
    String in_objectId = getString(paramsContainerPtr, "objectId", &objectId_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightNode(&error, in_highlightConfig, nodeId_valueFound ? &in_nodeId : 0, backendNodeId_valueFound ? &in_backendNodeId : 0, objectId_valueFound ? &in_objectId : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_hideHighlight(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_hideHighlightCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->hideHighlight(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    bool contentColor_valueFound = false;
    RefPtr<JSONObject> in_contentColor = getObject(paramsContainerPtr, "contentColor", &contentColor_valueFound, protocolErrors);
    bool contentOutlineColor_valueFound = false;
    RefPtr<JSONObject> in_contentOutlineColor = getObject(paramsContainerPtr, "contentOutlineColor", &contentOutlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightFrame(&error, in_frameId, contentColor_valueFound ? &in_contentColor : 0, contentOutlineColor_valueFound ? &in_contentOutlineColor : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_pushNodeByPathToFrontend(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_path = getString(paramsContainerPtr, "path", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_pushNodeByPathToFrontendCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->pushNodeByPathToFrontend(&error, in_path, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_pushNodesByBackendIdsToFrontend(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_backendNodeIds = getArray(paramsContainerPtr, "backendNodeIds", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_pushNodesByBackendIdsToFrontendCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->pushNodesByBackendIdsToFrontend(&error, in_backendNodeIds, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setInspectedNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setInspectedNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setInspectedNode(&error, in_nodeId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_resolveNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_object;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_resolveNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->resolveNode(&error, in_nodeId, objectGroup_valueFound ? &in_objectGroup : 0, out_object);
    if (!error.length()) {
        result->setValue("object", out_object);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getAttributes(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_attributes;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getAttributesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getAttributes(&error, in_nodeId, out_attributes);
    if (!error.length()) {
        result->setValue("attributes", out_attributes);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_copyTo(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    int in_targetNodeId = getInt(paramsContainerPtr, "targetNodeId", 0, protocolErrors);
    bool insertBeforeNodeId_valueFound = false;
    int in_insertBeforeNodeId = getInt(paramsContainerPtr, "insertBeforeNodeId", &insertBeforeNodeId_valueFound, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_copyToCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->copyTo(&error, in_nodeId, in_targetNodeId, insertBeforeNodeId_valueFound ? &in_insertBeforeNodeId : 0, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_moveTo(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    int in_targetNodeId = getInt(paramsContainerPtr, "targetNodeId", 0, protocolErrors);
    bool insertBeforeNodeId_valueFound = false;
    int in_insertBeforeNodeId = getInt(paramsContainerPtr, "insertBeforeNodeId", &insertBeforeNodeId_valueFound, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_moveToCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->moveTo(&error, in_nodeId, in_targetNodeId, insertBeforeNodeId_valueFound ? &in_insertBeforeNodeId : 0, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_undo(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_undoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->undo(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_redo(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_redoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->redo(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_markUndoableState(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_markUndoableStateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->markUndoableState(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_focus(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_focusCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->focus(&error, in_nodeId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setFileInputFiles(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    RefPtr<JSONArray> in_files = getArray(paramsContainerPtr, "files", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setFileInputFilesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setFileInputFiles(&error, in_nodeId, in_files);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getBoxModel(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::DOM::BoxModel> out_model;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getBoxModelCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getBoxModel(&error, in_nodeId, out_model);
    if (!error.length()) {
        result->setValue("model", out_model);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getNodeForLocation(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_x = getInt(paramsContainerPtr, "x", 0, protocolErrors);
    int in_y = getInt(paramsContainerPtr, "y", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getNodeForLocationCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getNodeForLocation(&error, in_x, in_y, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getRelayoutBoundary(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getRelayoutBoundaryCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getRelayoutBoundary(&error, in_nodeId, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getHighlightObjectForTest(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<JSONObject> out_highlight;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getHighlightObjectForTestCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getHighlightObjectForTest(&error, in_nodeId, out_highlight);
    if (!error.length()) {
        result->setValue("highlight", out_highlight);
    }
    sendResponse(callId, error, result);
}

InspectorBackendDispatcher::CSSCommandHandler::EnableCallback::EnableCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::CSSCommandHandler::EnableCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CSS_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");
    RefPtrWillBeRawPtr<CSSCommandHandler::EnableCallback> callback = adoptRefWillBeNoop(new CSSCommandHandler::EnableCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->enable(&error, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::CSS_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::CSS_getMatchedStylesForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool excludePseudo_valueFound = false;
    bool in_excludePseudo = getBoolean(paramsContainerPtr, "excludePseudo", &excludePseudo_valueFound, protocolErrors);
    bool excludeInherited_valueFound = false;
    bool in_excludeInherited = getBoolean(paramsContainerPtr, "excludeInherited", &excludeInherited_valueFound, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSStyle> out_inlineStyle;
    RefPtr<TypeBuilder::CSS::CSSStyle> out_attributesStyle;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::RuleMatch> > out_matchedCSSRules;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::PseudoIdMatches> > out_pseudoElements;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::InheritedStyleEntry> > out_inherited;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getMatchedStylesForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getMatchedStylesForNode(&error, in_nodeId, excludePseudo_valueFound ? &in_excludePseudo : 0, excludeInherited_valueFound ? &in_excludeInherited : 0, out_inlineStyle, out_attributesStyle, out_matchedCSSRules, out_pseudoElements, out_inherited);
    if (!error.length()) {
//         if (out_inlineStyle)
//             result->setValue("inlineStyle", out_inlineStyle);
//         if (out_attributesStyle)
//             result->setValue("attributesStyle", out_attributesStyle);
        if (out_matchedCSSRules)
            result->setValue("matchedCSSRules", out_matchedCSSRules);
        if (out_pseudoElements)
            result->setValue("pseudoElements", out_pseudoElements);
        if (out_inherited)
            result->setValue("inherited", out_inherited);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getInlineStylesForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSStyle> out_inlineStyle;
    RefPtr<TypeBuilder::CSS::CSSStyle> out_attributesStyle;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getInlineStylesForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getInlineStylesForNode(&error, in_nodeId, out_inlineStyle, out_attributesStyle);
    if (!error.length()) {
        if (out_inlineStyle)
            result->setValue("inlineStyle", out_inlineStyle);
        if (out_attributesStyle)
            result->setValue("attributesStyle", out_attributesStyle);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getComputedStyleForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSComputedStyleProperty> > out_computedStyle;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getComputedStyleForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getComputedStyleForNode(&error, in_nodeId, out_computedStyle);
    if (!error.length()) {
        result->setValue("computedStyle", out_computedStyle);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getPlatformFontsForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::PlatformFontUsage> > out_fonts;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getPlatformFontsForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getPlatformFontsForNode(&error, in_nodeId, out_fonts);
    if (!error.length()) {
        result->setValue("fonts", out_fonts);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getStyleSheetText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);

    String out_text;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getStyleSheetTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getStyleSheetText(&error, in_styleSheetId, &out_text);
    if (!error.length()) {
        result->setString("text", out_text);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setStyleSheetText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setStyleSheetTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->setStyleSheetText(&error, in_styleSheetId, in_text);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::CSS_setRuleSelector(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSRule> out_rule;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setRuleSelectorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setRuleSelector(&error, in_styleSheetId, in_range, in_selector, out_rule);
    if (!error.length()) {
        result->setValue("rule", out_rule);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setStyleText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSStyle> out_style;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setStyleTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setStyleText(&error, in_styleSheetId, in_range, in_text, out_style);
    if (!error.length()) {
        result->setValue("style", out_style);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setMediaText(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSMedia> out_media;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setMediaTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setMediaText(&error, in_styleSheetId, in_range, in_text, out_media);
    if (!error.length()) {
        result->setValue("media", out_media);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_createStyleSheet(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    TypeBuilder::CSS::StyleSheetId out_styleSheetId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_createStyleSheetCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->createStyleSheet(&error, in_frameId, &out_styleSheetId);
    if (!error.length()) {
        result->setString("styleSheetId", out_styleSheetId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_addRule(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    String in_ruleText = getString(paramsContainerPtr, "ruleText", 0, protocolErrors);
    RefPtr<JSONObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSRule> out_rule;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_addRuleCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->addRule(&error, in_styleSheetId, in_ruleText, in_location, out_rule);
    if (!error.length()) {
        result->setValue("rule", out_rule);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_forcePseudoState(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    RefPtr<JSONArray> in_forcedPseudoClasses = getArray(paramsContainerPtr, "forcedPseudoClasses", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_forcePseudoStateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->forcePseudoState(&error, in_nodeId, in_forcedPseudoClasses);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::CSS_getMediaQueries(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSMedia> > out_medias;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getMediaQueriesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getMediaQueries(&error, out_medias);
    if (!error.length()) {
        result->setValue("medias", out_medias);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setEffectivePropertyValueForNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_propertyName = getString(paramsContainerPtr, "propertyName", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setEffectivePropertyValueForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->setEffectivePropertyValueForNode(&error, in_nodeId, in_propertyName, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Timeline_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTimeline_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_timelineAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Timeline_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTimeline_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_timelineAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Timeline_start(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool maxCallStackDepth_valueFound = false;
    int in_maxCallStackDepth = getInt(paramsContainerPtr, "maxCallStackDepth", &maxCallStackDepth_valueFound, protocolErrors);
    bool bufferEvents_valueFound = false;
    bool in_bufferEvents = getBoolean(paramsContainerPtr, "bufferEvents", &bufferEvents_valueFound, protocolErrors);
    bool liveEvents_valueFound = false;
    String in_liveEvents = getString(paramsContainerPtr, "liveEvents", &liveEvents_valueFound, protocolErrors);
    bool includeCounters_valueFound = false;
    bool in_includeCounters = getBoolean(paramsContainerPtr, "includeCounters", &includeCounters_valueFound, protocolErrors);
    bool includeGPUEvents_valueFound = false;
    bool in_includeGPUEvents = getBoolean(paramsContainerPtr, "includeGPUEvents", &includeGPUEvents_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTimeline_startCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_timelineAgent->start(&error, maxCallStackDepth_valueFound ? &in_maxCallStackDepth : 0, bufferEvents_valueFound ? &in_bufferEvents : 0, liveEvents_valueFound ? &in_liveEvents : 0, includeCounters_valueFound ? &in_includeCounters : 0, includeGPUEvents_valueFound ? &in_includeGPUEvents : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Timeline_stop(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTimeline_stopCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_timelineAgent->stop(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpointsActive(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_active = getBoolean(paramsContainerPtr, "active", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointsActiveCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setBreakpointsActive(&error, in_active);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setSkipAllPauses(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_skipped = getBoolean(paramsContainerPtr, "skipped", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setSkipAllPausesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setSkipAllPauses(&error, in_skipped);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpointByUrl(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_lineNumber = getInt(paramsContainerPtr, "lineNumber", 0, protocolErrors);
    bool url_valueFound = false;
    String in_url = getString(paramsContainerPtr, "url", &url_valueFound, protocolErrors);
    bool urlRegex_valueFound = false;
    String in_urlRegex = getString(paramsContainerPtr, "urlRegex", &urlRegex_valueFound, protocolErrors);
    bool columnNumber_valueFound = false;
    int in_columnNumber = getInt(paramsContainerPtr, "columnNumber", &columnNumber_valueFound, protocolErrors);
    bool condition_valueFound = false;
    String in_condition = getString(paramsContainerPtr, "condition", &condition_valueFound, protocolErrors);

    TypeBuilder::Debugger::BreakpointId out_breakpointId;
    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Location> > out_locations;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointByUrlCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setBreakpointByUrl(&error, in_lineNumber, url_valueFound ? &in_url : 0, urlRegex_valueFound ? &in_urlRegex : 0, columnNumber_valueFound ? &in_columnNumber : 0, condition_valueFound ? &in_condition : 0, &out_breakpointId, out_locations);
    if (!error.length()) {
        result->setString("breakpointId", out_breakpointId);
        result->setValue("locations", out_locations);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrors);
    bool condition_valueFound = false;
    String in_condition = getString(paramsContainerPtr, "condition", &condition_valueFound, protocolErrors);

    TypeBuilder::Debugger::BreakpointId out_breakpointId;
    RefPtr<TypeBuilder::Debugger::Location> out_actualLocation;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setBreakpoint(&error, in_location, condition_valueFound ? &in_condition : 0, &out_breakpointId, out_actualLocation);
    if (!error.length()) {
        result->setString("breakpointId", out_breakpointId);
        result->setValue("actualLocation", out_actualLocation);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_removeBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_breakpointId = getString(paramsContainerPtr, "breakpointId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_removeBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->removeBreakpoint(&error, in_breakpointId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_continueToLocation(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrors);
    bool interstatementLocation_valueFound = false;
    bool in_interstatementLocation = getBoolean(paramsContainerPtr, "interstatementLocation", &interstatementLocation_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_continueToLocationCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->continueToLocation(&error, in_location, interstatementLocation_valueFound ? &in_interstatementLocation : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepOver(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepOverCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepOver(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepInto(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepIntoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepInto(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepOut(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepOutCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepOut(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_pause(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_pauseCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->pause(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_resume(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_resumeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->resume(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepIntoAsync(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepIntoAsyncCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepIntoAsync(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_searchInContent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrors);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::SearchMatch> > out_result;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_searchInContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->searchInContent(&error, in_scriptId, in_query, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, out_result);
    if (!error.length()) {
        result->setValue("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_canSetScriptSource(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_canSetScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->canSetScriptSource(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setScriptSource(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");
    RefPtr<TypeBuilder::Debugger::SetScriptSourceError> errorData;

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    String in_scriptSource = getString(paramsContainerPtr, "scriptSource", 0, protocolErrors);
    bool preview_valueFound = false;
    bool in_preview = getBoolean(paramsContainerPtr, "preview", &preview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<JSONObject> out_result;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setScriptSource(&error, errorData, in_scriptId, in_scriptSource, preview_valueFound ? &in_preview : 0, out_callFrames, out_result, out_asyncStackTrace);
    if (!error.length()) {
        if (out_callFrames)
            result->setValue("callFrames", out_callFrames);
        if (out_result)
            result->setValue("result", out_result);
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", out_asyncStackTrace);
    }
    sendResponse(callId, error, errorData, result);
}

void InspectorBackendDispatcherImpl::Debugger_restartFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<JSONObject> out_result;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_restartFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->restartFrame(&error, in_callFrameId, out_callFrames, out_result, out_asyncStackTrace);
    if (!error.length()) {
        result->setValue("callFrames", out_callFrames);
        result->setValue("result", out_result);
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", out_asyncStackTrace);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getScriptSource(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);

    String out_scriptSource;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getScriptSource(&error, in_scriptId, &out_scriptSource);
    if (!error.length()) {
        result->setString("scriptSource", out_scriptSource);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getFunctionDetails(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_functionId = getString(paramsContainerPtr, "functionId", 0, protocolErrors);

    RefPtr<TypeBuilder::Debugger::FunctionDetails> out_details;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getFunctionDetailsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getFunctionDetails(&error, in_functionId, out_details);
    if (!error.length()) {
        result->setValue("details", out_details);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getGeneratorObjectDetails(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    RefPtr<TypeBuilder::Debugger::GeneratorObjectDetails> out_details;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getGeneratorObjectDetailsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getGeneratorObjectDetails(&error, in_objectId, out_details);
    if (!error.length()) {
        result->setValue("details", out_details);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getCollectionEntries(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CollectionEntry> > out_entries;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getCollectionEntriesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getCollectionEntries(&error, in_objectId, out_entries);
    if (!error.length()) {
        result->setValue("entries", out_entries);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setPauseOnExceptions(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_state = getString(paramsContainerPtr, "state", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setPauseOnExceptionsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setPauseOnExceptions(&error, in_state);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_evaluateOnCallFrame(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool includeCommandLineAPI_valueFound = false;
    bool in_includeCommandLineAPI = getBoolean(paramsContainerPtr, "includeCommandLineAPI", &includeCommandLineAPI_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;
    RefPtr<TypeBuilder::Debugger::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_evaluateOnCallFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->evaluateOnCallFrame(&error, in_callFrameId, in_expression, objectGroup_valueFound ? &in_objectGroup : 0, includeCommandLineAPI_valueFound ? &in_includeCommandLineAPI : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", out_exceptionDetails);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_compileScript(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    String in_sourceURL = getString(paramsContainerPtr, "sourceURL", 0, protocolErrors);
    bool in_persistScript = getBoolean(paramsContainerPtr, "persistScript", 0, protocolErrors);
    bool executionContextId_valueFound = false;
    int in_executionContextId = getInt(paramsContainerPtr, "executionContextId", &executionContextId_valueFound, protocolErrors);

    TypeBuilder::OptOutput<TypeBuilder::Debugger::ScriptId> out_scriptId;
    RefPtr<TypeBuilder::Debugger::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_compileScriptCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->compileScript(&error, in_expression, in_sourceURL, in_persistScript, executionContextId_valueFound ? &in_executionContextId : 0, &out_scriptId, out_exceptionDetails);
    if (!error.length()) {
        if (out_scriptId.isAssigned())
            result->setString("scriptId", out_scriptId.getValue());
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", out_exceptionDetails);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_runScript(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    bool executionContextId_valueFound = false;
    int in_executionContextId = getInt(paramsContainerPtr, "executionContextId", &executionContextId_valueFound, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    RefPtr<TypeBuilder::Debugger::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_runScriptCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->runScript(&error, in_scriptId, executionContextId_valueFound ? &in_executionContextId : 0, objectGroup_valueFound ? &in_objectGroup : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, out_result, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", out_exceptionDetails);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setVariableValue(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_scopeNumber = getInt(paramsContainerPtr, "scopeNumber", 0, protocolErrors);
    String in_variableName = getString(paramsContainerPtr, "variableName", 0, protocolErrors);
    RefPtr<JSONObject> in_newValue = getObject(paramsContainerPtr, "newValue", 0, protocolErrors);
    bool callFrameId_valueFound = false;
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", &callFrameId_valueFound, protocolErrors);
    bool functionObjectId_valueFound = false;
    String in_functionObjectId = getString(paramsContainerPtr, "functionObjectId", &functionObjectId_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setVariableValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setVariableValue(&error, in_scopeNumber, in_variableName, in_newValue, callFrameId_valueFound ? &in_callFrameId : 0, functionObjectId_valueFound ? &in_functionObjectId : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_getStepInPositions(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Location> > out_stepInPositions;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getStepInPositionsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getStepInPositions(&error, in_callFrameId, out_stepInPositions);
    if (!error.length()) {
        if (out_stepInPositions)
            result->setValue("stepInPositions", out_stepInPositions);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getBacktrace(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getBacktraceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getBacktrace(&error, out_callFrames, out_asyncStackTrace);
    if (!error.length()) {
        result->setValue("callFrames", out_callFrames);
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", out_asyncStackTrace);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_skipStackFrames(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool script_valueFound = false;
    String in_script = getString(paramsContainerPtr, "script", &script_valueFound, protocolErrors);
    bool skipContentScripts_valueFound = false;
    bool in_skipContentScripts = getBoolean(paramsContainerPtr, "skipContentScripts", &skipContentScripts_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_skipStackFramesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->skipStackFrames(&error, script_valueFound ? &in_script : 0, skipContentScripts_valueFound ? &in_skipContentScripts : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setAsyncCallStackDepth(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_maxDepth = getInt(paramsContainerPtr, "maxDepth", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setAsyncCallStackDepthCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setAsyncCallStackDepth(&error, in_maxDepth);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_enablePromiseTracker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool captureStacks_valueFound = false;
    bool in_captureStacks = getBoolean(paramsContainerPtr, "captureStacks", &captureStacks_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_enablePromiseTrackerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->enablePromiseTracker(&error, captureStacks_valueFound ? &in_captureStacks : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_disablePromiseTracker(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_disablePromiseTrackerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->disablePromiseTracker(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_getPromiseById(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_promiseId = getInt(paramsContainerPtr, "promiseId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_promise;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getPromiseByIdCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getPromiseById(&error, in_promiseId, objectGroup_valueFound ? &in_objectGroup : 0, out_promise);
    if (!error.length()) {
        result->setValue("promise", out_promise);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_flushAsyncOperationEvents(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_flushAsyncOperationEventsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->flushAsyncOperationEvents(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setAsyncOperationBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_operationId = getInt(paramsContainerPtr, "operationId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setAsyncOperationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setAsyncOperationBreakpoint(&error, in_operationId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_removeAsyncOperationBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_operationId = getInt(paramsContainerPtr, "operationId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_removeAsyncOperationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->removeAsyncOperationBreakpoint(&error, in_operationId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setDOMBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setDOMBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setDOMBreakpoint(&error, in_nodeId, in_type);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeDOMBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeDOMBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeDOMBreakpoint(&error, in_nodeId, in_type);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setEventListenerBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);
    bool targetName_valueFound = false;
    String in_targetName = getString(paramsContainerPtr, "targetName", &targetName_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setEventListenerBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setEventListenerBreakpoint(&error, in_eventName, targetName_valueFound ? &in_targetName : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeEventListenerBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);
    bool targetName_valueFound = false;
    String in_targetName = getString(paramsContainerPtr, "targetName", &targetName_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeEventListenerBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeEventListenerBreakpoint(&error, in_eventName, targetName_valueFound ? &in_targetName : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setInstrumentationBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setInstrumentationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setInstrumentationBreakpoint(&error, in_eventName);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeInstrumentationBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeInstrumentationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeInstrumentationBreakpoint(&error, in_eventName);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setXHRBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setXHRBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setXHRBreakpoint(&error, in_url);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeXHRBreakpoint(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeXHRBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeXHRBreakpoint(&error, in_url);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_getEventListeners(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::DOMDebugger::EventListener> > out_listeners;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_getEventListenersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domDebuggerAgent->getEventListeners(&error, in_objectId, out_listeners);
    if (!error.length()) {
        result->setValue("listeners", out_listeners);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Profiler_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_setSamplingInterval(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_interval = getInt(paramsContainerPtr, "interval", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_setSamplingIntervalCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->setSamplingInterval(&error, in_interval);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_start(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_startCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->start(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_stop(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<TypeBuilder::Profiler::CPUProfile> out_profile;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_stopCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_profilerAgent->stop(&error, out_profile);
    if (!error.length()) {
        result->setValue("profile", out_profile);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::HeapProfiler_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_startTrackingHeapObjects(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool trackAllocations_valueFound = false;
    bool in_trackAllocations = getBoolean(paramsContainerPtr, "trackAllocations", &trackAllocations_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_startTrackingHeapObjectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->startTrackingHeapObjects(&error, trackAllocations_valueFound ? &in_trackAllocations : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_stopTrackingHeapObjects(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool reportProgress_valueFound = false;
    bool in_reportProgress = getBoolean(paramsContainerPtr, "reportProgress", &reportProgress_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_stopTrackingHeapObjectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->stopTrackingHeapObjects(&error, reportProgress_valueFound ? &in_reportProgress : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_takeHeapSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool reportProgress_valueFound = false;
    bool in_reportProgress = getBoolean(paramsContainerPtr, "reportProgress", &reportProgress_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_takeHeapSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->takeHeapSnapshot(&error, reportProgress_valueFound ? &in_reportProgress : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_collectGarbage(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_collectGarbageCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->collectGarbage(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_getObjectByHeapObjectId(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_getObjectByHeapObjectIdCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_heapProfilerAgent->getObjectByHeapObjectId(&error, in_objectId, objectGroup_valueFound ? &in_objectGroup : 0, out_result);
    if (!error.length()) {
        result->setValue("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::HeapProfiler_addInspectedHeapObject(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_heapObjectId = getString(paramsContainerPtr, "heapObjectId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_addInspectedHeapObjectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->addInspectedHeapObject(&error, in_heapObjectId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_getHeapObjectId(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    TypeBuilder::HeapProfiler::HeapSnapshotObjectId out_heapSnapshotObjectId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_getHeapObjectIdCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_heapProfilerAgent->getHeapObjectId(&error, in_objectId, &out_heapSnapshotObjectId);
    if (!error.length()) {
        result->setString("heapSnapshotObjectId", out_heapSnapshotObjectId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Worker_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_sendMessageToWorker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_workerId = getString(paramsContainerPtr, "workerId", 0, protocolErrors);
    String in_message = getString(paramsContainerPtr, "message", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_sendMessageToWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->sendMessageToWorker(&error, in_workerId, in_message);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_connectToWorker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_workerId = getString(paramsContainerPtr, "workerId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_connectToWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->connectToWorker(&error, in_workerId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_disconnectFromWorker(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_workerId = getString(paramsContainerPtr, "workerId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_disconnectFromWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->disconnectFromWorker(&error, in_workerId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_setAutoconnectToWorkers(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_value = getBoolean(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_setAutoconnectToWorkersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->setAutoconnectToWorkers(&error, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Input_dispatchTouchEvent(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_inputAgent)
        protocolErrors->pushString("Input handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);
    RefPtr<JSONArray> in_touchPoints = getArray(paramsContainerPtr, "touchPoints", 0, protocolErrors);
    bool modifiers_valueFound = false;
    int in_modifiers = getInt(paramsContainerPtr, "modifiers", &modifiers_valueFound, protocolErrors);
    bool timestamp_valueFound = false;
    double in_timestamp = getDouble(paramsContainerPtr, "timestamp", &timestamp_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInput_dispatchTouchEventCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inputAgent->dispatchTouchEvent(&error, in_type, in_touchPoints, modifiers_valueFound ? &in_modifiers : 0, timestamp_valueFound ? &in_timestamp : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_compositingReasons(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_layerId = getString(paramsContainerPtr, "layerId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_compositingReasons;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_compositingReasonsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->compositingReasons(&error, in_layerId, out_compositingReasons);
    if (!error.length()) {
        result->setValue("compositingReasons", out_compositingReasons);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_makeSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_layerId = getString(paramsContainerPtr, "layerId", 0, protocolErrors);

    TypeBuilder::LayerTree::SnapshotId out_snapshotId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_makeSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->makeSnapshot(&error, in_layerId, &out_snapshotId);
    if (!error.length()) {
        result->setString("snapshotId", out_snapshotId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_loadSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_tiles = getArray(paramsContainerPtr, "tiles", 0, protocolErrors);

    TypeBuilder::LayerTree::SnapshotId out_snapshotId;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_loadSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->loadSnapshot(&error, in_tiles, &out_snapshotId);
    if (!error.length()) {
        result->setString("snapshotId", out_snapshotId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_releaseSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_releaseSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->releaseSnapshot(&error, in_snapshotId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_profileSnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);
    bool minRepeatCount_valueFound = false;
    int in_minRepeatCount = getInt(paramsContainerPtr, "minRepeatCount", &minRepeatCount_valueFound, protocolErrors);
    bool minDuration_valueFound = false;
    double in_minDuration = getDouble(paramsContainerPtr, "minDuration", &minDuration_valueFound, protocolErrors);
    bool clipRect_valueFound = false;
    RefPtr<JSONObject> in_clipRect = getObject(paramsContainerPtr, "clipRect", &clipRect_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Array<double> > > out_timings;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_profileSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->profileSnapshot(&error, in_snapshotId, minRepeatCount_valueFound ? &in_minRepeatCount : 0, minDuration_valueFound ? &in_minDuration : 0, clipRect_valueFound ? &in_clipRect : 0, out_timings);
    if (!error.length()) {
        result->setValue("timings", out_timings);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_replaySnapshot(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);
    bool fromStep_valueFound = false;
    int in_fromStep = getInt(paramsContainerPtr, "fromStep", &fromStep_valueFound, protocolErrors);
    bool toStep_valueFound = false;
    int in_toStep = getInt(paramsContainerPtr, "toStep", &toStep_valueFound, protocolErrors);
    bool scale_valueFound = false;
    double in_scale = getDouble(paramsContainerPtr, "scale", &scale_valueFound, protocolErrors);

    String out_dataURL;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_replaySnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->replaySnapshot(&error, in_snapshotId, fromStep_valueFound ? &in_fromStep : 0, toStep_valueFound ? &in_toStep : 0, scale_valueFound ? &in_scale : 0, &out_dataURL);
    if (!error.length()) {
        result->setString("dataURL", out_dataURL);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_snapshotCommandLog(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<JSONObject> > out_commandLog;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_snapshotCommandLogCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->snapshotCommandLog(&error, in_snapshotId, out_commandLog);
    if (!error.length()) {
        result->setValue("commandLog", out_commandLog);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DeviceOrientation_setDeviceOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("DeviceOrientation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_alpha = getDouble(paramsContainerPtr, "alpha", 0, protocolErrors);
    double in_beta = getDouble(paramsContainerPtr, "beta", 0, protocolErrors);
    double in_gamma = getDouble(paramsContainerPtr, "gamma", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDeviceOrientation_setDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->setDeviceOrientationOverride(&error, in_alpha, in_beta, in_gamma);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DeviceOrientation_clearDeviceOrientationOverride(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("DeviceOrientation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDeviceOrientation_clearDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->clearDeviceOrientationOverride(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::ScreenOrientation_setScreenOrientationOverride(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_screenOrientationAgent)
        protocolErrors->pushString("ScreenOrientation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_angle = getInt(paramsContainerPtr, "angle", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kScreenOrientation_setScreenOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_screenOrientationAgent->setScreenOrientationOverride(&error, in_angle, in_type);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::ScreenOrientation_clearScreenOrientationOverride(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_screenOrientationAgent)
        protocolErrors->pushString("ScreenOrientation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kScreenOrientation_clearScreenOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_screenOrientationAgent->clearScreenOrientationOverride(&error);

    sendResponse(callId, error);
}

InspectorBackendDispatcher::TracingCommandHandler::StartCallback::StartCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::TracingCommandHandler::StartCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Tracing_start(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_tracingAgent)
        protocolErrors->pushString("Tracing handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool categories_valueFound = false;
    String in_categories = getString(paramsContainerPtr, "categories", &categories_valueFound, protocolErrors);
    bool options_valueFound = false;
    String in_options = getString(paramsContainerPtr, "options", &options_valueFound, protocolErrors);
    bool bufferUsageReportingInterval_valueFound = false;
    double in_bufferUsageReportingInterval = getDouble(paramsContainerPtr, "bufferUsageReportingInterval", &bufferUsageReportingInterval_valueFound, protocolErrors);
    RefPtrWillBeRawPtr<TracingCommandHandler::StartCallback> callback = adoptRefWillBeNoop(new TracingCommandHandler::StartCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTracing_startCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_tracingAgent->start(&error, categories_valueFound ? &in_categories : 0, options_valueFound ? &in_options : 0, bufferUsageReportingInterval_valueFound ? &in_bufferUsageReportingInterval : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::TracingCommandHandler::EndCallback::EndCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::TracingCommandHandler::EndCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Tracing_end(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_tracingAgent)
        protocolErrors->pushString("Tracing handler is not available.");
    RefPtrWillBeRawPtr<TracingCommandHandler::EndCallback> callback = adoptRefWillBeNoop(new TracingCommandHandler::EndCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTracing_endCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_tracingAgent->end(&error, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Animation_enable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Animation_disable(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Animation_getPlaybackRate(int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    double out_playbackRate;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_getPlaybackRateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_animationAgent->getPlaybackRate(&error, &out_playbackRate);
    if (!error.length()) {
        result->setNumber("playbackRate", out_playbackRate);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Animation_setPlaybackRate(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_playbackRate = getDouble(paramsContainerPtr, "playbackRate", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_setPlaybackRateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->setPlaybackRate(&error, in_playbackRate);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Animation_setCurrentTime(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_currentTime = getDouble(paramsContainerPtr, "currentTime", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_setCurrentTimeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->setCurrentTime(&error, in_currentTime);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Animation_setTiming(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_playerId = getString(paramsContainerPtr, "playerId", 0, protocolErrors);
    double in_duration = getDouble(paramsContainerPtr, "duration", 0, protocolErrors);
    double in_delay = getDouble(paramsContainerPtr, "delay", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_setTimingCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->setTiming(&error, in_playerId, in_duration, in_delay);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Accessibility_getAXNode(int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_accessibilityAgent)
        protocolErrors->pushString("Accessibility handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Accessibility::AXNode> out_accessibilityNode;

    if (protocolErrors->length()) {
        reportProtocolError(callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAccessibility_getAXNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_accessibilityAgent->getAXNode(&error, in_nodeId, out_accessibilityNode);
    if (!error.length()) {
        if (out_accessibilityNode)
            result->setValue("accessibilityNode", out_accessibilityNode);
    }
    sendResponse(callId, error, result);
}


PassRefPtrWillBeRawPtr<InspectorBackendDispatcher> InspectorBackendDispatcher::create(InspectorFrontendChannel* inspectorFrontendChannel)
{
    return adoptRefWillBeNoop(new InspectorBackendDispatcherImpl(inspectorFrontendChannel));
}


void InspectorBackendDispatcherImpl::dispatch(const String& message)
{
    RefPtrWillBeRawPtr<InspectorBackendDispatcher> protect(this);
    int callId = 0;
    RefPtr<JSONValue> parsedMessage = parseJSON(message);
    ASSERT(parsedMessage);
    RefPtr<JSONObject> messageObject = parsedMessage->asObject();
    ASSERT(messageObject);

    RefPtr<JSONValue> callIdValue = messageObject->get("id");
    bool success = callIdValue->asNumber(&callId);
    ASSERT_UNUSED(success, success);

    RefPtr<JSONValue> methodValue = messageObject->get("method");
    String method;
    success = methodValue && methodValue->asString(&method);
    ASSERT_UNUSED(success, success);

    HashMap<String, CallHandler>::iterator it = m_dispatchMap.find(method);
    if (it == m_dispatchMap.end()) {
        reportProtocolError(callId, MethodNotFound, "'" + method + "' wasn't found");
        return;
    }

    RefPtr<JSONArray> protocolErrors = JSONArray::create();
    ((*this).*it->value)(callId, messageObject.get(), protocolErrors.get());
}

void InspectorBackendDispatcherImpl::sendResponse(int callId, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData, PassRefPtr<JSONObject> result)
{
    if (invocationError.length()) {
        reportProtocolError(callId, ServerError, invocationError, errorData);
        return;
    }

    RefPtr<JSONObject> responseMessage = JSONObject::create();
    responseMessage->setNumber("id", callId);
    responseMessage->setObject("result", result);
    if (m_inspectorFrontendChannel)
        m_inspectorFrontendChannel->sendProtocolResponse(callId, responseMessage.release());
}

void InspectorBackendDispatcher::reportProtocolError(int callId, CommonErrorCode code, const String& errorMessage) const
{
    reportProtocolError(callId, code, errorMessage, PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::reportProtocolError(int callId, CommonErrorCode code, const String& errorMessage, PassRefPtr<JSONValue> data) const
{
    ASSERT(code >=0);
    ASSERT((unsigned)code < m_commonErrors.size());
    ASSERT(m_commonErrors[code]);
    RefPtr<JSONObject> error = JSONObject::create();
    error->setNumber("code", m_commonErrors[code]);
    error->setString("message", errorMessage);
    ASSERT(error);
    if (data)
        error->setValue("data", data);
    RefPtr<JSONObject> message = JSONObject::create();
    message->setObject("error", error);
    message->setNumber("id", callId);
    if (m_inspectorFrontendChannel)
        m_inspectorFrontendChannel->sendProtocolResponse(callId, message.release());
}

template<typename R, typename V, typename V0>
R InspectorBackendDispatcherImpl::getPropertyValueImpl(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors, V0 initial_value, bool (*as_method)(JSONValue*, V*), const char* type_name)
{
    ASSERT(protocolErrors);

    if (valueFound)
        *valueFound = false;

    V value = initial_value;

    if (!object) {
        if (!valueFound) {
            // Required parameter in missing params container.
            protocolErrors->pushString(String::format("'params' object must contain required parameter '%s' with type '%s'.", name, type_name));
        }
        return value;
    }

    JSONObject::const_iterator end = object->end();
    JSONObject::const_iterator valueIterator = object->find(name);

    if (valueIterator == end) {
        if (!valueFound)
            protocolErrors->pushString(String::format("Parameter '%s' with type '%s' was not found.", name, type_name));
        return value;
    }

    if (!as_method(valueIterator->value.get(), &value))
        protocolErrors->pushString(String::format("Parameter '%s' has wrong type. It must be '%s'.", name, type_name));
    else
        if (valueFound)
            *valueFound = true;
    return value;
}

struct AsMethodBridges {
    static bool asInt(JSONValue* value, int* output) { return value->asNumber(output); }
    static bool asDouble(JSONValue* value, double* output) { return value->asNumber(output); }
    static bool asString(JSONValue* value, String* output) { return value->asString(output); }
    static bool asBoolean(JSONValue* value, bool* output) { return value->asBoolean(output); }
    static bool asObject(JSONValue* value, RefPtr<JSONObject>* output) { return value->asObject(output); }
    static bool asArray(JSONValue* value, RefPtr<JSONArray>* output) { return value->asArray(output); }
};

int InspectorBackendDispatcherImpl::getInt(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<int, int, int>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asInt, "Number");
}

double InspectorBackendDispatcherImpl::getDouble(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<double, double, double>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asDouble, "Number");
}

String InspectorBackendDispatcherImpl::getString(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<String, String, String>(object, name, valueFound, protocolErrors, "", AsMethodBridges::asString, "String");
}

bool InspectorBackendDispatcherImpl::getBoolean(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<bool, bool, bool>(object, name, valueFound, protocolErrors, false, AsMethodBridges::asBoolean, "Boolean");
}

PassRefPtr<JSONObject> InspectorBackendDispatcherImpl::getObject(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<PassRefPtr<JSONObject>, RefPtr<JSONObject>, JSONObject*>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asObject, "Object");
}

PassRefPtr<JSONArray> InspectorBackendDispatcherImpl::getArray(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<PassRefPtr<JSONArray>, RefPtr<JSONArray>, JSONArray*>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asArray, "Array");
}

bool InspectorBackendDispatcher::getCommandName(const String& message, String* result)
{
    RefPtr<JSONValue> value = parseJSON(message);
    if (!value)
        return false;

    RefPtr<JSONObject> object = value->asObject();
    if (!object)
        return false;

    if (!object->getString("method", result))
        return false;

    return true;
}

InspectorBackendDispatcher::CallbackBase::CallbackBase(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int id)
    : m_backendImpl(backendImpl), m_id(id), m_alreadySent(false) {}

InspectorBackendDispatcher::CallbackBase::~CallbackBase() {}

DEFINE_TRACE(InspectorBackendDispatcher::CallbackBase)
{
    visitor->trace(m_backendImpl);
}

void InspectorBackendDispatcher::CallbackBase::sendFailure(const ErrorString& error)
{
    ASSERT(error.length());
    sendIfActive(nullptr, error, PassRefPtr<JSONValue>());
}

bool InspectorBackendDispatcher::CallbackBase::isActive()
{
    return !m_alreadySent && m_backendImpl->isActive();
}

void InspectorBackendDispatcher::CallbackBase::sendIfActive(PassRefPtr<JSONObject> partialMessage, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData)
{
    if (m_alreadySent)
        return;
    m_backendImpl->sendResponse(m_id, invocationError, errorData, partialMessage);
    m_alreadySent = true;
}

} // namespace blink

