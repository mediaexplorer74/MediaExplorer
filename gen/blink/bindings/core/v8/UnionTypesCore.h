// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#ifndef UnionTypeCore_h
#define UnionTypeCore_h

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/V8Binding.h"
#include "core/CoreExport.h"
#include "platform/heap/Handle.h"

namespace blink {

class AudioTrack;
class Blob;
class DOMArrayBuffer;
class DOMArrayBufferView;
class DOMFormData;
class Document;
class EffectModel;
class Element;
class File;
class HTMLElement;
class HTMLOptGroupElement;
class HTMLOptionElement;
class Node;
class NodeList;
class RadioNodeList;
class TextTrack;
class VideoTrack;

class CORE_EXPORT ArrayBufferOrArrayBufferView final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    ArrayBufferOrArrayBufferView();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static ArrayBufferOrArrayBufferView fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static ArrayBufferOrArrayBufferView fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    ArrayBufferOrArrayBufferView(const ArrayBufferOrArrayBufferView&);
    ~ArrayBufferOrArrayBufferView();
    ArrayBufferOrArrayBufferView& operator=(const ArrayBufferOrArrayBufferView&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
    };
    SpecificTypes m_type;

    RefPtr<DOMArrayBuffer> m_arrayBuffer;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8ArrayBufferOrArrayBufferView final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, ArrayBufferOrArrayBufferView&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ArrayBufferOrArrayBufferView& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<ArrayBufferOrArrayBufferView> {
    CORE_EXPORT static ArrayBufferOrArrayBufferView nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    bool isBlob() const { return m_type == SpecificTypeBlob; }
    Blob* getAsBlob() const;
    void setBlob(Blob*);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromBlob(Blob*);

    bool isDocument() const { return m_type == SpecificTypeDocument; }
    PassRefPtrWillBeRawPtr<Document> getAsDocument() const;
    void setDocument(PassRefPtrWillBeRawPtr<Document>);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromDocument(PassRefPtrWillBeRawPtr<Document>);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromString(String);

    bool isFormData() const { return m_type == SpecificTypeFormData; }
    DOMFormData* getAsFormData() const;
    void setFormData(DOMFormData*);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromFormData(DOMFormData*);

    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&);
    ~ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData();
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData& operator=(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
        SpecificTypeBlob,
        SpecificTypeDocument,
        SpecificTypeString,
        SpecificTypeFormData,
    };
    SpecificTypes m_type;

    RefPtr<DOMArrayBuffer> m_arrayBuffer;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;
    Member<Blob> m_blob;
    RefPtrWillBeMember<Document> m_document;
    String m_string;
    Member<DOMFormData> m_formData;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData> {
    CORE_EXPORT static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT ArrayBufferOrArrayBufferViewOrBlobOrString final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    ArrayBufferOrArrayBufferViewOrBlobOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static ArrayBufferOrArrayBufferViewOrBlobOrString fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static ArrayBufferOrArrayBufferViewOrBlobOrString fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    bool isBlob() const { return m_type == SpecificTypeBlob; }
    Blob* getAsBlob() const;
    void setBlob(Blob*);
    static ArrayBufferOrArrayBufferViewOrBlobOrString fromBlob(Blob*);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static ArrayBufferOrArrayBufferViewOrBlobOrString fromString(String);

    ArrayBufferOrArrayBufferViewOrBlobOrString(const ArrayBufferOrArrayBufferViewOrBlobOrString&);
    ~ArrayBufferOrArrayBufferViewOrBlobOrString();
    ArrayBufferOrArrayBufferViewOrBlobOrString& operator=(const ArrayBufferOrArrayBufferViewOrBlobOrString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
        SpecificTypeBlob,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    RefPtr<DOMArrayBuffer> m_arrayBuffer;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;
    Member<Blob> m_blob;
    String m_string;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8ArrayBufferOrArrayBufferViewOrBlobOrString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, ArrayBufferOrArrayBufferViewOrBlobOrString&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ArrayBufferOrArrayBufferViewOrBlobOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<ArrayBufferOrArrayBufferViewOrBlobOrString> {
    CORE_EXPORT static ArrayBufferOrArrayBufferViewOrBlobOrString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT BlobOrStringOrArrayBufferViewOrArrayBuffer final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    BlobOrStringOrArrayBufferViewOrArrayBuffer();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isBlob() const { return m_type == SpecificTypeBlob; }
    Blob* getAsBlob() const;
    void setBlob(Blob*);
    static BlobOrStringOrArrayBufferViewOrArrayBuffer fromBlob(Blob*);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static BlobOrStringOrArrayBufferViewOrArrayBuffer fromString(String);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static BlobOrStringOrArrayBufferViewOrArrayBuffer fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static BlobOrStringOrArrayBufferViewOrArrayBuffer fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    BlobOrStringOrArrayBufferViewOrArrayBuffer(const BlobOrStringOrArrayBufferViewOrArrayBuffer&);
    ~BlobOrStringOrArrayBufferViewOrArrayBuffer();
    BlobOrStringOrArrayBufferViewOrArrayBuffer& operator=(const BlobOrStringOrArrayBufferViewOrArrayBuffer&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeBlob,
        SpecificTypeString,
        SpecificTypeArrayBufferView,
        SpecificTypeArrayBuffer,
    };
    SpecificTypes m_type;

    Member<Blob> m_blob;
    String m_string;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;
    RefPtr<DOMArrayBuffer> m_arrayBuffer;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const BlobOrStringOrArrayBufferViewOrArrayBuffer&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8BlobOrStringOrArrayBufferViewOrArrayBuffer final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, BlobOrStringOrArrayBufferViewOrArrayBuffer&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const BlobOrStringOrArrayBufferViewOrArrayBuffer&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, BlobOrStringOrArrayBufferViewOrArrayBuffer& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<BlobOrStringOrArrayBufferViewOrArrayBuffer> {
    CORE_EXPORT static BlobOrStringOrArrayBufferViewOrArrayBuffer nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrAutoKeyword final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    DoubleOrAutoKeyword();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrAutoKeyword fromDouble(double);

    bool isAutoKeyword() const { return m_type == SpecificTypeAutoKeyword; }
    String getAsAutoKeyword() const;
    void setAutoKeyword(String);
    static DoubleOrAutoKeyword fromAutoKeyword(String);

    DoubleOrAutoKeyword(const DoubleOrAutoKeyword&);
    ~DoubleOrAutoKeyword();
    DoubleOrAutoKeyword& operator=(const DoubleOrAutoKeyword&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeAutoKeyword,
    };
    SpecificTypes m_type;

    double m_double;
    String m_autoKeyword;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrAutoKeyword&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrAutoKeyword final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrAutoKeyword&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrAutoKeyword&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrAutoKeyword& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrAutoKeyword> {
    CORE_EXPORT static DoubleOrAutoKeyword nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrInternalEnum final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    DoubleOrInternalEnum();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrInternalEnum fromDouble(double);

    bool isInternalEnum() const { return m_type == SpecificTypeInternalEnum; }
    String getAsInternalEnum() const;
    void setInternalEnum(String);
    static DoubleOrInternalEnum fromInternalEnum(String);

    DoubleOrInternalEnum(const DoubleOrInternalEnum&);
    ~DoubleOrInternalEnum();
    DoubleOrInternalEnum& operator=(const DoubleOrInternalEnum&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeInternalEnum,
    };
    SpecificTypes m_type;

    double m_double;
    String m_internalEnum;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrInternalEnum&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrInternalEnum final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrInternalEnum&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrInternalEnum&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrInternalEnum& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrInternalEnum> {
    CORE_EXPORT static DoubleOrInternalEnum nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrString final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    DoubleOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrString fromDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static DoubleOrString fromString(String);

    DoubleOrString(const DoubleOrString&);
    ~DoubleOrString();
    DoubleOrString& operator=(const DoubleOrString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    double m_double;
    String m_string;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrString&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrString> {
    CORE_EXPORT static DoubleOrString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrStringOrStringArray final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    DoubleOrStringOrStringArray();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrStringOrStringArray fromDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static DoubleOrStringOrStringArray fromString(String);

    bool isStringArray() const { return m_type == SpecificTypeStringArray; }
    const Vector<String>& getAsStringArray() const;
    void setStringArray(const Vector<String>&);
    static DoubleOrStringOrStringArray fromStringArray(const Vector<String>&);

    DoubleOrStringOrStringArray(const DoubleOrStringOrStringArray&);
    ~DoubleOrStringOrStringArray();
    DoubleOrStringOrStringArray& operator=(const DoubleOrStringOrStringArray&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeString,
        SpecificTypeStringArray,
    };
    SpecificTypes m_type;

    double m_double;
    String m_string;
    Vector<String> m_stringArray;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrStringOrStringArray&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrStringOrStringArray final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrStringOrStringArray&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrStringOrStringArray&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrStringOrStringArray& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrStringOrStringArray> {
    CORE_EXPORT static DoubleOrStringOrStringArray nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrStringOrStringSequence final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    DoubleOrStringOrStringSequence();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrStringOrStringSequence fromDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static DoubleOrStringOrStringSequence fromString(String);

    bool isStringSequence() const { return m_type == SpecificTypeStringSequence; }
    const Vector<String>& getAsStringSequence() const;
    void setStringSequence(const Vector<String>&);
    static DoubleOrStringOrStringSequence fromStringSequence(const Vector<String>&);

    DoubleOrStringOrStringSequence(const DoubleOrStringOrStringSequence&);
    ~DoubleOrStringOrStringSequence();
    DoubleOrStringOrStringSequence& operator=(const DoubleOrStringOrStringSequence&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeString,
        SpecificTypeStringSequence,
    };
    SpecificTypes m_type;

    double m_double;
    String m_string;
    Vector<String> m_stringSequence;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrStringOrStringSequence&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrStringOrStringSequence final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrStringOrStringSequence&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrStringOrStringSequence&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrStringOrStringSequence& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrStringOrStringSequence> {
    CORE_EXPORT static DoubleOrStringOrStringSequence nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT EffectModelOrDictionarySequence final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    EffectModelOrDictionarySequence();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isEffectModel() const { return m_type == SpecificTypeEffectModel; }
    PassRefPtrWillBeRawPtr<EffectModel> getAsEffectModel() const;
    void setEffectModel(PassRefPtrWillBeRawPtr<EffectModel>);
    static EffectModelOrDictionarySequence fromEffectModel(PassRefPtrWillBeRawPtr<EffectModel>);

    bool isDictionarySequence() const { return m_type == SpecificTypeDictionarySequence; }
    const Vector<Dictionary>& getAsDictionarySequence() const;
    void setDictionarySequence(const Vector<Dictionary>&);
    static EffectModelOrDictionarySequence fromDictionarySequence(const Vector<Dictionary>&);

    EffectModelOrDictionarySequence(const EffectModelOrDictionarySequence&);
    ~EffectModelOrDictionarySequence();
    EffectModelOrDictionarySequence& operator=(const EffectModelOrDictionarySequence&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeEffectModel,
        SpecificTypeDictionarySequence,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<EffectModel> m_effectModel;
    Vector<Dictionary> m_dictionarySequence;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const EffectModelOrDictionarySequence&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8EffectModelOrDictionarySequence final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, EffectModelOrDictionarySequence&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const EffectModelOrDictionarySequence&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, EffectModelOrDictionarySequence& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<EffectModelOrDictionarySequence> {
    CORE_EXPORT static EffectModelOrDictionarySequence nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT FileOrUSVString final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    FileOrUSVString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isFile() const { return m_type == SpecificTypeFile; }
    File* getAsFile() const;
    void setFile(File*);
    static FileOrUSVString fromFile(File*);

    bool isUSVString() const { return m_type == SpecificTypeUSVString; }
    String getAsUSVString() const;
    void setUSVString(String);
    static FileOrUSVString fromUSVString(String);

    FileOrUSVString(const FileOrUSVString&);
    ~FileOrUSVString();
    FileOrUSVString& operator=(const FileOrUSVString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeFile,
        SpecificTypeUSVString,
    };
    SpecificTypes m_type;

    Member<File> m_file;
    String m_uSVString;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const FileOrUSVString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8FileOrUSVString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, FileOrUSVString&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const FileOrUSVString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, FileOrUSVString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<FileOrUSVString> {
    CORE_EXPORT static FileOrUSVString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT HTMLElementOrLong final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    HTMLElementOrLong();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isHTMLElement() const { return m_type == SpecificTypeHTMLElement; }
    PassRefPtrWillBeRawPtr<HTMLElement> getAsHTMLElement() const;
    void setHTMLElement(PassRefPtrWillBeRawPtr<HTMLElement>);
    static HTMLElementOrLong fromHTMLElement(PassRefPtrWillBeRawPtr<HTMLElement>);

    bool isLong() const { return m_type == SpecificTypeLong; }
    int getAsLong() const;
    void setLong(int);
    static HTMLElementOrLong fromLong(int);

    HTMLElementOrLong(const HTMLElementOrLong&);
    ~HTMLElementOrLong();
    HTMLElementOrLong& operator=(const HTMLElementOrLong&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeHTMLElement,
        SpecificTypeLong,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<HTMLElement> m_htmlElement;
    int m_long;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLElementOrLong&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8HTMLElementOrLong final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, HTMLElementOrLong&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLElementOrLong&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, HTMLElementOrLong& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<HTMLElementOrLong> {
    CORE_EXPORT static HTMLElementOrLong nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT HTMLOptionElementOrHTMLOptGroupElement final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    HTMLOptionElementOrHTMLOptGroupElement();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isHTMLOptionElement() const { return m_type == SpecificTypeHTMLOptionElement; }
    PassRefPtrWillBeRawPtr<HTMLOptionElement> getAsHTMLOptionElement() const;
    void setHTMLOptionElement(PassRefPtrWillBeRawPtr<HTMLOptionElement>);
    static HTMLOptionElementOrHTMLOptGroupElement fromHTMLOptionElement(PassRefPtrWillBeRawPtr<HTMLOptionElement>);

    bool isHTMLOptGroupElement() const { return m_type == SpecificTypeHTMLOptGroupElement; }
    PassRefPtrWillBeRawPtr<HTMLOptGroupElement> getAsHTMLOptGroupElement() const;
    void setHTMLOptGroupElement(PassRefPtrWillBeRawPtr<HTMLOptGroupElement>);
    static HTMLOptionElementOrHTMLOptGroupElement fromHTMLOptGroupElement(PassRefPtrWillBeRawPtr<HTMLOptGroupElement>);

    HTMLOptionElementOrHTMLOptGroupElement(const HTMLOptionElementOrHTMLOptGroupElement&);
    ~HTMLOptionElementOrHTMLOptGroupElement();
    HTMLOptionElementOrHTMLOptGroupElement& operator=(const HTMLOptionElementOrHTMLOptGroupElement&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeHTMLOptionElement,
        SpecificTypeHTMLOptGroupElement,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<HTMLOptionElement> m_htmlOptionElement;
    RefPtrWillBeMember<HTMLOptGroupElement> m_htmlOptGroupElement;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLOptionElementOrHTMLOptGroupElement&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8HTMLOptionElementOrHTMLOptGroupElement final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, HTMLOptionElementOrHTMLOptGroupElement&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLOptionElementOrHTMLOptGroupElement&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, HTMLOptionElementOrHTMLOptGroupElement& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<HTMLOptionElementOrHTMLOptGroupElement> {
    CORE_EXPORT static HTMLOptionElementOrHTMLOptGroupElement nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT NodeListOrElement final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    NodeListOrElement();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isNodeList() const { return m_type == SpecificTypeNodeList; }
    PassRefPtrWillBeRawPtr<NodeList> getAsNodeList() const;
    void setNodeList(PassRefPtrWillBeRawPtr<NodeList>);
    static NodeListOrElement fromNodeList(PassRefPtrWillBeRawPtr<NodeList>);

    bool isElement() const { return m_type == SpecificTypeElement; }
    PassRefPtrWillBeRawPtr<Element> getAsElement() const;
    void setElement(PassRefPtrWillBeRawPtr<Element>);
    static NodeListOrElement fromElement(PassRefPtrWillBeRawPtr<Element>);

    NodeListOrElement(const NodeListOrElement&);
    ~NodeListOrElement();
    NodeListOrElement& operator=(const NodeListOrElement&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeNodeList,
        SpecificTypeElement,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<NodeList> m_nodeList;
    RefPtrWillBeMember<Element> m_element;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const NodeListOrElement&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8NodeListOrElement final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, NodeListOrElement&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const NodeListOrElement&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, NodeListOrElement& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<NodeListOrElement> {
    CORE_EXPORT static NodeListOrElement nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT NodeOrString final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    NodeOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isNode() const { return m_type == SpecificTypeNode; }
    PassRefPtrWillBeRawPtr<Node> getAsNode() const;
    void setNode(PassRefPtrWillBeRawPtr<Node>);
    static NodeOrString fromNode(PassRefPtrWillBeRawPtr<Node>);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static NodeOrString fromString(String);

    NodeOrString(const NodeOrString&);
    ~NodeOrString();
    NodeOrString& operator=(const NodeOrString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeNode,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<Node> m_node;
    String m_string;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const NodeOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8NodeOrString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, NodeOrString&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const NodeOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, NodeOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<NodeOrString> {
    CORE_EXPORT static NodeOrString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT RadioNodeListOrElement final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    RadioNodeListOrElement();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isRadioNodeList() const { return m_type == SpecificTypeRadioNodeList; }
    PassRefPtrWillBeRawPtr<RadioNodeList> getAsRadioNodeList() const;
    void setRadioNodeList(PassRefPtrWillBeRawPtr<RadioNodeList>);
    static RadioNodeListOrElement fromRadioNodeList(PassRefPtrWillBeRawPtr<RadioNodeList>);

    bool isElement() const { return m_type == SpecificTypeElement; }
    PassRefPtrWillBeRawPtr<Element> getAsElement() const;
    void setElement(PassRefPtrWillBeRawPtr<Element>);
    static RadioNodeListOrElement fromElement(PassRefPtrWillBeRawPtr<Element>);

    RadioNodeListOrElement(const RadioNodeListOrElement&);
    ~RadioNodeListOrElement();
    RadioNodeListOrElement& operator=(const RadioNodeListOrElement&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeRadioNodeList,
        SpecificTypeElement,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<RadioNodeList> m_radioNodeList;
    RefPtrWillBeMember<Element> m_element;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const RadioNodeListOrElement&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8RadioNodeListOrElement final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, RadioNodeListOrElement&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const RadioNodeListOrElement&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, RadioNodeListOrElement& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<RadioNodeListOrElement> {
    CORE_EXPORT static RadioNodeListOrElement nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT StringOrArrayBuffer final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    StringOrArrayBuffer();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrArrayBuffer fromString(String);

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static StringOrArrayBuffer fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    StringOrArrayBuffer(const StringOrArrayBuffer&);
    ~StringOrArrayBuffer();
    StringOrArrayBuffer& operator=(const StringOrArrayBuffer&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeArrayBuffer,
    };
    SpecificTypes m_type;

    String m_string;
    RefPtr<DOMArrayBuffer> m_arrayBuffer;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrArrayBuffer&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrArrayBuffer final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrArrayBuffer&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrArrayBuffer&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrArrayBuffer& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrArrayBuffer> {
    CORE_EXPORT static StringOrArrayBuffer nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT StringOrArrayBufferOrArrayBufferView final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    StringOrArrayBufferOrArrayBufferView();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrArrayBufferOrArrayBufferView fromString(String);

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static StringOrArrayBufferOrArrayBufferView fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static StringOrArrayBufferOrArrayBufferView fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    StringOrArrayBufferOrArrayBufferView(const StringOrArrayBufferOrArrayBufferView&);
    ~StringOrArrayBufferOrArrayBufferView();
    StringOrArrayBufferOrArrayBufferView& operator=(const StringOrArrayBufferOrArrayBufferView&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
    };
    SpecificTypes m_type;

    String m_string;
    RefPtr<DOMArrayBuffer> m_arrayBuffer;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrArrayBufferOrArrayBufferView final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrArrayBufferOrArrayBufferView&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrArrayBufferOrArrayBufferView& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrArrayBufferOrArrayBufferView> {
    CORE_EXPORT static StringOrArrayBufferOrArrayBufferView nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT StringOrFloat final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    StringOrFloat();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrFloat fromString(String);

    bool isFloat() const { return m_type == SpecificTypeFloat; }
    float getAsFloat() const;
    void setFloat(float);
    static StringOrFloat fromFloat(float);

    StringOrFloat(const StringOrFloat&);
    ~StringOrFloat();
    StringOrFloat& operator=(const StringOrFloat&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeFloat,
    };
    SpecificTypes m_type;

    String m_string;
    float m_float;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrFloat&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrFloat final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrFloat&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrFloat&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrFloat& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrFloat> {
    CORE_EXPORT static StringOrFloat nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT UnrestrictedDoubleOrString final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    UnrestrictedDoubleOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isUnrestrictedDouble() const { return m_type == SpecificTypeUnrestrictedDouble; }
    double getAsUnrestrictedDouble() const;
    void setUnrestrictedDouble(double);
    static UnrestrictedDoubleOrString fromUnrestrictedDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static UnrestrictedDoubleOrString fromString(String);

    UnrestrictedDoubleOrString(const UnrestrictedDoubleOrString&);
    ~UnrestrictedDoubleOrString();
    UnrestrictedDoubleOrString& operator=(const UnrestrictedDoubleOrString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeUnrestrictedDouble,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    double m_unrestrictedDouble;
    String m_string;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const UnrestrictedDoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8UnrestrictedDoubleOrString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, UnrestrictedDoubleOrString&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const UnrestrictedDoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, UnrestrictedDoubleOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<UnrestrictedDoubleOrString> {
    CORE_EXPORT static UnrestrictedDoubleOrString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT VideoTrackOrAudioTrackOrTextTrack final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    VideoTrackOrAudioTrackOrTextTrack();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isVideoTrack() const { return m_type == SpecificTypeVideoTrack; }
    PassRefPtrWillBeRawPtr<VideoTrack> getAsVideoTrack() const;
    void setVideoTrack(PassRefPtrWillBeRawPtr<VideoTrack>);
    static VideoTrackOrAudioTrackOrTextTrack fromVideoTrack(PassRefPtrWillBeRawPtr<VideoTrack>);

    bool isAudioTrack() const { return m_type == SpecificTypeAudioTrack; }
    PassRefPtrWillBeRawPtr<AudioTrack> getAsAudioTrack() const;
    void setAudioTrack(PassRefPtrWillBeRawPtr<AudioTrack>);
    static VideoTrackOrAudioTrackOrTextTrack fromAudioTrack(PassRefPtrWillBeRawPtr<AudioTrack>);

    bool isTextTrack() const { return m_type == SpecificTypeTextTrack; }
    PassRefPtrWillBeRawPtr<TextTrack> getAsTextTrack() const;
    void setTextTrack(PassRefPtrWillBeRawPtr<TextTrack>);
    static VideoTrackOrAudioTrackOrTextTrack fromTextTrack(PassRefPtrWillBeRawPtr<TextTrack>);

    VideoTrackOrAudioTrackOrTextTrack(const VideoTrackOrAudioTrackOrTextTrack&);
    ~VideoTrackOrAudioTrackOrTextTrack();
    VideoTrackOrAudioTrackOrTextTrack& operator=(const VideoTrackOrAudioTrackOrTextTrack&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeVideoTrack,
        SpecificTypeAudioTrack,
        SpecificTypeTextTrack,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<VideoTrack> m_videoTrack;
    RefPtrWillBeMember<AudioTrack> m_audioTrack;
    RefPtrWillBeMember<TextTrack> m_textTrack;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const VideoTrackOrAudioTrackOrTextTrack&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8VideoTrackOrAudioTrackOrTextTrack final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, VideoTrackOrAudioTrackOrTextTrack&, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const VideoTrackOrAudioTrackOrTextTrack&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, VideoTrackOrAudioTrackOrTextTrack& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<VideoTrackOrAudioTrackOrTextTrack> {
    CORE_EXPORT static VideoTrackOrAudioTrackOrTextTrack nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class V8ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormDataOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8DoubleOrStringOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrString& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8DoubleOrString::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8DoubleOrStringOrStringArrayOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrStringOrStringArray& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8DoubleOrStringOrStringArray::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8DoubleOrStringOrStringSequenceOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrStringOrStringSequence& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8DoubleOrStringOrStringSequence::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8EffectModelOrDictionarySequenceOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, EffectModelOrDictionarySequence& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8EffectModelOrDictionarySequence::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8HTMLElementOrLongOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, HTMLElementOrLong& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8HTMLElementOrLong::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8NodeListOrElementOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, NodeListOrElement& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8NodeListOrElement::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8RadioNodeListOrElementOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, RadioNodeListOrElement& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8RadioNodeListOrElement::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8StringOrArrayBufferOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, StringOrArrayBuffer& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8StringOrArrayBuffer::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

class V8VideoTrackOrAudioTrackOrTextTrackOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, VideoTrackOrAudioTrackOrTextTrack& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8VideoTrackOrAudioTrackOrTextTrack::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

} // namespace blink

// We need to set canInitializeWithMemset=true because HeapVector supports
// items that can initialize with memset or have a vtable. It is safe to
// set canInitializeWithMemset=true for a union type object in practice.
// See https://codereview.chromium.org/1118993002/#msg5 for more details.
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::ArrayBufferOrArrayBufferView);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::ArrayBufferOrArrayBufferViewOrBlobOrString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::BlobOrStringOrArrayBufferViewOrArrayBuffer);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrAutoKeyword);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrInternalEnum);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrStringOrStringArray);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrStringOrStringSequence);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::EffectModelOrDictionarySequence);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::FileOrUSVString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::HTMLElementOrLong);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::HTMLOptionElementOrHTMLOptGroupElement);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::NodeListOrElement);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::NodeOrString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::RadioNodeListOrElement);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::StringOrArrayBuffer);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::StringOrArrayBufferOrArrayBufferView);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::StringOrFloat);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::UnrestrictedDoubleOrString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::VideoTrackOrAudioTrackOrTextTrack);

#endif // UnionTypeCore_h
