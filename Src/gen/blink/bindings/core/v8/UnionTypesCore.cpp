// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "bindings/core/v8/UnionTypesCore.h"

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/UnionTypesCore.h"
#include "bindings/core/v8/V8ArrayBuffer.h"
#include "bindings/core/v8/V8ArrayBufferView.h"
#include "bindings/core/v8/V8AudioTrack.h"
#include "bindings/core/v8/V8Blob.h"
#include "bindings/core/v8/V8Document.h"
#include "bindings/core/v8/V8EffectModel.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8File.h"
#include "bindings/core/v8/V8FormData.h"
#include "bindings/core/v8/V8HTMLElement.h"
#include "bindings/core/v8/V8HTMLOptGroupElement.h"
#include "bindings/core/v8/V8HTMLOptionElement.h"
#include "bindings/core/v8/V8Node.h"
#include "bindings/core/v8/V8NodeList.h"
#include "bindings/core/v8/V8RadioNodeList.h"
#include "bindings/core/v8/V8TextTrack.h"
#include "bindings/core/v8/V8VideoTrack.h"
#include "core/animation/DocumentAnimation.h"
#include "core/animation/ElementAnimation.h"
#include "core/css/DocumentFontFaceSet.h"
#include "core/dom/ChildNode.h"
#include "core/dom/DocumentFullscreen.h"
#include "core/dom/ElementFullscreen.h"
#include "core/dom/NameNodeList.h"
#include "core/dom/NodeList.h"
#include "core/dom/NonDocumentTypeChildNode.h"
#include "core/dom/NonElementParentNode.h"
#include "core/dom/ParentNode.h"
#include "core/dom/StaticNodeList.h"
#include "core/html/LabelsNodeList.h"
#include "core/svg/SVGDocumentExtensions.h"
#include "core/xml/DocumentXPathEvaluator.h"

namespace blink {

ArrayBufferOrArrayBufferView::ArrayBufferOrArrayBufferView()
    : m_type(SpecificTypeNone)
{
}

PassRefPtr<DOMArrayBuffer> ArrayBufferOrArrayBufferView::getAsArrayBuffer() const
{
    ASSERT(isArrayBuffer());
    return m_arrayBuffer;
}

void ArrayBufferOrArrayBufferView::setArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ASSERT(isNull());
    m_arrayBuffer = value;
    m_type = SpecificTypeArrayBuffer;
}

ArrayBufferOrArrayBufferView ArrayBufferOrArrayBufferView::fromArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ArrayBufferOrArrayBufferView container;
    container.setArrayBuffer(value);
    return container;
}

PassRefPtr<DOMArrayBufferView> ArrayBufferOrArrayBufferView::getAsArrayBufferView() const
{
    ASSERT(isArrayBufferView());
    return m_arrayBufferView;
}

void ArrayBufferOrArrayBufferView::setArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    ASSERT(isNull());
    m_arrayBufferView = value;
    m_type = SpecificTypeArrayBufferView;
}

ArrayBufferOrArrayBufferView ArrayBufferOrArrayBufferView::fromArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    ArrayBufferOrArrayBufferView container;
    container.setArrayBufferView(value);
    return container;
}

ArrayBufferOrArrayBufferView::ArrayBufferOrArrayBufferView(const ArrayBufferOrArrayBufferView&) = default;
ArrayBufferOrArrayBufferView::~ArrayBufferOrArrayBufferView() = default;
ArrayBufferOrArrayBufferView& ArrayBufferOrArrayBufferView::operator=(const ArrayBufferOrArrayBufferView&) = default;

DEFINE_TRACE(ArrayBufferOrArrayBufferView)
{
}

void V8ArrayBufferOrArrayBufferView::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, ArrayBufferOrArrayBufferView& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8ArrayBuffer::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBuffer> cppValue = V8ArrayBuffer::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBuffer(cppValue);
        return;
    }

    if (V8ArrayBufferView::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBufferView> cppValue = V8ArrayBufferView::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBufferView(cppValue);
        return;
    }

    exceptionState.throwTypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
}

v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferView& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case ArrayBufferOrArrayBufferView::SpecificTypeNone:
        return v8::Null(isolate);
    case ArrayBufferOrArrayBufferView::SpecificTypeArrayBuffer:
        return toV8(impl.getAsArrayBuffer(), creationContext, isolate);
    case ArrayBufferOrArrayBufferView::SpecificTypeArrayBufferView:
        return toV8(impl.getAsArrayBufferView(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

ArrayBufferOrArrayBufferView NativeValueTraits<ArrayBufferOrArrayBufferView>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    ArrayBufferOrArrayBufferView impl;
    V8ArrayBufferOrArrayBufferView::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData()
    : m_type(SpecificTypeNone)
{
}

PassRefPtr<DOMArrayBuffer> ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::getAsArrayBuffer() const
{
    ASSERT(isArrayBuffer());
    return m_arrayBuffer;
}

void ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::setArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ASSERT(isNull());
    m_arrayBuffer = value;
    m_type = SpecificTypeArrayBuffer;
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::fromArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData container;
    container.setArrayBuffer(value);
    return container;
}

PassRefPtr<DOMArrayBufferView> ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::getAsArrayBufferView() const
{
    ASSERT(isArrayBufferView());
    return m_arrayBufferView;
}

void ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::setArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    ASSERT(isNull());
    m_arrayBufferView = value;
    m_type = SpecificTypeArrayBufferView;
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::fromArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData container;
    container.setArrayBufferView(value);
    return container;
}

Blob* ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::getAsBlob() const
{
    ASSERT(isBlob());
    return m_blob;
}

void ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::setBlob(Blob* value)
{
    ASSERT(isNull());
    m_blob = value;
    m_type = SpecificTypeBlob;
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::fromBlob(Blob* value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData container;
    container.setBlob(value);
    return container;
}

PassRefPtrWillBeRawPtr<Document> ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::getAsDocument() const
{
    ASSERT(isDocument());
    return m_document;
}

void ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::setDocument(PassRefPtrWillBeRawPtr<Document> value)
{
    ASSERT(isNull());
    m_document = value;
    m_type = SpecificTypeDocument;
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::fromDocument(PassRefPtrWillBeRawPtr<Document> value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData container;
    container.setDocument(value);
    return container;
}

String ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::fromString(String value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData container;
    container.setString(value);
    return container;
}

DOMFormData* ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::getAsFormData() const
{
    ASSERT(isFormData());
    return m_formData;
}

void ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::setFormData(DOMFormData* value)
{
    ASSERT(isNull());
    m_formData = value;
    m_type = SpecificTypeFormData;
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::fromFormData(DOMFormData* value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData container;
    container.setFormData(value);
    return container;
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&) = default;
ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::~ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData() = default;
ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData& ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::operator=(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&) = default;

DEFINE_TRACE(ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData)
{
    visitor->trace(m_blob);
    visitor->trace(m_document);
    visitor->trace(m_formData);
}

void V8ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8Blob::hasInstance(v8Value, isolate)) {
        RawPtr<Blob> cppValue = V8Blob::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setBlob(cppValue);
        return;
    }

    if (V8Document::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<Document> cppValue = V8Document::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setDocument(cppValue);
        return;
    }

    if (V8FormData::hasInstance(v8Value, isolate)) {
        RawPtr<DOMFormData> cppValue = V8FormData::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setFormData(cppValue);
        return;
    }

    if (V8ArrayBuffer::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBuffer> cppValue = V8ArrayBuffer::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBuffer(cppValue);
        return;
    }

    if (V8ArrayBufferView::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBufferView> cppValue = V8ArrayBufferView::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBufferView(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::SpecificTypeNone:
        return v8::Null(isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::SpecificTypeArrayBuffer:
        return toV8(impl.getAsArrayBuffer(), creationContext, isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::SpecificTypeArrayBufferView:
        return toV8(impl.getAsArrayBufferView(), creationContext, isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::SpecificTypeBlob:
        return toV8(impl.getAsBlob(), creationContext, isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::SpecificTypeDocument:
        return toV8(impl.getAsDocument(), creationContext, isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    case ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::SpecificTypeFormData:
        return toV8(impl.getAsFormData(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData NativeValueTraits<ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData impl;
    V8ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

ArrayBufferOrArrayBufferViewOrBlobOrString::ArrayBufferOrArrayBufferViewOrBlobOrString()
    : m_type(SpecificTypeNone)
{
}

PassRefPtr<DOMArrayBuffer> ArrayBufferOrArrayBufferViewOrBlobOrString::getAsArrayBuffer() const
{
    ASSERT(isArrayBuffer());
    return m_arrayBuffer;
}

void ArrayBufferOrArrayBufferViewOrBlobOrString::setArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ASSERT(isNull());
    m_arrayBuffer = value;
    m_type = SpecificTypeArrayBuffer;
}

ArrayBufferOrArrayBufferViewOrBlobOrString ArrayBufferOrArrayBufferViewOrBlobOrString::fromArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrString container;
    container.setArrayBuffer(value);
    return container;
}

PassRefPtr<DOMArrayBufferView> ArrayBufferOrArrayBufferViewOrBlobOrString::getAsArrayBufferView() const
{
    ASSERT(isArrayBufferView());
    return m_arrayBufferView;
}

void ArrayBufferOrArrayBufferViewOrBlobOrString::setArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    ASSERT(isNull());
    m_arrayBufferView = value;
    m_type = SpecificTypeArrayBufferView;
}

ArrayBufferOrArrayBufferViewOrBlobOrString ArrayBufferOrArrayBufferViewOrBlobOrString::fromArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrString container;
    container.setArrayBufferView(value);
    return container;
}

Blob* ArrayBufferOrArrayBufferViewOrBlobOrString::getAsBlob() const
{
    ASSERT(isBlob());
    return m_blob;
}

void ArrayBufferOrArrayBufferViewOrBlobOrString::setBlob(Blob* value)
{
    ASSERT(isNull());
    m_blob = value;
    m_type = SpecificTypeBlob;
}

ArrayBufferOrArrayBufferViewOrBlobOrString ArrayBufferOrArrayBufferViewOrBlobOrString::fromBlob(Blob* value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrString container;
    container.setBlob(value);
    return container;
}

String ArrayBufferOrArrayBufferViewOrBlobOrString::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void ArrayBufferOrArrayBufferViewOrBlobOrString::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

ArrayBufferOrArrayBufferViewOrBlobOrString ArrayBufferOrArrayBufferViewOrBlobOrString::fromString(String value)
{
    ArrayBufferOrArrayBufferViewOrBlobOrString container;
    container.setString(value);
    return container;
}

ArrayBufferOrArrayBufferViewOrBlobOrString::ArrayBufferOrArrayBufferViewOrBlobOrString(const ArrayBufferOrArrayBufferViewOrBlobOrString&) = default;
ArrayBufferOrArrayBufferViewOrBlobOrString::~ArrayBufferOrArrayBufferViewOrBlobOrString() = default;
ArrayBufferOrArrayBufferViewOrBlobOrString& ArrayBufferOrArrayBufferViewOrBlobOrString::operator=(const ArrayBufferOrArrayBufferViewOrBlobOrString&) = default;

DEFINE_TRACE(ArrayBufferOrArrayBufferViewOrBlobOrString)
{
    visitor->trace(m_blob);
}

void V8ArrayBufferOrArrayBufferViewOrBlobOrString::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, ArrayBufferOrArrayBufferViewOrBlobOrString& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8Blob::hasInstance(v8Value, isolate)) {
        RawPtr<Blob> cppValue = V8Blob::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setBlob(cppValue);
        return;
    }

    if (V8ArrayBuffer::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBuffer> cppValue = V8ArrayBuffer::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBuffer(cppValue);
        return;
    }

    if (V8ArrayBufferView::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBufferView> cppValue = V8ArrayBufferView::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBufferView(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrString& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case ArrayBufferOrArrayBufferViewOrBlobOrString::SpecificTypeNone:
        return v8::Null(isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrString::SpecificTypeArrayBuffer:
        return toV8(impl.getAsArrayBuffer(), creationContext, isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrString::SpecificTypeArrayBufferView:
        return toV8(impl.getAsArrayBufferView(), creationContext, isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrString::SpecificTypeBlob:
        return toV8(impl.getAsBlob(), creationContext, isolate);
    case ArrayBufferOrArrayBufferViewOrBlobOrString::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

ArrayBufferOrArrayBufferViewOrBlobOrString NativeValueTraits<ArrayBufferOrArrayBufferViewOrBlobOrString>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    ArrayBufferOrArrayBufferViewOrBlobOrString impl;
    V8ArrayBufferOrArrayBufferViewOrBlobOrString::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

BlobOrStringOrArrayBufferViewOrArrayBuffer::BlobOrStringOrArrayBufferViewOrArrayBuffer()
    : m_type(SpecificTypeNone)
{
}

Blob* BlobOrStringOrArrayBufferViewOrArrayBuffer::getAsBlob() const
{
    ASSERT(isBlob());
    return m_blob;
}

void BlobOrStringOrArrayBufferViewOrArrayBuffer::setBlob(Blob* value)
{
    ASSERT(isNull());
    m_blob = value;
    m_type = SpecificTypeBlob;
}

BlobOrStringOrArrayBufferViewOrArrayBuffer BlobOrStringOrArrayBufferViewOrArrayBuffer::fromBlob(Blob* value)
{
    BlobOrStringOrArrayBufferViewOrArrayBuffer container;
    container.setBlob(value);
    return container;
}

String BlobOrStringOrArrayBufferViewOrArrayBuffer::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void BlobOrStringOrArrayBufferViewOrArrayBuffer::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

BlobOrStringOrArrayBufferViewOrArrayBuffer BlobOrStringOrArrayBufferViewOrArrayBuffer::fromString(String value)
{
    BlobOrStringOrArrayBufferViewOrArrayBuffer container;
    container.setString(value);
    return container;
}

PassRefPtr<DOMArrayBufferView> BlobOrStringOrArrayBufferViewOrArrayBuffer::getAsArrayBufferView() const
{
    ASSERT(isArrayBufferView());
    return m_arrayBufferView;
}

void BlobOrStringOrArrayBufferViewOrArrayBuffer::setArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    ASSERT(isNull());
    m_arrayBufferView = value;
    m_type = SpecificTypeArrayBufferView;
}

BlobOrStringOrArrayBufferViewOrArrayBuffer BlobOrStringOrArrayBufferViewOrArrayBuffer::fromArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    BlobOrStringOrArrayBufferViewOrArrayBuffer container;
    container.setArrayBufferView(value);
    return container;
}

PassRefPtr<DOMArrayBuffer> BlobOrStringOrArrayBufferViewOrArrayBuffer::getAsArrayBuffer() const
{
    ASSERT(isArrayBuffer());
    return m_arrayBuffer;
}

void BlobOrStringOrArrayBufferViewOrArrayBuffer::setArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ASSERT(isNull());
    m_arrayBuffer = value;
    m_type = SpecificTypeArrayBuffer;
}

BlobOrStringOrArrayBufferViewOrArrayBuffer BlobOrStringOrArrayBufferViewOrArrayBuffer::fromArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    BlobOrStringOrArrayBufferViewOrArrayBuffer container;
    container.setArrayBuffer(value);
    return container;
}

BlobOrStringOrArrayBufferViewOrArrayBuffer::BlobOrStringOrArrayBufferViewOrArrayBuffer(const BlobOrStringOrArrayBufferViewOrArrayBuffer&) = default;
BlobOrStringOrArrayBufferViewOrArrayBuffer::~BlobOrStringOrArrayBufferViewOrArrayBuffer() = default;
BlobOrStringOrArrayBufferViewOrArrayBuffer& BlobOrStringOrArrayBufferViewOrArrayBuffer::operator=(const BlobOrStringOrArrayBufferViewOrArrayBuffer&) = default;

DEFINE_TRACE(BlobOrStringOrArrayBufferViewOrArrayBuffer)
{
    visitor->trace(m_blob);
}

void V8BlobOrStringOrArrayBufferViewOrArrayBuffer::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, BlobOrStringOrArrayBufferViewOrArrayBuffer& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8Blob::hasInstance(v8Value, isolate)) {
        RawPtr<Blob> cppValue = V8Blob::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setBlob(cppValue);
        return;
    }

    if (V8ArrayBuffer::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBuffer> cppValue = V8ArrayBuffer::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBuffer(cppValue);
        return;
    }

    if (V8ArrayBufferView::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBufferView> cppValue = V8ArrayBufferView::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBufferView(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const BlobOrStringOrArrayBufferViewOrArrayBuffer& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case BlobOrStringOrArrayBufferViewOrArrayBuffer::SpecificTypeNone:
        return v8::Null(isolate);
    case BlobOrStringOrArrayBufferViewOrArrayBuffer::SpecificTypeBlob:
        return toV8(impl.getAsBlob(), creationContext, isolate);
    case BlobOrStringOrArrayBufferViewOrArrayBuffer::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    case BlobOrStringOrArrayBufferViewOrArrayBuffer::SpecificTypeArrayBufferView:
        return toV8(impl.getAsArrayBufferView(), creationContext, isolate);
    case BlobOrStringOrArrayBufferViewOrArrayBuffer::SpecificTypeArrayBuffer:
        return toV8(impl.getAsArrayBuffer(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

BlobOrStringOrArrayBufferViewOrArrayBuffer NativeValueTraits<BlobOrStringOrArrayBufferViewOrArrayBuffer>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    BlobOrStringOrArrayBufferViewOrArrayBuffer impl;
    V8BlobOrStringOrArrayBufferViewOrArrayBuffer::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

DoubleOrAutoKeyword::DoubleOrAutoKeyword()
    : m_type(SpecificTypeNone)
{
}

double DoubleOrAutoKeyword::getAsDouble() const
{
    ASSERT(isDouble());
    return m_double;
}

void DoubleOrAutoKeyword::setDouble(double value)
{
    ASSERT(isNull());
    m_double = value;
    m_type = SpecificTypeDouble;
}

DoubleOrAutoKeyword DoubleOrAutoKeyword::fromDouble(double value)
{
    DoubleOrAutoKeyword container;
    container.setDouble(value);
    return container;
}

String DoubleOrAutoKeyword::getAsAutoKeyword() const
{
    ASSERT(isAutoKeyword());
    return m_autoKeyword;
}

void DoubleOrAutoKeyword::setAutoKeyword(String value)
{
    ASSERT(isNull());
    NonThrowableExceptionState exceptionState;
    static const char* validValues[] = {
        "auto",
    };
    if (!isValidEnum(value, validValues, WTF_ARRAY_LENGTH(validValues), "AutoKeyword", exceptionState)) {
        ASSERT_NOT_REACHED();
        return;
    }
    m_autoKeyword = value;
    m_type = SpecificTypeAutoKeyword;
}

DoubleOrAutoKeyword DoubleOrAutoKeyword::fromAutoKeyword(String value)
{
    DoubleOrAutoKeyword container;
    container.setAutoKeyword(value);
    return container;
}

DoubleOrAutoKeyword::DoubleOrAutoKeyword(const DoubleOrAutoKeyword&) = default;
DoubleOrAutoKeyword::~DoubleOrAutoKeyword() = default;
DoubleOrAutoKeyword& DoubleOrAutoKeyword::operator=(const DoubleOrAutoKeyword&) = default;

DEFINE_TRACE(DoubleOrAutoKeyword)
{
}

void V8DoubleOrAutoKeyword::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrAutoKeyword& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (v8Value->IsNumber()) {
        double cppValue = toRestrictedDouble(isolate, v8Value, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setDouble(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        static const char* validValues[] = {
            "auto",
        };
        if (!isValidEnum(cppValue, validValues, WTF_ARRAY_LENGTH(validValues), "AutoKeyword", exceptionState))
            return;
        impl.setAutoKeyword(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const DoubleOrAutoKeyword& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case DoubleOrAutoKeyword::SpecificTypeNone:
        return v8::Null(isolate);
    case DoubleOrAutoKeyword::SpecificTypeDouble:
        return v8::Number::New(isolate, impl.getAsDouble());
    case DoubleOrAutoKeyword::SpecificTypeAutoKeyword:
        return v8String(isolate, impl.getAsAutoKeyword());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

DoubleOrAutoKeyword NativeValueTraits<DoubleOrAutoKeyword>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    DoubleOrAutoKeyword impl;
    V8DoubleOrAutoKeyword::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

DoubleOrInternalEnum::DoubleOrInternalEnum()
    : m_type(SpecificTypeNone)
{
}

double DoubleOrInternalEnum::getAsDouble() const
{
    ASSERT(isDouble());
    return m_double;
}

void DoubleOrInternalEnum::setDouble(double value)
{
    ASSERT(isNull());
    m_double = value;
    m_type = SpecificTypeDouble;
}

DoubleOrInternalEnum DoubleOrInternalEnum::fromDouble(double value)
{
    DoubleOrInternalEnum container;
    container.setDouble(value);
    return container;
}

String DoubleOrInternalEnum::getAsInternalEnum() const
{
    ASSERT(isInternalEnum());
    return m_internalEnum;
}

void DoubleOrInternalEnum::setInternalEnum(String value)
{
    ASSERT(isNull());
    NonThrowableExceptionState exceptionState;
    static const char* validValues[] = {
        "foo",
        "bar",
        "baz",
    };
    if (!isValidEnum(value, validValues, WTF_ARRAY_LENGTH(validValues), "InternalEnum", exceptionState)) {
        ASSERT_NOT_REACHED();
        return;
    }
    m_internalEnum = value;
    m_type = SpecificTypeInternalEnum;
}

DoubleOrInternalEnum DoubleOrInternalEnum::fromInternalEnum(String value)
{
    DoubleOrInternalEnum container;
    container.setInternalEnum(value);
    return container;
}

DoubleOrInternalEnum::DoubleOrInternalEnum(const DoubleOrInternalEnum&) = default;
DoubleOrInternalEnum::~DoubleOrInternalEnum() = default;
DoubleOrInternalEnum& DoubleOrInternalEnum::operator=(const DoubleOrInternalEnum&) = default;

DEFINE_TRACE(DoubleOrInternalEnum)
{
}

void V8DoubleOrInternalEnum::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrInternalEnum& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (v8Value->IsNumber()) {
        double cppValue = toRestrictedDouble(isolate, v8Value, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setDouble(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        static const char* validValues[] = {
            "foo",
            "bar",
            "baz",
        };
        if (!isValidEnum(cppValue, validValues, WTF_ARRAY_LENGTH(validValues), "InternalEnum", exceptionState))
            return;
        impl.setInternalEnum(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const DoubleOrInternalEnum& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case DoubleOrInternalEnum::SpecificTypeNone:
        return v8::Null(isolate);
    case DoubleOrInternalEnum::SpecificTypeDouble:
        return v8::Number::New(isolate, impl.getAsDouble());
    case DoubleOrInternalEnum::SpecificTypeInternalEnum:
        return v8String(isolate, impl.getAsInternalEnum());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

DoubleOrInternalEnum NativeValueTraits<DoubleOrInternalEnum>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    DoubleOrInternalEnum impl;
    V8DoubleOrInternalEnum::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

DoubleOrString::DoubleOrString()
    : m_type(SpecificTypeNone)
{
}

double DoubleOrString::getAsDouble() const
{
    ASSERT(isDouble());
    return m_double;
}

void DoubleOrString::setDouble(double value)
{
    ASSERT(isNull());
    m_double = value;
    m_type = SpecificTypeDouble;
}

DoubleOrString DoubleOrString::fromDouble(double value)
{
    DoubleOrString container;
    container.setDouble(value);
    return container;
}

String DoubleOrString::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void DoubleOrString::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

DoubleOrString DoubleOrString::fromString(String value)
{
    DoubleOrString container;
    container.setString(value);
    return container;
}

DoubleOrString::DoubleOrString(const DoubleOrString&) = default;
DoubleOrString::~DoubleOrString() = default;
DoubleOrString& DoubleOrString::operator=(const DoubleOrString&) = default;

DEFINE_TRACE(DoubleOrString)
{
}

void V8DoubleOrString::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrString& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (v8Value->IsNumber()) {
        double cppValue = toRestrictedDouble(isolate, v8Value, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setDouble(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const DoubleOrString& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case DoubleOrString::SpecificTypeNone:
        return v8::Null(isolate);
    case DoubleOrString::SpecificTypeDouble:
        return v8::Number::New(isolate, impl.getAsDouble());
    case DoubleOrString::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

DoubleOrString NativeValueTraits<DoubleOrString>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    DoubleOrString impl;
    V8DoubleOrString::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

DoubleOrStringOrStringArray::DoubleOrStringOrStringArray()
    : m_type(SpecificTypeNone)
{
}

double DoubleOrStringOrStringArray::getAsDouble() const
{
    ASSERT(isDouble());
    return m_double;
}

void DoubleOrStringOrStringArray::setDouble(double value)
{
    ASSERT(isNull());
    m_double = value;
    m_type = SpecificTypeDouble;
}

DoubleOrStringOrStringArray DoubleOrStringOrStringArray::fromDouble(double value)
{
    DoubleOrStringOrStringArray container;
    container.setDouble(value);
    return container;
}

String DoubleOrStringOrStringArray::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void DoubleOrStringOrStringArray::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

DoubleOrStringOrStringArray DoubleOrStringOrStringArray::fromString(String value)
{
    DoubleOrStringOrStringArray container;
    container.setString(value);
    return container;
}

const Vector<String>& DoubleOrStringOrStringArray::getAsStringArray() const
{
    ASSERT(isStringArray());
    return m_stringArray;
}

void DoubleOrStringOrStringArray::setStringArray(const Vector<String>& value)
{
    ASSERT(isNull());
    m_stringArray = value;
    m_type = SpecificTypeStringArray;
}

DoubleOrStringOrStringArray DoubleOrStringOrStringArray::fromStringArray(const Vector<String>& value)
{
    DoubleOrStringOrStringArray container;
    container.setStringArray(value);
    return container;
}

DoubleOrStringOrStringArray::DoubleOrStringOrStringArray(const DoubleOrStringOrStringArray&) = default;
DoubleOrStringOrStringArray::~DoubleOrStringOrStringArray() = default;
DoubleOrStringOrStringArray& DoubleOrStringOrStringArray::operator=(const DoubleOrStringOrStringArray&) = default;

DEFINE_TRACE(DoubleOrStringOrStringArray)
{
}

void V8DoubleOrStringOrStringArray::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrStringOrStringArray& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (v8Value->IsArray()) {
        Vector<String> cppValue = toImplArray<Vector<String>>(v8Value, 0, isolate, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setStringArray(cppValue);
        return;
    }

    if (v8Value->IsNumber()) {
        double cppValue = toRestrictedDouble(isolate, v8Value, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setDouble(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const DoubleOrStringOrStringArray& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case DoubleOrStringOrStringArray::SpecificTypeNone:
        return v8::Null(isolate);
    case DoubleOrStringOrStringArray::SpecificTypeDouble:
        return v8::Number::New(isolate, impl.getAsDouble());
    case DoubleOrStringOrStringArray::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    case DoubleOrStringOrStringArray::SpecificTypeStringArray:
        return toV8(impl.getAsStringArray(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

DoubleOrStringOrStringArray NativeValueTraits<DoubleOrStringOrStringArray>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    DoubleOrStringOrStringArray impl;
    V8DoubleOrStringOrStringArray::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

DoubleOrStringOrStringSequence::DoubleOrStringOrStringSequence()
    : m_type(SpecificTypeNone)
{
}

double DoubleOrStringOrStringSequence::getAsDouble() const
{
    ASSERT(isDouble());
    return m_double;
}

void DoubleOrStringOrStringSequence::setDouble(double value)
{
    ASSERT(isNull());
    m_double = value;
    m_type = SpecificTypeDouble;
}

DoubleOrStringOrStringSequence DoubleOrStringOrStringSequence::fromDouble(double value)
{
    DoubleOrStringOrStringSequence container;
    container.setDouble(value);
    return container;
}

String DoubleOrStringOrStringSequence::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void DoubleOrStringOrStringSequence::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

DoubleOrStringOrStringSequence DoubleOrStringOrStringSequence::fromString(String value)
{
    DoubleOrStringOrStringSequence container;
    container.setString(value);
    return container;
}

const Vector<String>& DoubleOrStringOrStringSequence::getAsStringSequence() const
{
    ASSERT(isStringSequence());
    return m_stringSequence;
}

void DoubleOrStringOrStringSequence::setStringSequence(const Vector<String>& value)
{
    ASSERT(isNull());
    m_stringSequence = value;
    m_type = SpecificTypeStringSequence;
}

DoubleOrStringOrStringSequence DoubleOrStringOrStringSequence::fromStringSequence(const Vector<String>& value)
{
    DoubleOrStringOrStringSequence container;
    container.setStringSequence(value);
    return container;
}

DoubleOrStringOrStringSequence::DoubleOrStringOrStringSequence(const DoubleOrStringOrStringSequence&) = default;
DoubleOrStringOrStringSequence::~DoubleOrStringOrStringSequence() = default;
DoubleOrStringOrStringSequence& DoubleOrStringOrStringSequence::operator=(const DoubleOrStringOrStringSequence&) = default;

DEFINE_TRACE(DoubleOrStringOrStringSequence)
{
}

void V8DoubleOrStringOrStringSequence::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrStringOrStringSequence& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (v8Value->IsArray()) {
        Vector<String> cppValue = toImplArray<Vector<String>>(v8Value, 0, isolate, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setStringSequence(cppValue);
        return;
    }

    if (v8Value->IsNumber()) {
        double cppValue = toRestrictedDouble(isolate, v8Value, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setDouble(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const DoubleOrStringOrStringSequence& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case DoubleOrStringOrStringSequence::SpecificTypeNone:
        return v8::Null(isolate);
    case DoubleOrStringOrStringSequence::SpecificTypeDouble:
        return v8::Number::New(isolate, impl.getAsDouble());
    case DoubleOrStringOrStringSequence::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    case DoubleOrStringOrStringSequence::SpecificTypeStringSequence:
        return toV8(impl.getAsStringSequence(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

DoubleOrStringOrStringSequence NativeValueTraits<DoubleOrStringOrStringSequence>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    DoubleOrStringOrStringSequence impl;
    V8DoubleOrStringOrStringSequence::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

EffectModelOrDictionarySequence::EffectModelOrDictionarySequence()
    : m_type(SpecificTypeNone)
{
}

PassRefPtrWillBeRawPtr<EffectModel> EffectModelOrDictionarySequence::getAsEffectModel() const
{
    ASSERT(isEffectModel());
    return m_effectModel;
}

void EffectModelOrDictionarySequence::setEffectModel(PassRefPtrWillBeRawPtr<EffectModel> value)
{
    ASSERT(isNull());
    m_effectModel = value;
    m_type = SpecificTypeEffectModel;
}

EffectModelOrDictionarySequence EffectModelOrDictionarySequence::fromEffectModel(PassRefPtrWillBeRawPtr<EffectModel> value)
{
    EffectModelOrDictionarySequence container;
    container.setEffectModel(value);
    return container;
}

const Vector<Dictionary>& EffectModelOrDictionarySequence::getAsDictionarySequence() const
{
    ASSERT(isDictionarySequence());
    return m_dictionarySequence;
}

void EffectModelOrDictionarySequence::setDictionarySequence(const Vector<Dictionary>& value)
{
    ASSERT(isNull());
    m_dictionarySequence = value;
    m_type = SpecificTypeDictionarySequence;
}

EffectModelOrDictionarySequence EffectModelOrDictionarySequence::fromDictionarySequence(const Vector<Dictionary>& value)
{
    EffectModelOrDictionarySequence container;
    container.setDictionarySequence(value);
    return container;
}

EffectModelOrDictionarySequence::EffectModelOrDictionarySequence(const EffectModelOrDictionarySequence&) = default;
EffectModelOrDictionarySequence::~EffectModelOrDictionarySequence() = default;
EffectModelOrDictionarySequence& EffectModelOrDictionarySequence::operator=(const EffectModelOrDictionarySequence&) = default;

DEFINE_TRACE(EffectModelOrDictionarySequence)
{
    visitor->trace(m_effectModel);
}

void V8EffectModelOrDictionarySequence::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, EffectModelOrDictionarySequence& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8EffectModel::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<EffectModel> cppValue = V8EffectModel::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setEffectModel(cppValue);
        return;
    }

    if (v8Value->IsArray()) {
        Vector<Dictionary> cppValue = toImplArray<Vector<Dictionary>>(v8Value, 0, isolate, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setDictionarySequence(cppValue);
        return;
    }

    exceptionState.throwTypeError("The provided value is not of type '(EffectModel or sequence<Dictionary>)'");
}

v8::Local<v8::Value> toV8(const EffectModelOrDictionarySequence& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case EffectModelOrDictionarySequence::SpecificTypeNone:
        return v8::Null(isolate);
    case EffectModelOrDictionarySequence::SpecificTypeEffectModel:
        return toV8(impl.getAsEffectModel(), creationContext, isolate);
    case EffectModelOrDictionarySequence::SpecificTypeDictionarySequence:
        return toV8(impl.getAsDictionarySequence(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

EffectModelOrDictionarySequence NativeValueTraits<EffectModelOrDictionarySequence>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    EffectModelOrDictionarySequence impl;
    V8EffectModelOrDictionarySequence::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

FileOrUSVString::FileOrUSVString()
    : m_type(SpecificTypeNone)
{
}

File* FileOrUSVString::getAsFile() const
{
    ASSERT(isFile());
    return m_file;
}

void FileOrUSVString::setFile(File* value)
{
    ASSERT(isNull());
    m_file = value;
    m_type = SpecificTypeFile;
}

FileOrUSVString FileOrUSVString::fromFile(File* value)
{
    FileOrUSVString container;
    container.setFile(value);
    return container;
}

String FileOrUSVString::getAsUSVString() const
{
    ASSERT(isUSVString());
    return m_uSVString;
}

void FileOrUSVString::setUSVString(String value)
{
    ASSERT(isNull());
    m_uSVString = value;
    m_type = SpecificTypeUSVString;
}

FileOrUSVString FileOrUSVString::fromUSVString(String value)
{
    FileOrUSVString container;
    container.setUSVString(value);
    return container;
}

FileOrUSVString::FileOrUSVString(const FileOrUSVString&) = default;
FileOrUSVString::~FileOrUSVString() = default;
FileOrUSVString& FileOrUSVString::operator=(const FileOrUSVString&) = default;

DEFINE_TRACE(FileOrUSVString)
{
    visitor->trace(m_file);
}

void V8FileOrUSVString::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, FileOrUSVString& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8File::hasInstance(v8Value, isolate)) {
        RawPtr<File> cppValue = V8File::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setFile(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = toUSVString(isolate, v8Value, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setUSVString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const FileOrUSVString& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case FileOrUSVString::SpecificTypeNone:
        return v8::Null(isolate);
    case FileOrUSVString::SpecificTypeFile:
        return toV8(impl.getAsFile(), creationContext, isolate);
    case FileOrUSVString::SpecificTypeUSVString:
        return v8String(isolate, impl.getAsUSVString());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

FileOrUSVString NativeValueTraits<FileOrUSVString>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    FileOrUSVString impl;
    V8FileOrUSVString::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

HTMLElementOrLong::HTMLElementOrLong()
    : m_type(SpecificTypeNone)
{
}

PassRefPtrWillBeRawPtr<HTMLElement> HTMLElementOrLong::getAsHTMLElement() const
{
    ASSERT(isHTMLElement());
    return m_htmlElement;
}

void HTMLElementOrLong::setHTMLElement(PassRefPtrWillBeRawPtr<HTMLElement> value)
{
    ASSERT(isNull());
    m_htmlElement = value;
    m_type = SpecificTypeHTMLElement;
}

HTMLElementOrLong HTMLElementOrLong::fromHTMLElement(PassRefPtrWillBeRawPtr<HTMLElement> value)
{
    HTMLElementOrLong container;
    container.setHTMLElement(value);
    return container;
}

int HTMLElementOrLong::getAsLong() const
{
    ASSERT(isLong());
    return m_long;
}

void HTMLElementOrLong::setLong(int value)
{
    ASSERT(isNull());
    m_long = value;
    m_type = SpecificTypeLong;
}

HTMLElementOrLong HTMLElementOrLong::fromLong(int value)
{
    HTMLElementOrLong container;
    container.setLong(value);
    return container;
}

HTMLElementOrLong::HTMLElementOrLong(const HTMLElementOrLong&) = default;
HTMLElementOrLong::~HTMLElementOrLong() = default;
HTMLElementOrLong& HTMLElementOrLong::operator=(const HTMLElementOrLong&) = default;

DEFINE_TRACE(HTMLElementOrLong)
{
    visitor->trace(m_htmlElement);
}

void V8HTMLElementOrLong::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, HTMLElementOrLong& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8HTMLElement::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<HTMLElement> cppValue = V8HTMLElement::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setHTMLElement(cppValue);
        return;
    }

    if (v8Value->IsNumber()) {
        int cppValue = toInt32(isolate, v8Value, NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setLong(cppValue);
        return;
    }

    {
        int cppValue = toInt32(isolate, v8Value, NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setLong(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const HTMLElementOrLong& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case HTMLElementOrLong::SpecificTypeNone:
        return v8::Null(isolate);
    case HTMLElementOrLong::SpecificTypeHTMLElement:
        return toV8(impl.getAsHTMLElement(), creationContext, isolate);
    case HTMLElementOrLong::SpecificTypeLong:
        return v8::Integer::New(isolate, impl.getAsLong());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

HTMLElementOrLong NativeValueTraits<HTMLElementOrLong>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    HTMLElementOrLong impl;
    V8HTMLElementOrLong::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

HTMLOptionElementOrHTMLOptGroupElement::HTMLOptionElementOrHTMLOptGroupElement()
    : m_type(SpecificTypeNone)
{
}

PassRefPtrWillBeRawPtr<HTMLOptionElement> HTMLOptionElementOrHTMLOptGroupElement::getAsHTMLOptionElement() const
{
    ASSERT(isHTMLOptionElement());
    return m_htmlOptionElement;
}

void HTMLOptionElementOrHTMLOptGroupElement::setHTMLOptionElement(PassRefPtrWillBeRawPtr<HTMLOptionElement> value)
{
    ASSERT(isNull());
    m_htmlOptionElement = value;
    m_type = SpecificTypeHTMLOptionElement;
}

HTMLOptionElementOrHTMLOptGroupElement HTMLOptionElementOrHTMLOptGroupElement::fromHTMLOptionElement(PassRefPtrWillBeRawPtr<HTMLOptionElement> value)
{
    HTMLOptionElementOrHTMLOptGroupElement container;
    container.setHTMLOptionElement(value);
    return container;
}

PassRefPtrWillBeRawPtr<HTMLOptGroupElement> HTMLOptionElementOrHTMLOptGroupElement::getAsHTMLOptGroupElement() const
{
    ASSERT(isHTMLOptGroupElement());
    return m_htmlOptGroupElement;
}

void HTMLOptionElementOrHTMLOptGroupElement::setHTMLOptGroupElement(PassRefPtrWillBeRawPtr<HTMLOptGroupElement> value)
{
    ASSERT(isNull());
    m_htmlOptGroupElement = value;
    m_type = SpecificTypeHTMLOptGroupElement;
}

HTMLOptionElementOrHTMLOptGroupElement HTMLOptionElementOrHTMLOptGroupElement::fromHTMLOptGroupElement(PassRefPtrWillBeRawPtr<HTMLOptGroupElement> value)
{
    HTMLOptionElementOrHTMLOptGroupElement container;
    container.setHTMLOptGroupElement(value);
    return container;
}

HTMLOptionElementOrHTMLOptGroupElement::HTMLOptionElementOrHTMLOptGroupElement(const HTMLOptionElementOrHTMLOptGroupElement&) = default;
HTMLOptionElementOrHTMLOptGroupElement::~HTMLOptionElementOrHTMLOptGroupElement() = default;
HTMLOptionElementOrHTMLOptGroupElement& HTMLOptionElementOrHTMLOptGroupElement::operator=(const HTMLOptionElementOrHTMLOptGroupElement&) = default;

DEFINE_TRACE(HTMLOptionElementOrHTMLOptGroupElement)
{
    visitor->trace(m_htmlOptionElement);
    visitor->trace(m_htmlOptGroupElement);
}

void V8HTMLOptionElementOrHTMLOptGroupElement::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, HTMLOptionElementOrHTMLOptGroupElement& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8HTMLOptionElement::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<HTMLOptionElement> cppValue = V8HTMLOptionElement::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setHTMLOptionElement(cppValue);
        return;
    }

    if (V8HTMLOptGroupElement::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<HTMLOptGroupElement> cppValue = V8HTMLOptGroupElement::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setHTMLOptGroupElement(cppValue);
        return;
    }

    exceptionState.throwTypeError("The provided value is not of type '(HTMLOptionElement or HTMLOptGroupElement)'");
}

v8::Local<v8::Value> toV8(const HTMLOptionElementOrHTMLOptGroupElement& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case HTMLOptionElementOrHTMLOptGroupElement::SpecificTypeNone:
        return v8::Null(isolate);
    case HTMLOptionElementOrHTMLOptGroupElement::SpecificTypeHTMLOptionElement:
        return toV8(impl.getAsHTMLOptionElement(), creationContext, isolate);
    case HTMLOptionElementOrHTMLOptGroupElement::SpecificTypeHTMLOptGroupElement:
        return toV8(impl.getAsHTMLOptGroupElement(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

HTMLOptionElementOrHTMLOptGroupElement NativeValueTraits<HTMLOptionElementOrHTMLOptGroupElement>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    HTMLOptionElementOrHTMLOptGroupElement impl;
    V8HTMLOptionElementOrHTMLOptGroupElement::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

NodeListOrElement::NodeListOrElement()
    : m_type(SpecificTypeNone)
{
}

PassRefPtrWillBeRawPtr<NodeList> NodeListOrElement::getAsNodeList() const
{
    ASSERT(isNodeList());
    return m_nodeList;
}

void NodeListOrElement::setNodeList(PassRefPtrWillBeRawPtr<NodeList> value)
{
    ASSERT(isNull());
    m_nodeList = value;
    m_type = SpecificTypeNodeList;
}

NodeListOrElement NodeListOrElement::fromNodeList(PassRefPtrWillBeRawPtr<NodeList> value)
{
    NodeListOrElement container;
    container.setNodeList(value);
    return container;
}

PassRefPtrWillBeRawPtr<Element> NodeListOrElement::getAsElement() const
{
    ASSERT(isElement());
    return m_element;
}

void NodeListOrElement::setElement(PassRefPtrWillBeRawPtr<Element> value)
{
    ASSERT(isNull());
    m_element = value;
    m_type = SpecificTypeElement;
}

NodeListOrElement NodeListOrElement::fromElement(PassRefPtrWillBeRawPtr<Element> value)
{
    NodeListOrElement container;
    container.setElement(value);
    return container;
}

NodeListOrElement::NodeListOrElement(const NodeListOrElement&) = default;
NodeListOrElement::~NodeListOrElement() = default;
NodeListOrElement& NodeListOrElement::operator=(const NodeListOrElement&) = default;

DEFINE_TRACE(NodeListOrElement)
{
    visitor->trace(m_nodeList);
    visitor->trace(m_element);
}

void V8NodeListOrElement::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, NodeListOrElement& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8NodeList::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<NodeList> cppValue = V8NodeList::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setNodeList(cppValue);
        return;
    }

    if (V8Element::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<Element> cppValue = V8Element::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setElement(cppValue);
        return;
    }

    exceptionState.throwTypeError("The provided value is not of type '(NodeList or Element)'");
}

v8::Local<v8::Value> toV8(const NodeListOrElement& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case NodeListOrElement::SpecificTypeNone:
        return v8::Null(isolate);
    case NodeListOrElement::SpecificTypeNodeList:
        return toV8(impl.getAsNodeList(), creationContext, isolate);
    case NodeListOrElement::SpecificTypeElement:
        return toV8(impl.getAsElement(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

NodeListOrElement NativeValueTraits<NodeListOrElement>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    NodeListOrElement impl;
    V8NodeListOrElement::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

NodeOrString::NodeOrString()
    : m_type(SpecificTypeNone)
{
}

PassRefPtrWillBeRawPtr<Node> NodeOrString::getAsNode() const
{
    ASSERT(isNode());
    return m_node;
}

void NodeOrString::setNode(PassRefPtrWillBeRawPtr<Node> value)
{
    ASSERT(isNull());
    m_node = value;
    m_type = SpecificTypeNode;
}

NodeOrString NodeOrString::fromNode(PassRefPtrWillBeRawPtr<Node> value)
{
    NodeOrString container;
    container.setNode(value);
    return container;
}

String NodeOrString::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void NodeOrString::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

NodeOrString NodeOrString::fromString(String value)
{
    NodeOrString container;
    container.setString(value);
    return container;
}

NodeOrString::NodeOrString(const NodeOrString&) = default;
NodeOrString::~NodeOrString() = default;
NodeOrString& NodeOrString::operator=(const NodeOrString&) = default;

DEFINE_TRACE(NodeOrString)
{
    visitor->trace(m_node);
}

void V8NodeOrString::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, NodeOrString& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8Node::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<Node> cppValue = V8Node::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setNode(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const NodeOrString& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case NodeOrString::SpecificTypeNone:
        return v8::Null(isolate);
    case NodeOrString::SpecificTypeNode:
        return toV8(impl.getAsNode(), creationContext, isolate);
    case NodeOrString::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

NodeOrString NativeValueTraits<NodeOrString>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    NodeOrString impl;
    V8NodeOrString::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

RadioNodeListOrElement::RadioNodeListOrElement()
    : m_type(SpecificTypeNone)
{
}

PassRefPtrWillBeRawPtr<RadioNodeList> RadioNodeListOrElement::getAsRadioNodeList() const
{
    ASSERT(isRadioNodeList());
    return m_radioNodeList;
}

void RadioNodeListOrElement::setRadioNodeList(PassRefPtrWillBeRawPtr<RadioNodeList> value)
{
    ASSERT(isNull());
    m_radioNodeList = value;
    m_type = SpecificTypeRadioNodeList;
}

RadioNodeListOrElement RadioNodeListOrElement::fromRadioNodeList(PassRefPtrWillBeRawPtr<RadioNodeList> value)
{
    RadioNodeListOrElement container;
    container.setRadioNodeList(value);
    return container;
}

PassRefPtrWillBeRawPtr<Element> RadioNodeListOrElement::getAsElement() const
{
    ASSERT(isElement());
    return m_element;
}

void RadioNodeListOrElement::setElement(PassRefPtrWillBeRawPtr<Element> value)
{
    ASSERT(isNull());
    m_element = value;
    m_type = SpecificTypeElement;
}

RadioNodeListOrElement RadioNodeListOrElement::fromElement(PassRefPtrWillBeRawPtr<Element> value)
{
    RadioNodeListOrElement container;
    container.setElement(value);
    return container;
}

RadioNodeListOrElement::RadioNodeListOrElement(const RadioNodeListOrElement&) = default;
RadioNodeListOrElement::~RadioNodeListOrElement() = default;
RadioNodeListOrElement& RadioNodeListOrElement::operator=(const RadioNodeListOrElement&) = default;

DEFINE_TRACE(RadioNodeListOrElement)
{
    visitor->trace(m_radioNodeList);
    visitor->trace(m_element);
}

void V8RadioNodeListOrElement::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, RadioNodeListOrElement& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8RadioNodeList::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<RadioNodeList> cppValue = V8RadioNodeList::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setRadioNodeList(cppValue);
        return;
    }

    if (V8Element::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<Element> cppValue = V8Element::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setElement(cppValue);
        return;
    }

    exceptionState.throwTypeError("The provided value is not of type '(RadioNodeList or Element)'");
}

v8::Local<v8::Value> toV8(const RadioNodeListOrElement& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case RadioNodeListOrElement::SpecificTypeNone:
        return v8::Null(isolate);
    case RadioNodeListOrElement::SpecificTypeRadioNodeList:
        return toV8(impl.getAsRadioNodeList(), creationContext, isolate);
    case RadioNodeListOrElement::SpecificTypeElement:
        return toV8(impl.getAsElement(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

RadioNodeListOrElement NativeValueTraits<RadioNodeListOrElement>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    RadioNodeListOrElement impl;
    V8RadioNodeListOrElement::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

StringOrArrayBuffer::StringOrArrayBuffer()
    : m_type(SpecificTypeNone)
{
}

String StringOrArrayBuffer::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void StringOrArrayBuffer::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

StringOrArrayBuffer StringOrArrayBuffer::fromString(String value)
{
    StringOrArrayBuffer container;
    container.setString(value);
    return container;
}

PassRefPtr<DOMArrayBuffer> StringOrArrayBuffer::getAsArrayBuffer() const
{
    ASSERT(isArrayBuffer());
    return m_arrayBuffer;
}

void StringOrArrayBuffer::setArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ASSERT(isNull());
    m_arrayBuffer = value;
    m_type = SpecificTypeArrayBuffer;
}

StringOrArrayBuffer StringOrArrayBuffer::fromArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    StringOrArrayBuffer container;
    container.setArrayBuffer(value);
    return container;
}

StringOrArrayBuffer::StringOrArrayBuffer(const StringOrArrayBuffer&) = default;
StringOrArrayBuffer::~StringOrArrayBuffer() = default;
StringOrArrayBuffer& StringOrArrayBuffer::operator=(const StringOrArrayBuffer&) = default;

DEFINE_TRACE(StringOrArrayBuffer)
{
}

void V8StringOrArrayBuffer::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, StringOrArrayBuffer& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8ArrayBuffer::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBuffer> cppValue = V8ArrayBuffer::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBuffer(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const StringOrArrayBuffer& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case StringOrArrayBuffer::SpecificTypeNone:
        return v8::Null(isolate);
    case StringOrArrayBuffer::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    case StringOrArrayBuffer::SpecificTypeArrayBuffer:
        return toV8(impl.getAsArrayBuffer(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

StringOrArrayBuffer NativeValueTraits<StringOrArrayBuffer>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    StringOrArrayBuffer impl;
    V8StringOrArrayBuffer::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

StringOrArrayBufferOrArrayBufferView::StringOrArrayBufferOrArrayBufferView()
    : m_type(SpecificTypeNone)
{
}

String StringOrArrayBufferOrArrayBufferView::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void StringOrArrayBufferOrArrayBufferView::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

StringOrArrayBufferOrArrayBufferView StringOrArrayBufferOrArrayBufferView::fromString(String value)
{
    StringOrArrayBufferOrArrayBufferView container;
    container.setString(value);
    return container;
}

PassRefPtr<DOMArrayBuffer> StringOrArrayBufferOrArrayBufferView::getAsArrayBuffer() const
{
    ASSERT(isArrayBuffer());
    return m_arrayBuffer;
}

void StringOrArrayBufferOrArrayBufferView::setArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    ASSERT(isNull());
    m_arrayBuffer = value;
    m_type = SpecificTypeArrayBuffer;
}

StringOrArrayBufferOrArrayBufferView StringOrArrayBufferOrArrayBufferView::fromArrayBuffer(PassRefPtr<DOMArrayBuffer> value)
{
    StringOrArrayBufferOrArrayBufferView container;
    container.setArrayBuffer(value);
    return container;
}

PassRefPtr<DOMArrayBufferView> StringOrArrayBufferOrArrayBufferView::getAsArrayBufferView() const
{
    ASSERT(isArrayBufferView());
    return m_arrayBufferView;
}

void StringOrArrayBufferOrArrayBufferView::setArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    ASSERT(isNull());
    m_arrayBufferView = value;
    m_type = SpecificTypeArrayBufferView;
}

StringOrArrayBufferOrArrayBufferView StringOrArrayBufferOrArrayBufferView::fromArrayBufferView(PassRefPtr<DOMArrayBufferView> value)
{
    StringOrArrayBufferOrArrayBufferView container;
    container.setArrayBufferView(value);
    return container;
}

StringOrArrayBufferOrArrayBufferView::StringOrArrayBufferOrArrayBufferView(const StringOrArrayBufferOrArrayBufferView&) = default;
StringOrArrayBufferOrArrayBufferView::~StringOrArrayBufferOrArrayBufferView() = default;
StringOrArrayBufferOrArrayBufferView& StringOrArrayBufferOrArrayBufferView::operator=(const StringOrArrayBufferOrArrayBufferView&) = default;

DEFINE_TRACE(StringOrArrayBufferOrArrayBufferView)
{
}

void V8StringOrArrayBufferOrArrayBufferView::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, StringOrArrayBufferOrArrayBufferView& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8ArrayBuffer::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBuffer> cppValue = V8ArrayBuffer::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBuffer(cppValue);
        return;
    }

    if (V8ArrayBufferView::hasInstance(v8Value, isolate)) {
        RefPtr<DOMArrayBufferView> cppValue = V8ArrayBufferView::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setArrayBufferView(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const StringOrArrayBufferOrArrayBufferView& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case StringOrArrayBufferOrArrayBufferView::SpecificTypeNone:
        return v8::Null(isolate);
    case StringOrArrayBufferOrArrayBufferView::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    case StringOrArrayBufferOrArrayBufferView::SpecificTypeArrayBuffer:
        return toV8(impl.getAsArrayBuffer(), creationContext, isolate);
    case StringOrArrayBufferOrArrayBufferView::SpecificTypeArrayBufferView:
        return toV8(impl.getAsArrayBufferView(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

StringOrArrayBufferOrArrayBufferView NativeValueTraits<StringOrArrayBufferOrArrayBufferView>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    StringOrArrayBufferOrArrayBufferView impl;
    V8StringOrArrayBufferOrArrayBufferView::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

StringOrFloat::StringOrFloat()
    : m_type(SpecificTypeNone)
{
}

String StringOrFloat::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void StringOrFloat::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

StringOrFloat StringOrFloat::fromString(String value)
{
    StringOrFloat container;
    container.setString(value);
    return container;
}

float StringOrFloat::getAsFloat() const
{
    ASSERT(isFloat());
    return m_float;
}

void StringOrFloat::setFloat(float value)
{
    ASSERT(isNull());
    m_float = value;
    m_type = SpecificTypeFloat;
}

StringOrFloat StringOrFloat::fromFloat(float value)
{
    StringOrFloat container;
    container.setFloat(value);
    return container;
}

StringOrFloat::StringOrFloat(const StringOrFloat&) = default;
StringOrFloat::~StringOrFloat() = default;
StringOrFloat& StringOrFloat::operator=(const StringOrFloat&) = default;

DEFINE_TRACE(StringOrFloat)
{
}

void V8StringOrFloat::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, StringOrFloat& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (v8Value->IsNumber()) {
        float cppValue = toRestrictedFloat(isolate, v8Value, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setFloat(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const StringOrFloat& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case StringOrFloat::SpecificTypeNone:
        return v8::Null(isolate);
    case StringOrFloat::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    case StringOrFloat::SpecificTypeFloat:
        return v8::Number::New(isolate, impl.getAsFloat());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

StringOrFloat NativeValueTraits<StringOrFloat>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    StringOrFloat impl;
    V8StringOrFloat::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

UnrestrictedDoubleOrString::UnrestrictedDoubleOrString()
    : m_type(SpecificTypeNone)
{
}

double UnrestrictedDoubleOrString::getAsUnrestrictedDouble() const
{
    ASSERT(isUnrestrictedDouble());
    return m_unrestrictedDouble;
}

void UnrestrictedDoubleOrString::setUnrestrictedDouble(double value)
{
    ASSERT(isNull());
    m_unrestrictedDouble = value;
    m_type = SpecificTypeUnrestrictedDouble;
}

UnrestrictedDoubleOrString UnrestrictedDoubleOrString::fromUnrestrictedDouble(double value)
{
    UnrestrictedDoubleOrString container;
    container.setUnrestrictedDouble(value);
    return container;
}

String UnrestrictedDoubleOrString::getAsString() const
{
    ASSERT(isString());
    return m_string;
}

void UnrestrictedDoubleOrString::setString(String value)
{
    ASSERT(isNull());
    m_string = value;
    m_type = SpecificTypeString;
}

UnrestrictedDoubleOrString UnrestrictedDoubleOrString::fromString(String value)
{
    UnrestrictedDoubleOrString container;
    container.setString(value);
    return container;
}

UnrestrictedDoubleOrString::UnrestrictedDoubleOrString(const UnrestrictedDoubleOrString&) = default;
UnrestrictedDoubleOrString::~UnrestrictedDoubleOrString() = default;
UnrestrictedDoubleOrString& UnrestrictedDoubleOrString::operator=(const UnrestrictedDoubleOrString&) = default;

DEFINE_TRACE(UnrestrictedDoubleOrString)
{
}

void V8UnrestrictedDoubleOrString::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, UnrestrictedDoubleOrString& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (v8Value->IsNumber()) {
        double cppValue = toDouble(isolate, v8Value, exceptionState);
        if (exceptionState.hadException())
            return;
        impl.setUnrestrictedDouble(cppValue);
        return;
    }

    {
        V8StringResource<> cppValue = v8Value;
        if (!cppValue.prepare(exceptionState))
            return;
        impl.setString(cppValue);
        return;
    }

}

v8::Local<v8::Value> toV8(const UnrestrictedDoubleOrString& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case UnrestrictedDoubleOrString::SpecificTypeNone:
        return v8::Null(isolate);
    case UnrestrictedDoubleOrString::SpecificTypeUnrestrictedDouble:
        return v8::Number::New(isolate, impl.getAsUnrestrictedDouble());
    case UnrestrictedDoubleOrString::SpecificTypeString:
        return v8String(isolate, impl.getAsString());
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

UnrestrictedDoubleOrString NativeValueTraits<UnrestrictedDoubleOrString>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    UnrestrictedDoubleOrString impl;
    V8UnrestrictedDoubleOrString::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

VideoTrackOrAudioTrackOrTextTrack::VideoTrackOrAudioTrackOrTextTrack()
    : m_type(SpecificTypeNone)
{
}

PassRefPtrWillBeRawPtr<VideoTrack> VideoTrackOrAudioTrackOrTextTrack::getAsVideoTrack() const
{
    ASSERT(isVideoTrack());
    return m_videoTrack;
}

void VideoTrackOrAudioTrackOrTextTrack::setVideoTrack(PassRefPtrWillBeRawPtr<VideoTrack> value)
{
    ASSERT(isNull());
    m_videoTrack = value;
    m_type = SpecificTypeVideoTrack;
}

VideoTrackOrAudioTrackOrTextTrack VideoTrackOrAudioTrackOrTextTrack::fromVideoTrack(PassRefPtrWillBeRawPtr<VideoTrack> value)
{
    VideoTrackOrAudioTrackOrTextTrack container;
    container.setVideoTrack(value);
    return container;
}

PassRefPtrWillBeRawPtr<AudioTrack> VideoTrackOrAudioTrackOrTextTrack::getAsAudioTrack() const
{
    ASSERT(isAudioTrack());
    return m_audioTrack;
}

void VideoTrackOrAudioTrackOrTextTrack::setAudioTrack(PassRefPtrWillBeRawPtr<AudioTrack> value)
{
    ASSERT(isNull());
    m_audioTrack = value;
    m_type = SpecificTypeAudioTrack;
}

VideoTrackOrAudioTrackOrTextTrack VideoTrackOrAudioTrackOrTextTrack::fromAudioTrack(PassRefPtrWillBeRawPtr<AudioTrack> value)
{
    VideoTrackOrAudioTrackOrTextTrack container;
    container.setAudioTrack(value);
    return container;
}

PassRefPtrWillBeRawPtr<TextTrack> VideoTrackOrAudioTrackOrTextTrack::getAsTextTrack() const
{
    ASSERT(isTextTrack());
    return m_textTrack;
}

void VideoTrackOrAudioTrackOrTextTrack::setTextTrack(PassRefPtrWillBeRawPtr<TextTrack> value)
{
    ASSERT(isNull());
    m_textTrack = value;
    m_type = SpecificTypeTextTrack;
}

VideoTrackOrAudioTrackOrTextTrack VideoTrackOrAudioTrackOrTextTrack::fromTextTrack(PassRefPtrWillBeRawPtr<TextTrack> value)
{
    VideoTrackOrAudioTrackOrTextTrack container;
    container.setTextTrack(value);
    return container;
}

VideoTrackOrAudioTrackOrTextTrack::VideoTrackOrAudioTrackOrTextTrack(const VideoTrackOrAudioTrackOrTextTrack&) = default;
VideoTrackOrAudioTrackOrTextTrack::~VideoTrackOrAudioTrackOrTextTrack() = default;
VideoTrackOrAudioTrackOrTextTrack& VideoTrackOrAudioTrackOrTextTrack::operator=(const VideoTrackOrAudioTrackOrTextTrack&) = default;

DEFINE_TRACE(VideoTrackOrAudioTrackOrTextTrack)
{
    visitor->trace(m_videoTrack);
    visitor->trace(m_audioTrack);
    visitor->trace(m_textTrack);
}

void V8VideoTrackOrAudioTrackOrTextTrack::toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, VideoTrackOrAudioTrackOrTextTrack& impl, ExceptionState& exceptionState)
{
    if (v8Value.IsEmpty())
        return;

    if (V8VideoTrack::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<VideoTrack> cppValue = V8VideoTrack::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setVideoTrack(cppValue);
        return;
    }

    if (V8AudioTrack::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<AudioTrack> cppValue = V8AudioTrack::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setAudioTrack(cppValue);
        return;
    }

    if (V8TextTrack::hasInstance(v8Value, isolate)) {
        RefPtrWillBeRawPtr<TextTrack> cppValue = V8TextTrack::toImpl(v8::Local<v8::Object>::Cast(v8Value));
        impl.setTextTrack(cppValue);
        return;
    }

    exceptionState.throwTypeError("The provided value is not of type '(VideoTrack or AudioTrack or TextTrack)'");
}

v8::Local<v8::Value> toV8(const VideoTrackOrAudioTrackOrTextTrack& impl, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)
{
    switch (impl.m_type) {
    case VideoTrackOrAudioTrackOrTextTrack::SpecificTypeNone:
        return v8::Null(isolate);
    case VideoTrackOrAudioTrackOrTextTrack::SpecificTypeVideoTrack:
        return toV8(impl.getAsVideoTrack(), creationContext, isolate);
    case VideoTrackOrAudioTrackOrTextTrack::SpecificTypeAudioTrack:
        return toV8(impl.getAsAudioTrack(), creationContext, isolate);
    case VideoTrackOrAudioTrackOrTextTrack::SpecificTypeTextTrack:
        return toV8(impl.getAsTextTrack(), creationContext, isolate);
    default:
        ASSERT_NOT_REACHED();
    }
    return v8::Local<v8::Value>();
}

VideoTrackOrAudioTrackOrTextTrack NativeValueTraits<VideoTrackOrAudioTrackOrTextTrack>::nativeValue(v8::Isolate* isolate, v8::Local<v8::Value> value, ExceptionState& exceptionState)
{
    VideoTrackOrAudioTrackOrTextTrack impl;
    V8VideoTrackOrAudioTrackOrTextTrack::toImpl(isolate, value, impl, exceptionState);
    return impl;
}

} // namespace blink
