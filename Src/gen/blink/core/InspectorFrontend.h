// File is generated by Source/core/inspector/CodeGeneratorInspector.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#ifndef InspectorFrontend_h
#define InspectorFrontend_h

#include "InspectorTypeBuilder.h"
#include "core/CoreExport.h"
#include "core/inspector/InspectorFrontendChannel.h"
#include "platform/JSONValues.h"
#include "wtf/PassRefPtr.h"
#include "wtf/text/WTFString.h"

namespace blink {

typedef String ErrorString;

class CORE_EXPORT InspectorFrontend {
public:
    InspectorFrontend(InspectorFrontendChannel*);
    InspectorFrontendChannel* channel() { return m_inspectorFrontendChannel; }

    class CORE_EXPORT Inspector {
    public:
        static Inspector* from(InspectorFrontend* frontend) { return &(frontend->m_inspector) ;}
        Inspector(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void evaluateForTestInFrontend(int testCallId, const String& script);
        void inspect(PassRefPtr<TypeBuilder::Runtime::RemoteObject> object, PassRefPtr<JSONObject> hints);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Memory {
    public:
        static Memory* from(InspectorFrontend* frontend) { return &(frontend->m_memory) ;}
        Memory(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Page {
    public:
        static Page* from(InspectorFrontend* frontend) { return &(frontend->m_page) ;}
        Page(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void domContentEventFired(double timestamp);
        void loadEventFired(double timestamp);
        void frameAttached(const TypeBuilder::Page::FrameId& frameId, const TypeBuilder::Page::FrameId& parentFrameId);
        void frameNavigated(PassRefPtr<TypeBuilder::Page::Frame> frame);
        void frameDetached(const TypeBuilder::Page::FrameId& frameId);
        void frameStartedLoading(const TypeBuilder::Page::FrameId& frameId);
        void frameStoppedLoading(const TypeBuilder::Page::FrameId& frameId);
        void frameScheduledNavigation(const TypeBuilder::Page::FrameId& frameId, double delay);
        void frameClearedScheduledNavigation(const TypeBuilder::Page::FrameId& frameId);
        void frameResized();
        void javascriptDialogOpening(const String& message, TypeBuilder::Page::DialogType::Enum type);
        void javascriptDialogClosed(bool result);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Rendering {
    public:
        static Rendering* from(InspectorFrontend* frontend) { return &(frontend->m_rendering) ;}
        Rendering(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Emulation {
    public:
        static Emulation* from(InspectorFrontend* frontend) { return &(frontend->m_emulation) ;}
        Emulation(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void viewportChanged(PassRefPtr<TypeBuilder::Emulation::Viewport> viewport);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Runtime {
    public:
        static Runtime* from(InspectorFrontend* frontend) { return &(frontend->m_runtime) ;}
        Runtime(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void executionContextCreated(PassRefPtr<TypeBuilder::Runtime::ExecutionContextDescription> context);
        void executionContextDestroyed(int executionContextId);
        void executionContextsCleared();

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Console {
    public:
        static Console* from(InspectorFrontend* frontend) { return &(frontend->m_console) ;}
        Console(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void messageAdded(PassRefPtr<TypeBuilder::Console::ConsoleMessage> message);
        void messageRepeatCountUpdated(int count, double timestamp);
        void messagesCleared();

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Network {
    public:
        static Network* from(InspectorFrontend* frontend) { return &(frontend->m_network) ;}
        Network(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void requestWillBeSent(const TypeBuilder::Network::RequestId& requestId, const TypeBuilder::Page::FrameId& frameId, const TypeBuilder::Network::LoaderId& loaderId, const String& documentURL, PassRefPtr<TypeBuilder::Network::Request> request, double timestamp, double wallTime, PassRefPtr<TypeBuilder::Network::Initiator> initiator, PassRefPtr<TypeBuilder::Network::Response> redirectResponse, TypeBuilder::Page::ResourceType::Enum* type);
        void requestServedFromCache(const TypeBuilder::Network::RequestId& requestId);
        void responseReceived(const TypeBuilder::Network::RequestId& requestId, const TypeBuilder::Page::FrameId& frameId, const TypeBuilder::Network::LoaderId& loaderId, double timestamp, TypeBuilder::Page::ResourceType::Enum type, PassRefPtr<TypeBuilder::Network::Response> response);
        void dataReceived(const TypeBuilder::Network::RequestId& requestId, double timestamp, int dataLength, int encodedDataLength);
        void loadingFinished(const TypeBuilder::Network::RequestId& requestId, double timestamp, double encodedDataLength);
        void loadingFailed(const TypeBuilder::Network::RequestId& requestId, double timestamp, TypeBuilder::Page::ResourceType::Enum type, const String& errorText, const bool* const canceled);
        void webSocketWillSendHandshakeRequest(const TypeBuilder::Network::RequestId& requestId, double timestamp, double wallTime, PassRefPtr<TypeBuilder::Network::WebSocketRequest> request);
        void webSocketHandshakeResponseReceived(const TypeBuilder::Network::RequestId& requestId, double timestamp, PassRefPtr<TypeBuilder::Network::WebSocketResponse> response);
        void webSocketCreated(const TypeBuilder::Network::RequestId& requestId, const String& url);
        void webSocketClosed(const TypeBuilder::Network::RequestId& requestId, double timestamp);
        void webSocketFrameReceived(const TypeBuilder::Network::RequestId& requestId, double timestamp, PassRefPtr<TypeBuilder::Network::WebSocketFrame> response);
        void webSocketFrameError(const TypeBuilder::Network::RequestId& requestId, double timestamp, const String& errorMessage);
        void webSocketFrameSent(const TypeBuilder::Network::RequestId& requestId, double timestamp, PassRefPtr<TypeBuilder::Network::WebSocketFrame> response);
        void eventSourceMessageReceived(const TypeBuilder::Network::RequestId& requestId, double timestamp, const String& eventName, const String& eventId, const String& data);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Database {
    public:
        static Database* from(InspectorFrontend* frontend) { return &(frontend->m_database) ;}
        Database(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void addDatabase(PassRefPtr<TypeBuilder::Database::Database> database);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT IndexedDB {
    public:
        static IndexedDB* from(InspectorFrontend* frontend) { return &(frontend->m_indexeddb) ;}
        IndexedDB(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT CacheStorage {
    public:
        static CacheStorage* from(InspectorFrontend* frontend) { return &(frontend->m_cachestorage) ;}
        CacheStorage(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT DOMStorage {
    public:
        static DOMStorage* from(InspectorFrontend* frontend) { return &(frontend->m_domstorage) ;}
        DOMStorage(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void domStorageItemsCleared(PassRefPtr<TypeBuilder::DOMStorage::StorageId> storageId);
        void domStorageItemRemoved(PassRefPtr<TypeBuilder::DOMStorage::StorageId> storageId, const String& key);
        void domStorageItemAdded(PassRefPtr<TypeBuilder::DOMStorage::StorageId> storageId, const String& key, const String& newValue);
        void domStorageItemUpdated(PassRefPtr<TypeBuilder::DOMStorage::StorageId> storageId, const String& key, const String& oldValue, const String& newValue);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT ApplicationCache {
    public:
        static ApplicationCache* from(InspectorFrontend* frontend) { return &(frontend->m_applicationcache) ;}
        ApplicationCache(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void applicationCacheStatusUpdated(const TypeBuilder::Page::FrameId& frameId, const String& manifestURL, int status);
        void networkStateUpdated(bool isNowOnline);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT FileSystem {
    public:
        static FileSystem* from(InspectorFrontend* frontend) { return &(frontend->m_filesystem) ;}
        FileSystem(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT DOM {
    public:
        static DOM* from(InspectorFrontend* frontend) { return &(frontend->m_dom) ;}
        DOM(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void documentUpdated();
        void inspectNodeRequested(int backendNodeId);
        void setChildNodes(int parentId, PassRefPtr<TypeBuilder::Array<TypeBuilder::DOM::Node> > nodes);
        void attributeModified(int nodeId, const String& name, const String& value);
        void attributeRemoved(int nodeId, const String& name);
        void inlineStyleInvalidated(PassRefPtr<TypeBuilder::Array<int> > nodeIds);
        void characterDataModified(int nodeId, const String& characterData);
        void childNodeCountUpdated(int nodeId, int childNodeCount);
        void childNodeInserted(int parentNodeId, int previousNodeId, PassRefPtr<TypeBuilder::DOM::Node> node);
        void childNodeRemoved(int parentNodeId, int nodeId);
        void shadowRootPushed(int hostId, PassRefPtr<TypeBuilder::DOM::Node> root);
        void shadowRootPopped(int hostId, int rootId);
        void pseudoElementAdded(int parentId, PassRefPtr<TypeBuilder::DOM::Node> pseudoElement);
        void pseudoElementRemoved(int parentId, int pseudoElementId);
        void distributedNodesUpdated(int insertionPointId, PassRefPtr<TypeBuilder::Array<TypeBuilder::DOM::BackendNode> > distributedNodes);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT CSS {
    public:
        static CSS* from(InspectorFrontend* frontend) { return &(frontend->m_css) ;}
        CSS(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void mediaQueryResultChanged();
        void styleSheetChanged(const TypeBuilder::CSS::StyleSheetId& styleSheetId);
        void styleSheetAdded(PassRefPtr<TypeBuilder::CSS::CSSStyleSheetHeader> header);
        void styleSheetRemoved(const TypeBuilder::CSS::StyleSheetId& styleSheetId);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Timeline {
    public:
        static Timeline* from(InspectorFrontend* frontend) { return &(frontend->m_timeline) ;}
        Timeline(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void eventRecorded(PassRefPtr<TypeBuilder::Timeline::TimelineEvent> record);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Debugger {
    public:
        static Debugger* from(InspectorFrontend* frontend) { return &(frontend->m_debugger) ;}
        Debugger(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void globalObjectCleared();
        void scriptParsed(const TypeBuilder::Debugger::ScriptId& scriptId, const String& url, int startLine, int startColumn, int endLine, int endColumn, const bool* const isContentScript, const bool* const isInternalScript, const String* const sourceMapURL, const bool* const hasSourceURL);
        void scriptFailedToParse(const TypeBuilder::Debugger::ScriptId& scriptId, const String& url, int startLine, int startColumn, int endLine, int endColumn, const bool* const isContentScript, const bool* const isInternalScript, const String* const sourceMapURL, const bool* const hasSourceURL);
        void breakpointResolved(const TypeBuilder::Debugger::BreakpointId& breakpointId, PassRefPtr<TypeBuilder::Debugger::Location> location);
        // Named after parameter 'reason' while generating command/event paused.
        struct Reason {
            enum Enum {
                XHR = 7,
                DOM = 173,
                EventListener = 174,
                Exception = 175,
                Assert = 55,
                CSPViolation = 176,
                DebugCommand = 177,
                PromiseRejection = 178,
                AsyncOperation = 179,
                Other = 40,
            };
        }; // struct Reason

        void paused(PassRefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > callFrames, Reason::Enum reason, PassRefPtr<JSONObject> data, PassRefPtr<TypeBuilder::Array<String> > hitBreakpoints, PassRefPtr<TypeBuilder::Debugger::StackTrace> asyncStackTrace);
        void resumed();
        // Named after parameter 'eventType' while generating command/event promiseUpdated.
        struct EventType {
            enum Enum {
                New = 102,
                Update = 180,
                Gc = 181,
            };
        }; // struct EventType

        void promiseUpdated(EventType::Enum eventType, PassRefPtr<TypeBuilder::Debugger::PromiseDetails> promise);
        void asyncOperationStarted(PassRefPtr<TypeBuilder::Debugger::AsyncOperation> operation);
        void asyncOperationCompleted(int id);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT DOMDebugger {
    public:
        static DOMDebugger* from(InspectorFrontend* frontend) { return &(frontend->m_domdebugger) ;}
        DOMDebugger(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Profiler {
    public:
        static Profiler* from(InspectorFrontend* frontend) { return &(frontend->m_profiler) ;}
        Profiler(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void consoleProfileStarted(const String& id, PassRefPtr<TypeBuilder::Debugger::Location> location, const String* const title);
        void consoleProfileFinished(const String& id, PassRefPtr<TypeBuilder::Debugger::Location> location, PassRefPtr<TypeBuilder::Profiler::CPUProfile> profile, const String* const title);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT HeapProfiler {
    public:
        static HeapProfiler* from(InspectorFrontend* frontend) { return &(frontend->m_heapprofiler) ;}
        HeapProfiler(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void addHeapSnapshotChunk(const String& chunk);
        void resetProfiles();
        void reportHeapSnapshotProgress(int done, int total, const bool* const finished);
        void lastSeenObjectId(int lastSeenObjectId, double timestamp);
        void heapStatsUpdate(PassRefPtr<TypeBuilder::Array<int> > statsUpdate);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Worker {
    public:
        static Worker* from(InspectorFrontend* frontend) { return &(frontend->m_worker) ;}
        Worker(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void workerCreated(const String& workerId, const String& url, bool inspectorConnected);
        void workerTerminated(const String& workerId);
        void dispatchMessageFromWorker(const String& workerId, const String& message);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT ServiceWorker {
    public:
        static ServiceWorker* from(InspectorFrontend* frontend) { return &(frontend->m_serviceworker) ;}
        ServiceWorker(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Input {
    public:
        static Input* from(InspectorFrontend* frontend) { return &(frontend->m_input) ;}
        Input(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT LayerTree {
    public:
        static LayerTree* from(InspectorFrontend* frontend) { return &(frontend->m_layertree) ;}
        LayerTree(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void layerTreeDidChange(PassRefPtr<TypeBuilder::Array<TypeBuilder::LayerTree::Layer> > layers);
        void layerPainted(const TypeBuilder::LayerTree::LayerId& layerId, PassRefPtr<TypeBuilder::DOM::Rect> clip);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT DeviceOrientation {
    public:
        static DeviceOrientation* from(InspectorFrontend* frontend) { return &(frontend->m_deviceorientation) ;}
        DeviceOrientation(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT ScreenOrientation {
    public:
        static ScreenOrientation* from(InspectorFrontend* frontend) { return &(frontend->m_screenorientation) ;}
        ScreenOrientation(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Tracing {
    public:
        static Tracing* from(InspectorFrontend* frontend) { return &(frontend->m_tracing) ;}
        Tracing(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Power {
    public:
        static Power* from(InspectorFrontend* frontend) { return &(frontend->m_power) ;}
        Power(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Animation {
    public:
        static Animation* from(InspectorFrontend* frontend) { return &(frontend->m_animation) ;}
        Animation(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void animationCreated(PassRefPtr<TypeBuilder::Animation::Animation> player, bool resetTimeline);
        void animationCanceled(const String& id);

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Accessibility {
    public:
        static Accessibility* from(InspectorFrontend* frontend) { return &(frontend->m_accessibility) ;}
        Accessibility(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    class CORE_EXPORT Security {
    public:
        static Security* from(InspectorFrontend* frontend) { return &(frontend->m_security) ;}
        Security(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }

        void flush() { m_inspectorFrontendChannel->flush(); }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };


private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
    Inspector m_inspector;
    Memory m_memory;
    Page m_page;
    Rendering m_rendering;
    Emulation m_emulation;
    Runtime m_runtime;
    Console m_console;
    Network m_network;
    Database m_database;
    IndexedDB m_indexeddb;
    CacheStorage m_cachestorage;
    DOMStorage m_domstorage;
    ApplicationCache m_applicationcache;
    FileSystem m_filesystem;
    DOM m_dom;
    CSS m_css;
    Timeline m_timeline;
    Debugger m_debugger;
    DOMDebugger m_domdebugger;
    Profiler m_profiler;
    HeapProfiler m_heapprofiler;
    Worker m_worker;
    ServiceWorker m_serviceworker;
    Input m_input;
    LayerTree m_layertree;
    DeviceOrientation m_deviceorientation;
    ScreenOrientation m_screenorientation;
    Tracing m_tracing;
    Power m_power;
    Animation m_animation;
    Accessibility m_accessibility;
    Security m_security;
};

} // namespace blink
#endif // !defined(InspectorFrontend_h)
