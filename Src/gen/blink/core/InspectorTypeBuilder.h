// File is generated by Source/core/inspector/CodeGeneratorInspector.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef InspectorTypeBuilder_h
#define InspectorTypeBuilder_h

#include "core/CoreExport.h"
#include "platform/JSONValues.h"
#include "wtf/Assertions.h"
#include "wtf/PassRefPtr.h"

namespace blink {

namespace TypeBuilder {

template<typename T>
class OptOutput {
public:
    OptOutput() : m_assigned(false) { }

    void operator=(T value)
    {
        m_value = value;
        m_assigned = true;
    }

    bool isAssigned() { return m_assigned; }

    T getValue()
    {
        ASSERT(isAssigned());
        return m_value;
    }

private:
    T m_value;
    bool m_assigned;

    WTF_MAKE_NONCOPYABLE(OptOutput);
};

class RuntimeCastHelper {
public:
#if ENABLE(ASSERT)
    template<JSONValue::Type TYPE>
    static void assertType(JSONValue* value)
    {
        ASSERT(value->type() == TYPE);
    }
    static void assertAny(JSONValue*);
    static void assertInt(JSONValue* value);
#endif
};


// This class provides "Traits" type for the input type T. It is programmed using C++ template specialization
// technique. By default it simply takes "ItemTraits" type from T, but it doesn't work with the base types.
template<typename T>
struct ArrayItemHelper {
    typedef typename T::ItemTraits Traits;
};

template<typename T>
class Array : public JSONArrayBase {
private:
    Array() { }

    JSONArray* openAccessors() {
        static_assert(sizeof(JSONArray) == sizeof(Array<T>), "JSONArray should be the same size as Array<T>");
        return static_cast<JSONArray*>(static_cast<JSONArrayBase*>(this));
    }

public:
    void addItem(PassRefPtr<T> value)
    {
        ArrayItemHelper<T>::Traits::pushRefPtr(this->openAccessors(), value);
    }

    void addItem(T value)
    {
        ArrayItemHelper<T>::Traits::pushRaw(this->openAccessors(), value);
    }

    static PassRefPtr<Array<T> > create()
    {
        return adoptRef(new Array<T>());
    }

    static PassRefPtr<Array<T> > runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONArray> array;
        bool castRes = value->asArray(&array);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(array.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(Array<T>) == sizeof(JSONArray), "Array<T> should be the same size as JSONArray");
        return static_cast<Array<T>*>(static_cast<JSONArrayBase*>(array.get()));
    }

    void concat(PassRefPtr<Array<T> > array)
    {
        return ArrayItemHelper<T>::Traits::concat(this->openAccessors(), array->openAccessors());
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value)
    {
        RefPtr<JSONArray> array;
        bool castRes = value->asArray(&array);
        ASSERT_UNUSED(castRes, castRes);
        for (unsigned i = 0; i < array->length(); i++)
            ArrayItemHelper<T>::Traits::template assertCorrectValue<T>(array->get(i).get());
    }

#endif // ENABLE(ASSERT)
};

struct StructItemTraits {
    static void pushRefPtr(JSONArray* array, PassRefPtr<JSONValue> value)
    {
        array->pushValue(value);
    }

    static void concat(JSONArray* array, JSONArray* anotherArray)
    {
        for (JSONArray::iterator it = anotherArray->begin(); it != anotherArray->end(); ++it)
            array->pushValue(*it);
    }

#if ENABLE(ASSERT)
    template<typename T>
    static void assertCorrectValue(JSONValue* value) {
        T::assertCorrectValue(value);
    }
#endif  // ENABLE(ASSERT)
};

template<>
struct ArrayItemHelper<String> {
    struct Traits {
        static void pushRaw(JSONArray* array, const String& value)
        {
            array->pushString(value);
        }

#if ENABLE(ASSERT)
        template<typename T>
        static void assertCorrectValue(JSONValue* value) {
            RuntimeCastHelper::assertType<JSONValue::TypeString>(value);
        }
#endif  // ENABLE(ASSERT)
    };
};

template<>
struct ArrayItemHelper<int> {
    struct Traits {
        static void pushRaw(JSONArray* array, int value)
        {
            array->pushInt(value);
        }

#if ENABLE(ASSERT)
        template<typename T>
        static void assertCorrectValue(JSONValue* value) {
            RuntimeCastHelper::assertInt(value);
        }
#endif  // ENABLE(ASSERT)
    };
};

template<>
struct ArrayItemHelper<double> {
    struct Traits {
        static void pushRaw(JSONArray* array, double value)
        {
            array->pushNumber(value);
        }

#if ENABLE(ASSERT)
        template<typename T>
        static void assertCorrectValue(JSONValue* value) {
            RuntimeCastHelper::assertType<JSONValue::TypeNumber>(value);
        }
#endif  // ENABLE(ASSERT)
    };
};

template<>
struct ArrayItemHelper<bool> {
    struct Traits {
        static void pushRaw(JSONArray* array, bool value)
        {
            array->pushBoolean(value);
        }

#if ENABLE(ASSERT)
        template<typename T>
        static void assertCorrectValue(JSONValue* value) {
            RuntimeCastHelper::assertType<JSONValue::TypeBoolean>(value);
        }
#endif  // ENABLE(ASSERT)
    };
};

template<>
struct ArrayItemHelper<JSONValue> {
    struct Traits {
        static void pushRefPtr(JSONArray* array, PassRefPtr<JSONValue> value)
        {
            array->pushValue(value);
        }

#if ENABLE(ASSERT)
        template<typename T>
        static void assertCorrectValue(JSONValue* value) {
            RuntimeCastHelper::assertAny(value);
        }
#endif  // ENABLE(ASSERT)
    };
};

template<>
struct ArrayItemHelper<JSONObject> {
    struct Traits {
        static void pushRefPtr(JSONArray* array, PassRefPtr<JSONValue> value)
        {
            array->pushValue(value);
        }

#if ENABLE(ASSERT)
        template<typename T>
        static void assertCorrectValue(JSONValue* value) {
            RuntimeCastHelper::assertType<JSONValue::TypeObject>(value);
        }
#endif  // ENABLE(ASSERT)
    };
};

template<>
struct ArrayItemHelper<JSONArray> {
    struct Traits {
        static void pushRefPtr(JSONArray* array, PassRefPtr<JSONArray> value)
        {
            array->pushArray(value);
        }

#if ENABLE(ASSERT)
        template<typename T>
        static void assertCorrectValue(JSONValue* value) {
            RuntimeCastHelper::assertType<JSONValue::TypeArray>(value);
        }
#endif  // ENABLE(ASSERT)
    };
};

template<typename T>
struct ArrayItemHelper<TypeBuilder::Array<T> > {
    struct Traits {
        static void pushRefPtr(JSONArray* array, PassRefPtr<TypeBuilder::Array<T> > value)
        {
            array->pushValue(value);
        }

#if ENABLE(ASSERT)
        template<typename S>
        static void assertCorrectValue(JSONValue* value) {
            S::assertCorrectValue(value);
        }
#endif  // ENABLE(ASSERT)
    };
};

// Forward declarations.
namespace Runtime {
class CustomPreview;
class ObjectPreview;
class PropertyPreview;
class EntryPreview;
} // Runtime

namespace Console {
class CallFrame;
class AsyncStackTrace;
} // Console

namespace IndexedDB {
class ObjectStore;
class ObjectStoreIndex;
class KeyPath;
} // IndexedDB

namespace DOM {
class ShapeOutsideInfo;
} // DOM

namespace CSS {
class RuleMatch;
class CSSRule;
class SourceRange;
class CSSStyle;
class CSSProperty;
class CSSMedia;
class MediaQuery;
class MediaQueryExpression;
} // CSS

namespace Debugger {
class Scope;
} // Debugger

namespace Profiler {
class PositionTickInfo;
} // Profiler

namespace Animation {
class AnimationEffect;
class KeyframesRule;
class KeyframeStyle;
} // Animation

namespace Accessibility {
class AXValue;
} // Accessibility

// End of forward declarations.

// Typedefs.
namespace Page {
/* Unique frame identifier. */
typedef String FrameId;

/* Unique script identifier. */
typedef String ScriptIdentifier;

} // Page

namespace Runtime {
/* Unique object identifier. */
typedef String RemoteObjectId;

} // Runtime

namespace Network {
/* Unique loader identifier. */
typedef String LoaderId;

/* Unique request identifier. */
typedef String RequestId;

} // Network

namespace Database {
/* Unique identifier of Database object. */
typedef String DatabaseId;

} // Database

namespace CacheStorage {
/* Unique identifier of the Cache object. */
typedef String CacheId;

} // CacheStorage

namespace CSS {
typedef String StyleSheetId;

} // CSS

namespace Debugger {
/* Breakpoint identifier. */
typedef String BreakpointId;

/* Unique script identifier. */
typedef String ScriptId;

/* Call frame identifier. */
typedef String CallFrameId;

} // Debugger

namespace HeapProfiler {
/* Heap snapshot object id. */
typedef String HeapSnapshotObjectId;

} // HeapProfiler

namespace ServiceWorker {
typedef String TargetID;

} // ServiceWorker

namespace LayerTree {
/* Unique Layer identifier. */
typedef String LayerId;

/* Unique snapshot identifier. */
typedef String SnapshotId;

} // LayerTree

namespace Accessibility {
/* Unique accessibility node identifier. */
typedef String AXNodeId;

} // Accessibility

// End of typedefs.



CORE_EXPORT String getEnumConstantValue(int code);

namespace Page {
/* Resource type as it was perceived by the rendering engine. */
struct ResourceType {
    enum Enum {
        Document = 0,
        Stylesheet = 1,
        Image = 2,
        Media = 3,
        Font = 4,
        Script = 5,
        TextTrack = 6,
        XHR = 7,
        WebSocket = 8,
        Other = 9,
    };
}; // struct ResourceType

/* Information about the Frame on the page. */
class Frame : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        LoaderIdSet = 1 << 1,
        UrlSet = 1 << 2,
        SecurityOriginSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        AllFieldsSet = (IdSet | LoaderIdSet | UrlSet | SecurityOriginSet | MimeTypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Frame*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Frame;
    public:

        Builder<STATE | IdSet>& setId(const String& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setString("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | LoaderIdSet>& setLoaderId(const TypeBuilder::Network::LoaderId& value)
        {
            static_assert(!(STATE & LoaderIdSet), "property loaderId should not be set yet");
            m_result->setString("loaderId", value);
            return castState<LoaderIdSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            static_assert(!(STATE & SecurityOriginSet), "property securityOrigin should not be set yet");
            m_result->setString("securityOrigin", value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            static_assert(!(STATE & MimeTypeSet), "property mimeType should not be set yet");
            m_result->setString("mimeType", value);
            return castState<MimeTypeSet>();
        }

        operator RefPtr<Frame>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Frame) == sizeof(JSONObject), "Frame should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Frame>*>(&m_result);
        }

        PassRefPtr<Frame> release()
        {
            return RefPtr<Frame>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Frame> result = Frame::create()
     *     .setId(...)
     *     .setLoaderId(...)
     *     .setUrl(...)
     *     .setSecurityOrigin(...)
     *     .setMimeType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void id(String* value)
    {
        JSONObjectBase::getString("id", value);
    }

    void loaderId(TypeBuilder::Network::LoaderId* value)
    {
        JSONObjectBase::getString("loaderId", value);
    }

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void securityOrigin(String* value)
    {
        JSONObjectBase::getString("securityOrigin", value);
    }

    void mimeType(String* value)
    {
        JSONObjectBase::getString("mimeType", value);
    }

    void setParentId(const String& value)
    {
        this->setString("parentId", value);
    }

    void setName(const String& value)
    {
        this->setString("name", value);
    }
};

/* Information about the Frame hierarchy along with their cached resources. */
class FrameResourceTree : public JSONObjectBase {
public:
    // Named after property name 'resources' while generating FrameResourceTree.
    class Resources : public JSONObjectBase {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 0,
            TypeSet = 1 << 1,
            MimeTypeSet = 1 << 2,
            AllFieldsSet = (UrlSet | TypeSet | MimeTypeSet)
        };

        template<int STATE>
        class Builder {
        private:
            RefPtr<JSONObject> m_result;

            template<int STEP> Builder<STATE | STEP>& castState()
            {
                return *reinterpret_cast<Builder<STATE | STEP>*>(this);
            }

            Builder(PassRefPtr</*Resources*/JSONObject> ptr)
            {
                static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
                m_result = ptr;
            }
            friend class Resources;
        public:
    
            Builder<STATE | UrlSet>& setUrl(const String& value)
            {
                static_assert(!(STATE & UrlSet), "property url should not be set yet");
                m_result->setString("url", value);
                return castState<UrlSet>();
            }
    
            Builder<STATE | TypeSet>& setType(TypeBuilder::Page::ResourceType::Enum value)
            {
                static_assert(!(STATE & TypeSet), "property type should not be set yet");
                m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
                return castState<TypeSet>();
            }
    
            Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
            {
                static_assert(!(STATE & MimeTypeSet), "property mimeType should not be set yet");
                m_result->setString("mimeType", value);
                return castState<MimeTypeSet>();
            }
    
            operator RefPtr<Resources>& ()
            {
                static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
                static_assert(sizeof(Resources) == sizeof(JSONObject), "Resources should be the same size as JSONObject");
                return *reinterpret_cast<RefPtr<Resources>*>(&m_result);
            }

            PassRefPtr<Resources> release()
            {
                return RefPtr<Resources>(*this).release();
            }
        };

        /*
         * Synthetic constructor:
         * RefPtr<Resources> result = Resources::create()
         *     .setUrl(...)
         *     .setType(...)
         *     .setMimeType(...);
         */
        static Builder<NoFieldsSet> create()
        {
            return Builder<NoFieldsSet>(JSONObject::create());
        }
        typedef TypeBuilder::StructItemTraits ItemTraits;

        void url(String* value)
        {
            JSONObjectBase::getString("url", value);
        }

        void mimeType(String* value)
        {
            JSONObjectBase::getString("mimeType", value);
        }

        void setFailed(bool value)
        {
            this->setBoolean("failed", value);
        }

        void setCanceled(bool value)
        {
            this->setBoolean("canceled", value);
        }
    };

    enum {
        NoFieldsSet = 0,
        FrameSet = 1 << 0,
        ResourcesSet = 1 << 1,
        AllFieldsSet = (FrameSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*FrameResourceTree*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class FrameResourceTree;
    public:

        Builder<STATE | FrameSet>& setFrame(PassRefPtr<TypeBuilder::Page::Frame> value)
        {
            static_assert(!(STATE & FrameSet), "property frame should not be set yet");
            m_result->setValue("frame", value);
            return castState<FrameSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(PassRefPtr<TypeBuilder::Array<Resources> > value)
        {
            static_assert(!(STATE & ResourcesSet), "property resources should not be set yet");
            m_result->setValue("resources", value);
            return castState<ResourcesSet>();
        }

        operator RefPtr<FrameResourceTree>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(FrameResourceTree) == sizeof(JSONObject), "FrameResourceTree should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<FrameResourceTree>*>(&m_result);
        }

        PassRefPtr<FrameResourceTree> release()
        {
            return RefPtr<FrameResourceTree>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FrameResourceTree> result = FrameResourceTree::create()
     *     .setFrame(...)
     *     .setResources(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setChildFrames(PassRefPtr<TypeBuilder::Array<TypeBuilder::Page::FrameResourceTree> > value)
    {
        this->setValue("childFrames", value);
    }
};

/* Navigation history entry. */
class NavigationEntry : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        UrlSet = 1 << 1,
        TitleSet = 1 << 2,
        AllFieldsSet = (IdSet | UrlSet | TitleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*NavigationEntry*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class NavigationEntry;
    public:

        Builder<STATE | IdSet>& setId(int value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setNumber("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            static_assert(!(STATE & TitleSet), "property title should not be set yet");
            m_result->setString("title", value);
            return castState<TitleSet>();
        }

        operator RefPtr<NavigationEntry>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(NavigationEntry) == sizeof(JSONObject), "NavigationEntry should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<NavigationEntry>*>(&m_result);
        }

        PassRefPtr<NavigationEntry> release()
        {
            return RefPtr<NavigationEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<NavigationEntry> result = NavigationEntry::create()
     *     .setId(...)
     *     .setUrl(...)
     *     .setTitle(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void id(int* value)
    {
        JSONObjectBase::getNumber("id", value);
    }

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void title(String* value)
    {
        JSONObjectBase::getString("title", value);
    }
};

/* Screencast frame metadata */
class ScreencastFrameMetadata : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        OffsetTopSet = 1 << 0,
        PageScaleFactorSet = 1 << 1,
        DeviceWidthSet = 1 << 2,
        DeviceHeightSet = 1 << 3,
        ScrollOffsetXSet = 1 << 4,
        ScrollOffsetYSet = 1 << 5,
        AllFieldsSet = (OffsetTopSet | PageScaleFactorSet | DeviceWidthSet | DeviceHeightSet | ScrollOffsetXSet | ScrollOffsetYSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ScreencastFrameMetadata*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ScreencastFrameMetadata;
    public:

        Builder<STATE | OffsetTopSet>& setOffsetTop(double value)
        {
            static_assert(!(STATE & OffsetTopSet), "property offsetTop should not be set yet");
            m_result->setNumber("offsetTop", value);
            return castState<OffsetTopSet>();
        }

        Builder<STATE | PageScaleFactorSet>& setPageScaleFactor(double value)
        {
            static_assert(!(STATE & PageScaleFactorSet), "property pageScaleFactor should not be set yet");
            m_result->setNumber("pageScaleFactor", value);
            return castState<PageScaleFactorSet>();
        }

        Builder<STATE | DeviceWidthSet>& setDeviceWidth(double value)
        {
            static_assert(!(STATE & DeviceWidthSet), "property deviceWidth should not be set yet");
            m_result->setNumber("deviceWidth", value);
            return castState<DeviceWidthSet>();
        }

        Builder<STATE | DeviceHeightSet>& setDeviceHeight(double value)
        {
            static_assert(!(STATE & DeviceHeightSet), "property deviceHeight should not be set yet");
            m_result->setNumber("deviceHeight", value);
            return castState<DeviceHeightSet>();
        }

        Builder<STATE | ScrollOffsetXSet>& setScrollOffsetX(double value)
        {
            static_assert(!(STATE & ScrollOffsetXSet), "property scrollOffsetX should not be set yet");
            m_result->setNumber("scrollOffsetX", value);
            return castState<ScrollOffsetXSet>();
        }

        Builder<STATE | ScrollOffsetYSet>& setScrollOffsetY(double value)
        {
            static_assert(!(STATE & ScrollOffsetYSet), "property scrollOffsetY should not be set yet");
            m_result->setNumber("scrollOffsetY", value);
            return castState<ScrollOffsetYSet>();
        }

        operator RefPtr<ScreencastFrameMetadata>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ScreencastFrameMetadata) == sizeof(JSONObject), "ScreencastFrameMetadata should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ScreencastFrameMetadata>*>(&m_result);
        }

        PassRefPtr<ScreencastFrameMetadata> release()
        {
            return RefPtr<ScreencastFrameMetadata>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ScreencastFrameMetadata> result = ScreencastFrameMetadata::create()
     *     .setOffsetTop(...)
     *     .setPageScaleFactor(...)
     *     .setDeviceWidth(...)
     *     .setDeviceHeight(...)
     *     .setScrollOffsetX(...)
     *     .setScrollOffsetY(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void offsetTop(double* value)
    {
        JSONObjectBase::getNumber("offsetTop", value);
    }

    void pageScaleFactor(double* value)
    {
        JSONObjectBase::getNumber("pageScaleFactor", value);
    }

    void deviceWidth(double* value)
    {
        JSONObjectBase::getNumber("deviceWidth", value);
    }

    void deviceHeight(double* value)
    {
        JSONObjectBase::getNumber("deviceHeight", value);
    }

    void scrollOffsetX(double* value)
    {
        JSONObjectBase::getNumber("scrollOffsetX", value);
    }

    void scrollOffsetY(double* value)
    {
        JSONObjectBase::getNumber("scrollOffsetY", value);
    }

    void setTimestamp(double value)
    {
        this->setNumber("timestamp", value);
    }
};

/* Javascript dialog type */
struct DialogType {
    enum Enum {
        Alert = 10,
        Confirm = 11,
        Prompt = 12,
        Beforeunload = 13,
    };
}; // struct DialogType

} // Page

namespace Emulation {
/* Visible page viewport */
class Viewport : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ScrollXSet = 1 << 0,
        ScrollYSet = 1 << 1,
        ContentsWidthSet = 1 << 2,
        ContentsHeightSet = 1 << 3,
        PageScaleFactorSet = 1 << 4,
        MinimumPageScaleFactorSet = 1 << 5,
        MaximumPageScaleFactorSet = 1 << 6,
        AllFieldsSet = (ScrollXSet | ScrollYSet | ContentsWidthSet | ContentsHeightSet | PageScaleFactorSet | MinimumPageScaleFactorSet | MaximumPageScaleFactorSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Viewport*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Viewport;
    public:

        Builder<STATE | ScrollXSet>& setScrollX(double value)
        {
            static_assert(!(STATE & ScrollXSet), "property scrollX should not be set yet");
            m_result->setNumber("scrollX", value);
            return castState<ScrollXSet>();
        }

        Builder<STATE | ScrollYSet>& setScrollY(double value)
        {
            static_assert(!(STATE & ScrollYSet), "property scrollY should not be set yet");
            m_result->setNumber("scrollY", value);
            return castState<ScrollYSet>();
        }

        Builder<STATE | ContentsWidthSet>& setContentsWidth(double value)
        {
            static_assert(!(STATE & ContentsWidthSet), "property contentsWidth should not be set yet");
            m_result->setNumber("contentsWidth", value);
            return castState<ContentsWidthSet>();
        }

        Builder<STATE | ContentsHeightSet>& setContentsHeight(double value)
        {
            static_assert(!(STATE & ContentsHeightSet), "property contentsHeight should not be set yet");
            m_result->setNumber("contentsHeight", value);
            return castState<ContentsHeightSet>();
        }

        Builder<STATE | PageScaleFactorSet>& setPageScaleFactor(double value)
        {
            static_assert(!(STATE & PageScaleFactorSet), "property pageScaleFactor should not be set yet");
            m_result->setNumber("pageScaleFactor", value);
            return castState<PageScaleFactorSet>();
        }

        Builder<STATE | MinimumPageScaleFactorSet>& setMinimumPageScaleFactor(double value)
        {
            static_assert(!(STATE & MinimumPageScaleFactorSet), "property minimumPageScaleFactor should not be set yet");
            m_result->setNumber("minimumPageScaleFactor", value);
            return castState<MinimumPageScaleFactorSet>();
        }

        Builder<STATE | MaximumPageScaleFactorSet>& setMaximumPageScaleFactor(double value)
        {
            static_assert(!(STATE & MaximumPageScaleFactorSet), "property maximumPageScaleFactor should not be set yet");
            m_result->setNumber("maximumPageScaleFactor", value);
            return castState<MaximumPageScaleFactorSet>();
        }

        operator RefPtr<Viewport>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Viewport) == sizeof(JSONObject), "Viewport should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Viewport>*>(&m_result);
        }

        PassRefPtr<Viewport> release()
        {
            return RefPtr<Viewport>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Viewport> result = Viewport::create()
     *     .setScrollX(...)
     *     .setScrollY(...)
     *     .setContentsWidth(...)
     *     .setContentsHeight(...)
     *     .setPageScaleFactor(...)
     *     .setMinimumPageScaleFactor(...)
     *     .setMaximumPageScaleFactor(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void scrollX(double* value)
    {
        JSONObjectBase::getNumber("scrollX", value);
    }

    void scrollY(double* value)
    {
        JSONObjectBase::getNumber("scrollY", value);
    }

    void contentsWidth(double* value)
    {
        JSONObjectBase::getNumber("contentsWidth", value);
    }

    void contentsHeight(double* value)
    {
        JSONObjectBase::getNumber("contentsHeight", value);
    }

    void pageScaleFactor(double* value)
    {
        JSONObjectBase::getNumber("pageScaleFactor", value);
    }

    void minimumPageScaleFactor(double* value)
    {
        JSONObjectBase::getNumber("minimumPageScaleFactor", value);
    }

    void maximumPageScaleFactor(double* value)
    {
        JSONObjectBase::getNumber("maximumPageScaleFactor", value);
    }
};

} // Emulation

namespace Runtime {
/* Mirror object referencing original JavaScript object. */
class RemoteObject : public JSONObjectBase {
public:
    // Named after property name 'type' while generating RemoteObject.
    struct Type {
        enum Enum {
            Object = 14,
            Function = 15,
            Undefined = 16,
            String = 17,
            Number = 18,
            Boolean = 19,
            Symbol = 20,
        };
#if ENABLE(ASSERT)
        static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
    }; // struct Type

    // Named after property name 'subtype' while generating RemoteObject.
    struct Subtype {
        enum Enum {
            Array = 21,
            Null = 22,
            Node = 23,
            Regexp = 24,
            Date = 25,
            Map = 26,
            Set = 27,
            Iterator = 28,
            Generator = 29,
            Error = 30,
        };
#if ENABLE(ASSERT)
        static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
    }; // struct Subtype

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*RemoteObject*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class RemoteObject;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<RemoteObject>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(RemoteObject) == sizeof(JSONObject), "RemoteObject should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<RemoteObject>*>(&m_result);
        }

        PassRefPtr<RemoteObject> release()
        {
            return RefPtr<RemoteObject>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<RemoteObject> result = RemoteObject::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setSubtype(Subtype::Enum value)
    {
        this->setString("subtype", TypeBuilder::getEnumConstantValue(value));
    }

    void setClassName(const String& value)
    {
        this->setString("className", value);
    }

    void setValue(PassRefPtr<JSONValue> value)
    {
        this->setValue("value", value);
    }
    using JSONObjectBase::setValue;


    void setDescription(const String& value)
    {
        this->setString("description", value);
    }

    void setObjectId(const TypeBuilder::Runtime::RemoteObjectId& value)
    {
        this->setString("objectId", value);
    }

    void setPreview(PassRefPtr<TypeBuilder::Runtime::ObjectPreview> value)
    {
        this->setValue("preview", value);
    }

    void setCustomPreview(PassRefPtr<TypeBuilder::Runtime::CustomPreview> value)
    {
        this->setValue("customPreview", value);
    }
    static PassRefPtr<RemoteObject> runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(object.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(RemoteObject) == sizeof(JSONObjectBase), "RemoteObject should be the same size as JSONObjectBase");
        return static_cast<RemoteObject*>(static_cast<JSONObjectBase*>(object.get()));
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

class CustomPreview : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        HeaderSet = 1 << 0,
        HasBodySet = 1 << 1,
        FormatterObjectIdSet = 1 << 2,
        AllFieldsSet = (HeaderSet | HasBodySet | FormatterObjectIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CustomPreview*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CustomPreview;
    public:

        Builder<STATE | HeaderSet>& setHeader(const String& value)
        {
            static_assert(!(STATE & HeaderSet), "property header should not be set yet");
            m_result->setString("header", value);
            return castState<HeaderSet>();
        }

        Builder<STATE | HasBodySet>& setHasBody(bool value)
        {
            static_assert(!(STATE & HasBodySet), "property hasBody should not be set yet");
            m_result->setBoolean("hasBody", value);
            return castState<HasBodySet>();
        }

        Builder<STATE | FormatterObjectIdSet>& setFormatterObjectId(const TypeBuilder::Runtime::RemoteObjectId& value)
        {
            static_assert(!(STATE & FormatterObjectIdSet), "property formatterObjectId should not be set yet");
            m_result->setString("formatterObjectId", value);
            return castState<FormatterObjectIdSet>();
        }

        operator RefPtr<CustomPreview>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CustomPreview) == sizeof(JSONObject), "CustomPreview should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CustomPreview>*>(&m_result);
        }

        PassRefPtr<CustomPreview> release()
        {
            return RefPtr<CustomPreview>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CustomPreview> result = CustomPreview::create()
     *     .setHeader(...)
     *     .setHasBody(...)
     *     .setFormatterObjectId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void header(String* value)
    {
        JSONObjectBase::getString("header", value);
    }

    void hasBody(bool* value)
    {
        JSONObjectBase::getBoolean("hasBody", value);
    }

    void formatterObjectId(TypeBuilder::Runtime::RemoteObjectId* value)
    {
        JSONObjectBase::getString("formatterObjectId", value);
    }

    void setConfigObjectId(const TypeBuilder::Runtime::RemoteObjectId& value)
    {
        this->setString("configObjectId", value);
    }
#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* Object containing abbreviated remote object value. */
class ObjectPreview : public JSONObjectBase {
public:
    // Named after property name 'type' while generating ObjectPreview.
    struct Type {
        enum Enum {
            Object = 14,
            Function = 15,
            Undefined = 16,
            String = 17,
            Number = 18,
            Boolean = 19,
            Symbol = 20,
        };
#if ENABLE(ASSERT)
        static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
    }; // struct Type

    // Named after property name 'subtype' while generating ObjectPreview.
    struct Subtype {
        enum Enum {
            Array = 21,
            Null = 22,
            Node = 23,
            Regexp = 24,
            Date = 25,
            Map = 26,
            Set = 27,
            Iterator = 28,
            Generator = 29,
            Error = 30,
        };
#if ENABLE(ASSERT)
        static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
    }; // struct Subtype

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        LosslessSet = 1 << 1,
        OverflowSet = 1 << 2,
        PropertiesSet = 1 << 3,
        AllFieldsSet = (TypeSet | LosslessSet | OverflowSet | PropertiesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ObjectPreview*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ObjectPreview;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | LosslessSet>& setLossless(bool value)
        {
            static_assert(!(STATE & LosslessSet), "property lossless should not be set yet");
            m_result->setBoolean("lossless", value);
            return castState<LosslessSet>();
        }

        Builder<STATE | OverflowSet>& setOverflow(bool value)
        {
            static_assert(!(STATE & OverflowSet), "property overflow should not be set yet");
            m_result->setBoolean("overflow", value);
            return castState<OverflowSet>();
        }

        Builder<STATE | PropertiesSet>& setProperties(PassRefPtr<TypeBuilder::Array<TypeBuilder::Runtime::PropertyPreview> > value)
        {
            static_assert(!(STATE & PropertiesSet), "property properties should not be set yet");
            m_result->setValue("properties", value);
            return castState<PropertiesSet>();
        }

        operator RefPtr<ObjectPreview>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ObjectPreview) == sizeof(JSONObject), "ObjectPreview should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ObjectPreview>*>(&m_result);
        }

        PassRefPtr<ObjectPreview> release()
        {
            return RefPtr<ObjectPreview>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ObjectPreview> result = ObjectPreview::create()
     *     .setType(...)
     *     .setLossless(...)
     *     .setOverflow(...)
     *     .setProperties(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void lossless(bool* value)
    {
        JSONObjectBase::getBoolean("lossless", value);
    }

    void overflow(bool* value)
    {
        JSONObjectBase::getBoolean("overflow", value);
    }

    void setSubtype(Subtype::Enum value)
    {
        this->setString("subtype", TypeBuilder::getEnumConstantValue(value));
    }

    void setDescription(const String& value)
    {
        this->setString("description", value);
    }

    void setEntries(PassRefPtr<TypeBuilder::Array<TypeBuilder::Runtime::EntryPreview> > value)
    {
        this->setValue("entries", value);
    }
#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

class PropertyPreview : public JSONObjectBase {
public:
    // Named after property name 'type' while generating PropertyPreview.
    struct Type {
        enum Enum {
            Object = 14,
            Function = 15,
            Undefined = 16,
            String = 17,
            Number = 18,
            Boolean = 19,
            Symbol = 20,
            Accessor = 31,
        };
#if ENABLE(ASSERT)
        static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
    }; // struct Type

    // Named after property name 'subtype' while generating PropertyPreview.
    struct Subtype {
        enum Enum {
            Array = 21,
            Null = 22,
            Node = 23,
            Regexp = 24,
            Date = 25,
            Map = 26,
            Set = 27,
            Iterator = 28,
            Generator = 29,
            Error = 30,
        };
#if ENABLE(ASSERT)
        static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
    }; // struct Subtype

    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        TypeSet = 1 << 1,
        AllFieldsSet = (NameSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PropertyPreview*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class PropertyPreview;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<PropertyPreview>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(PropertyPreview) == sizeof(JSONObject), "PropertyPreview should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<PropertyPreview>*>(&m_result);
        }

        PassRefPtr<PropertyPreview> release()
        {
            return RefPtr<PropertyPreview>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PropertyPreview> result = PropertyPreview::create()
     *     .setName(...)
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void setValue(const String& value)
    {
        this->setString("value", value);
    }
    using JSONObjectBase::setValue;


    void setValuePreview(PassRefPtr<TypeBuilder::Runtime::ObjectPreview> value)
    {
        this->setValue("valuePreview", value);
    }

    void setSubtype(Subtype::Enum value)
    {
        this->setString("subtype", TypeBuilder::getEnumConstantValue(value));
    }
#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

class EntryPreview : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ValueSet = 1 << 0,
        AllFieldsSet = (ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*EntryPreview*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class EntryPreview;
    public:

        Builder<STATE | ValueSet>& setValue(PassRefPtr<TypeBuilder::Runtime::ObjectPreview> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<EntryPreview>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(EntryPreview) == sizeof(JSONObject), "EntryPreview should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<EntryPreview>*>(&m_result);
        }

        PassRefPtr<EntryPreview> release()
        {
            return RefPtr<EntryPreview>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<EntryPreview> result = EntryPreview::create()
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setKey(PassRefPtr<TypeBuilder::Runtime::ObjectPreview> value)
    {
        this->setValue("key", value);
    }
#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* Object property descriptor. */
class PropertyDescriptor : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ConfigurableSet = 1 << 1,
        EnumerableSet = 1 << 2,
        AllFieldsSet = (NameSet | ConfigurableSet | EnumerableSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PropertyDescriptor*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class PropertyDescriptor;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ConfigurableSet>& setConfigurable(bool value)
        {
            static_assert(!(STATE & ConfigurableSet), "property configurable should not be set yet");
            m_result->setBoolean("configurable", value);
            return castState<ConfigurableSet>();
        }

        Builder<STATE | EnumerableSet>& setEnumerable(bool value)
        {
            static_assert(!(STATE & EnumerableSet), "property enumerable should not be set yet");
            m_result->setBoolean("enumerable", value);
            return castState<EnumerableSet>();
        }

        operator RefPtr<PropertyDescriptor>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(PropertyDescriptor) == sizeof(JSONObject), "PropertyDescriptor should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<PropertyDescriptor>*>(&m_result);
        }

        PassRefPtr<PropertyDescriptor> release()
        {
            return RefPtr<PropertyDescriptor>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PropertyDescriptor> result = PropertyDescriptor::create()
     *     .setName(...)
     *     .setConfigurable(...)
     *     .setEnumerable(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void configurable(bool* value)
    {
        JSONObjectBase::getBoolean("configurable", value);
    }

    void enumerable(bool* value)
    {
        JSONObjectBase::getBoolean("enumerable", value);
    }

    void setValue(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue("value", value);
    }
    using JSONObjectBase::setValue;


    void setWritable(bool value)
    {
        this->setBoolean("writable", value);
    }

    void setGet(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue("get", value);
    }

    void setSet(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue("set", value);
    }

    void setWasThrown(bool value)
    {
        this->setBoolean("wasThrown", value);
    }

    void setIsOwn(bool value)
    {
        this->setBoolean("isOwn", value);
    }

    void setSymbol(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue("symbol", value);
    }
    static PassRefPtr<PropertyDescriptor> runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(object.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(PropertyDescriptor) == sizeof(JSONObjectBase), "PropertyDescriptor should be the same size as JSONObjectBase");
        return static_cast<PropertyDescriptor*>(static_cast<JSONObjectBase*>(object.get()));
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* Object internal property descriptor. This property isn't normally visible in JavaScript code. */
class InternalPropertyDescriptor : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        AllFieldsSet = (NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*InternalPropertyDescriptor*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class InternalPropertyDescriptor;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        operator RefPtr<InternalPropertyDescriptor>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(InternalPropertyDescriptor) == sizeof(JSONObject), "InternalPropertyDescriptor should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<InternalPropertyDescriptor>*>(&m_result);
        }

        PassRefPtr<InternalPropertyDescriptor> release()
        {
            return RefPtr<InternalPropertyDescriptor>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<InternalPropertyDescriptor> result = InternalPropertyDescriptor::create()
     *     .setName(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void setValue(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue("value", value);
    }
    using JSONObjectBase::setValue;

    static PassRefPtr<InternalPropertyDescriptor> runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(object.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(InternalPropertyDescriptor) == sizeof(JSONObjectBase), "InternalPropertyDescriptor should be the same size as JSONObjectBase");
        return static_cast<InternalPropertyDescriptor*>(static_cast<JSONObjectBase*>(object.get()));
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* Represents function call argument. Either remote object id <code>objectId</code> or primitive <code>value</code> or neither of (for undefined) them should be specified. */
class CallArgument : public JSONObjectBase {
public:
    // Named after property name 'type' while generating CallArgument.
    struct Type {
        enum Enum {
            Object = 14,
            Function = 15,
            Undefined = 16,
            String = 17,
            Number = 18,
            Boolean = 19,
            Symbol = 20,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CallArgument*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CallArgument;
    public:

        operator RefPtr<CallArgument>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CallArgument) == sizeof(JSONObject), "CallArgument should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CallArgument>*>(&m_result);
        }

        PassRefPtr<CallArgument> release()
        {
            return RefPtr<CallArgument>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallArgument> result = CallArgument::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setValue(PassRefPtr<JSONValue> value)
    {
        this->setValue("value", value);
    }
    using JSONObjectBase::setValue;


    void setObjectId(const TypeBuilder::Runtime::RemoteObjectId& value)
    {
        this->setString("objectId", value);
    }

    void setType(Type::Enum value)
    {
        this->setString("type", TypeBuilder::getEnumConstantValue(value));
    }
};

/* Description of an isolated world. */
class ExecutionContextDescription : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        OriginSet = 1 << 1,
        NameSet = 1 << 2,
        FrameIdSet = 1 << 3,
        AllFieldsSet = (IdSet | OriginSet | NameSet | FrameIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ExecutionContextDescription*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ExecutionContextDescription;
    public:

        Builder<STATE | IdSet>& setId(int value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setNumber("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(const String& value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->setString("origin", value);
            return castState<OriginSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const String& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setString("frameId", value);
            return castState<FrameIdSet>();
        }

        operator RefPtr<ExecutionContextDescription>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ExecutionContextDescription) == sizeof(JSONObject), "ExecutionContextDescription should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ExecutionContextDescription>*>(&m_result);
        }

        PassRefPtr<ExecutionContextDescription> release()
        {
            return RefPtr<ExecutionContextDescription>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ExecutionContextDescription> result = ExecutionContextDescription::create()
     *     .setId(...)
     *     .setOrigin(...)
     *     .setName(...)
     *     .setFrameId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void id(int* value)
    {
        JSONObjectBase::getNumber("id", value);
    }

    void origin(String* value)
    {
        JSONObjectBase::getString("origin", value);
    }

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void frameId(String* value)
    {
        JSONObjectBase::getString("frameId", value);
    }

    void setType(const String& value)
    {
        this->setString("type", value);
    }
};

} // Runtime

namespace Console {
/* Console message. */
class ConsoleMessage : public JSONObjectBase {
public:
    // Named after property name 'source' while generating ConsoleMessage.
    struct Source {
        enum Enum {
            Xml = 32,
            Javascript = 33,
            Network = 34,
            Console_api = 35,
            Storage = 36,
            Appcache = 37,
            Rendering = 38,
            Security = 39,
            Other = 40,
            Deprecation = 41,
        };
    }; // struct Source

    // Named after property name 'level' while generating ConsoleMessage.
    struct Level {
        enum Enum {
            Log = 42,
            Warning = 43,
            Error = 30,
            Debug = 44,
            Info = 45,
            RevokedError = 46,
        };
    }; // struct Level

    // Named after property name 'type' while generating ConsoleMessage.
    struct Type {
        enum Enum {
            Log = 42,
            Dir = 47,
            Dirxml = 48,
            Table = 49,
            Trace = 50,
            Clear = 51,
            StartGroup = 52,
            StartGroupCollapsed = 53,
            EndGroup = 54,
            Assert = 55,
            Profile = 56,
            ProfileEnd = 57,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        SourceSet = 1 << 0,
        LevelSet = 1 << 1,
        TextSet = 1 << 2,
        TimestampSet = 1 << 3,
        AllFieldsSet = (SourceSet | LevelSet | TextSet | TimestampSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ConsoleMessage*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ConsoleMessage;
    public:

        Builder<STATE | SourceSet>& setSource(Source::Enum value)
        {
            static_assert(!(STATE & SourceSet), "property source should not be set yet");
            m_result->setString("source", TypeBuilder::getEnumConstantValue(value));
            return castState<SourceSet>();
        }

        Builder<STATE | LevelSet>& setLevel(Level::Enum value)
        {
            static_assert(!(STATE & LevelSet), "property level should not be set yet");
            m_result->setString("level", TypeBuilder::getEnumConstantValue(value));
            return castState<LevelSet>();
        }

        Builder<STATE | TextSet>& setText(const String& value)
        {
            static_assert(!(STATE & TextSet), "property text should not be set yet");
            m_result->setString("text", value);
            return castState<TextSet>();
        }

        Builder<STATE | TimestampSet>& setTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->setNumber("timestamp", value);
            return castState<TimestampSet>();
        }

        operator RefPtr<ConsoleMessage>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ConsoleMessage) == sizeof(JSONObject), "ConsoleMessage should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ConsoleMessage>*>(&m_result);
        }

        PassRefPtr<ConsoleMessage> release()
        {
            return RefPtr<ConsoleMessage>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ConsoleMessage> result = ConsoleMessage::create()
     *     .setSource(...)
     *     .setLevel(...)
     *     .setText(...)
     *     .setTimestamp(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void text(String* value)
    {
        JSONObjectBase::getString("text", value);
    }

    void timestamp(double* value)
    {
        JSONObjectBase::getNumber("timestamp", value);
    }

    void setType(Type::Enum value)
    {
        this->setString("type", TypeBuilder::getEnumConstantValue(value));
    }

    void setScriptId(const String& value)
    {
        this->setString("scriptId", value);
    }

    void setUrl(const String& value)
    {
        this->setString("url", value);
    }

    void setLine(int value)
    {
        this->setNumber("line", value);
    }

    void setColumn(int value)
    {
        this->setNumber("column", value);
    }

    void setRepeatCount(int value)
    {
        this->setNumber("repeatCount", value);
    }

    void setParameters(PassRefPtr<TypeBuilder::Array<TypeBuilder::Runtime::RemoteObject> > value)
    {
        this->setValue("parameters", value);
    }

    void setStackTrace(PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue("stackTrace", value);
    }

    void setAsyncStackTrace(PassRefPtr<TypeBuilder::Console::AsyncStackTrace> value)
    {
        this->setValue("asyncStackTrace", value);
    }

    void setNetworkRequestId(const TypeBuilder::Network::RequestId& value)
    {
        this->setString("networkRequestId", value);
    }

    void setExecutionContextId(int value)
    {
        this->setNumber("executionContextId", value);
    }

    void setMessageId(int value)
    {
        this->setNumber("messageId", value);
    }

    void setRelatedMessageId(int value)
    {
        this->setNumber("relatedMessageId", value);
    }
};

/* Stack entry for console errors and assertions. */
class CallFrame : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FunctionNameSet = 1 << 0,
        ScriptIdSet = 1 << 1,
        UrlSet = 1 << 2,
        LineNumberSet = 1 << 3,
        ColumnNumberSet = 1 << 4,
        AllFieldsSet = (FunctionNameSet | ScriptIdSet | UrlSet | LineNumberSet | ColumnNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CallFrame*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CallFrame;
    public:

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            static_assert(!(STATE & FunctionNameSet), "property functionName should not be set yet");
            m_result->setString("functionName", value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | ScriptIdSet>& setScriptId(const String& value)
        {
            static_assert(!(STATE & ScriptIdSet), "property scriptId should not be set yet");
            m_result->setString("scriptId", value);
            return castState<ScriptIdSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(int value)
        {
            static_assert(!(STATE & ColumnNumberSet), "property columnNumber should not be set yet");
            m_result->setNumber("columnNumber", value);
            return castState<ColumnNumberSet>();
        }

        operator RefPtr<CallFrame>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CallFrame) == sizeof(JSONObject), "CallFrame should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CallFrame>*>(&m_result);
        }

        PassRefPtr<CallFrame> release()
        {
            return RefPtr<CallFrame>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallFrame> result = CallFrame::create()
     *     .setFunctionName(...)
     *     .setScriptId(...)
     *     .setUrl(...)
     *     .setLineNumber(...)
     *     .setColumnNumber(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void functionName(String* value)
    {
        JSONObjectBase::getString("functionName", value);
    }

    void scriptId(String* value)
    {
        JSONObjectBase::getString("scriptId", value);
    }

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void lineNumber(int* value)
    {
        JSONObjectBase::getNumber("lineNumber", value);
    }

    void columnNumber(int* value)
    {
        JSONObjectBase::getNumber("columnNumber", value);
    }
};

/* Asynchronous JavaScript call stack. */
class AsyncStackTrace : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CallFramesSet = 1 << 0,
        AllFieldsSet = (CallFramesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*AsyncStackTrace*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class AsyncStackTrace;
    public:

        Builder<STATE | CallFramesSet>& setCallFrames(PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> > value)
        {
            static_assert(!(STATE & CallFramesSet), "property callFrames should not be set yet");
            m_result->setValue("callFrames", value);
            return castState<CallFramesSet>();
        }

        operator RefPtr<AsyncStackTrace>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(AsyncStackTrace) == sizeof(JSONObject), "AsyncStackTrace should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<AsyncStackTrace>*>(&m_result);
        }

        PassRefPtr<AsyncStackTrace> release()
        {
            return RefPtr<AsyncStackTrace>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<AsyncStackTrace> result = AsyncStackTrace::create()
     *     .setCallFrames(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setDescription(const String& value)
    {
        this->setString("description", value);
    }

    void setAsyncStackTrace(PassRefPtr<TypeBuilder::Console::AsyncStackTrace> value)
    {
        this->setValue("asyncStackTrace", value);
    }
};

} // Console

namespace Network {
/* Timing information for the request. */
class ResourceTiming : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RequestTimeSet = 1 << 0,
        ProxyStartSet = 1 << 1,
        ProxyEndSet = 1 << 2,
        DnsStartSet = 1 << 3,
        DnsEndSet = 1 << 4,
        ConnectStartSet = 1 << 5,
        ConnectEndSet = 1 << 6,
        SslStartSet = 1 << 7,
        SslEndSet = 1 << 8,
        WorkerStartSet = 1 << 9,
        WorkerReadySet = 1 << 10,
        SendStartSet = 1 << 11,
        SendEndSet = 1 << 12,
        ReceiveHeadersEndSet = 1 << 13,
        AllFieldsSet = (RequestTimeSet | ProxyStartSet | ProxyEndSet | DnsStartSet | DnsEndSet | ConnectStartSet | ConnectEndSet | SslStartSet | SslEndSet | WorkerStartSet | WorkerReadySet | SendStartSet | SendEndSet | ReceiveHeadersEndSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ResourceTiming*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ResourceTiming;
    public:

        Builder<STATE | RequestTimeSet>& setRequestTime(double value)
        {
            static_assert(!(STATE & RequestTimeSet), "property requestTime should not be set yet");
            m_result->setNumber("requestTime", value);
            return castState<RequestTimeSet>();
        }

        Builder<STATE | ProxyStartSet>& setProxyStart(double value)
        {
            static_assert(!(STATE & ProxyStartSet), "property proxyStart should not be set yet");
            m_result->setNumber("proxyStart", value);
            return castState<ProxyStartSet>();
        }

        Builder<STATE | ProxyEndSet>& setProxyEnd(double value)
        {
            static_assert(!(STATE & ProxyEndSet), "property proxyEnd should not be set yet");
            m_result->setNumber("proxyEnd", value);
            return castState<ProxyEndSet>();
        }

        Builder<STATE | DnsStartSet>& setDnsStart(double value)
        {
            static_assert(!(STATE & DnsStartSet), "property dnsStart should not be set yet");
            m_result->setNumber("dnsStart", value);
            return castState<DnsStartSet>();
        }

        Builder<STATE | DnsEndSet>& setDnsEnd(double value)
        {
            static_assert(!(STATE & DnsEndSet), "property dnsEnd should not be set yet");
            m_result->setNumber("dnsEnd", value);
            return castState<DnsEndSet>();
        }

        Builder<STATE | ConnectStartSet>& setConnectStart(double value)
        {
            static_assert(!(STATE & ConnectStartSet), "property connectStart should not be set yet");
            m_result->setNumber("connectStart", value);
            return castState<ConnectStartSet>();
        }

        Builder<STATE | ConnectEndSet>& setConnectEnd(double value)
        {
            static_assert(!(STATE & ConnectEndSet), "property connectEnd should not be set yet");
            m_result->setNumber("connectEnd", value);
            return castState<ConnectEndSet>();
        }

        Builder<STATE | SslStartSet>& setSslStart(double value)
        {
            static_assert(!(STATE & SslStartSet), "property sslStart should not be set yet");
            m_result->setNumber("sslStart", value);
            return castState<SslStartSet>();
        }

        Builder<STATE | SslEndSet>& setSslEnd(double value)
        {
            static_assert(!(STATE & SslEndSet), "property sslEnd should not be set yet");
            m_result->setNumber("sslEnd", value);
            return castState<SslEndSet>();
        }

        Builder<STATE | WorkerStartSet>& setWorkerStart(double value)
        {
            static_assert(!(STATE & WorkerStartSet), "property workerStart should not be set yet");
            m_result->setNumber("workerStart", value);
            return castState<WorkerStartSet>();
        }

        Builder<STATE | WorkerReadySet>& setWorkerReady(double value)
        {
            static_assert(!(STATE & WorkerReadySet), "property workerReady should not be set yet");
            m_result->setNumber("workerReady", value);
            return castState<WorkerReadySet>();
        }

        Builder<STATE | SendStartSet>& setSendStart(double value)
        {
            static_assert(!(STATE & SendStartSet), "property sendStart should not be set yet");
            m_result->setNumber("sendStart", value);
            return castState<SendStartSet>();
        }

        Builder<STATE | SendEndSet>& setSendEnd(double value)
        {
            static_assert(!(STATE & SendEndSet), "property sendEnd should not be set yet");
            m_result->setNumber("sendEnd", value);
            return castState<SendEndSet>();
        }

        Builder<STATE | ReceiveHeadersEndSet>& setReceiveHeadersEnd(double value)
        {
            static_assert(!(STATE & ReceiveHeadersEndSet), "property receiveHeadersEnd should not be set yet");
            m_result->setNumber("receiveHeadersEnd", value);
            return castState<ReceiveHeadersEndSet>();
        }

        operator RefPtr<ResourceTiming>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ResourceTiming) == sizeof(JSONObject), "ResourceTiming should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ResourceTiming>*>(&m_result);
        }

        PassRefPtr<ResourceTiming> release()
        {
            return RefPtr<ResourceTiming>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ResourceTiming> result = ResourceTiming::create()
     *     .setRequestTime(...)
     *     .setProxyStart(...)
     *     .setProxyEnd(...)
     *     .setDnsStart(...)
     *     .setDnsEnd(...)
     *     .setConnectStart(...)
     *     .setConnectEnd(...)
     *     .setSslStart(...)
     *     .setSslEnd(...)
     *     .setWorkerStart(...)
     *     .setWorkerReady(...)
     *     .setSendStart(...)
     *     .setSendEnd(...)
     *     .setReceiveHeadersEnd(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void requestTime(double* value)
    {
        JSONObjectBase::getNumber("requestTime", value);
    }

    void proxyStart(double* value)
    {
        JSONObjectBase::getNumber("proxyStart", value);
    }

    void proxyEnd(double* value)
    {
        JSONObjectBase::getNumber("proxyEnd", value);
    }

    void dnsStart(double* value)
    {
        JSONObjectBase::getNumber("dnsStart", value);
    }

    void dnsEnd(double* value)
    {
        JSONObjectBase::getNumber("dnsEnd", value);
    }

    void connectStart(double* value)
    {
        JSONObjectBase::getNumber("connectStart", value);
    }

    void connectEnd(double* value)
    {
        JSONObjectBase::getNumber("connectEnd", value);
    }

    void sslStart(double* value)
    {
        JSONObjectBase::getNumber("sslStart", value);
    }

    void sslEnd(double* value)
    {
        JSONObjectBase::getNumber("sslEnd", value);
    }

    void workerStart(double* value)
    {
        JSONObjectBase::getNumber("workerStart", value);
    }

    void workerReady(double* value)
    {
        JSONObjectBase::getNumber("workerReady", value);
    }

    void sendStart(double* value)
    {
        JSONObjectBase::getNumber("sendStart", value);
    }

    void sendEnd(double* value)
    {
        JSONObjectBase::getNumber("sendEnd", value);
    }

    void receiveHeadersEnd(double* value)
    {
        JSONObjectBase::getNumber("receiveHeadersEnd", value);
    }
};

/* HTTP request data. */
class Request : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        MethodSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (UrlSet | MethodSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Request*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Request;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | MethodSet>& setMethod(const String& value)
        {
            static_assert(!(STATE & MethodSet), "property method should not be set yet");
            m_result->setString("method", value);
            return castState<MethodSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<JSONObject> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setValue("headers", value);
            return castState<HeadersSet>();
        }

        operator RefPtr<Request>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Request) == sizeof(JSONObject), "Request should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Request>*>(&m_result);
        }

        PassRefPtr<Request> release()
        {
            return RefPtr<Request>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Request> result = Request::create()
     *     .setUrl(...)
     *     .setMethod(...)
     *     .setHeaders(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void method(String* value)
    {
        JSONObjectBase::getString("method", value);
    }

    void setPostData(const String& value)
    {
        this->setString("postData", value);
    }
};

/* HTTP response data. */
class Response : public JSONObject {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        StatusSet = 1 << 1,
        StatusTextSet = 1 << 2,
        HeadersSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        ConnectionReusedSet = 1 << 5,
        ConnectionIdSet = 1 << 6,
        EncodedDataLengthSet = 1 << 7,
        AllFieldsSet = (UrlSet | StatusSet | StatusTextSet | HeadersSet | MimeTypeSet | ConnectionReusedSet | ConnectionIdSet | EncodedDataLengthSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Response*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Response;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | StatusSet>& setStatus(double value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setNumber("status", value);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            static_assert(!(STATE & StatusTextSet), "property statusText should not be set yet");
            m_result->setString("statusText", value);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<JSONObject> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setValue("headers", value);
            return castState<HeadersSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            static_assert(!(STATE & MimeTypeSet), "property mimeType should not be set yet");
            m_result->setString("mimeType", value);
            return castState<MimeTypeSet>();
        }

        Builder<STATE | ConnectionReusedSet>& setConnectionReused(bool value)
        {
            static_assert(!(STATE & ConnectionReusedSet), "property connectionReused should not be set yet");
            m_result->setBoolean("connectionReused", value);
            return castState<ConnectionReusedSet>();
        }

        Builder<STATE | ConnectionIdSet>& setConnectionId(double value)
        {
            static_assert(!(STATE & ConnectionIdSet), "property connectionId should not be set yet");
            m_result->setNumber("connectionId", value);
            return castState<ConnectionIdSet>();
        }

        Builder<STATE | EncodedDataLengthSet>& setEncodedDataLength(double value)
        {
            static_assert(!(STATE & EncodedDataLengthSet), "property encodedDataLength should not be set yet");
            m_result->setNumber("encodedDataLength", value);
            return castState<EncodedDataLengthSet>();
        }

        operator RefPtr<Response>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Response) == sizeof(JSONObject), "Response should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Response>*>(&m_result);
        }

        PassRefPtr<Response> release()
        {
            return RefPtr<Response>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Response> result = Response::create()
     *     .setUrl(...)
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .setMimeType(...)
     *     .setConnectionReused(...)
     *     .setConnectionId(...)
     *     .setEncodedDataLength(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void status(double* value)
    {
        JSONObjectBase::getNumber("status", value);
    }

    void statusText(String* value)
    {
        JSONObjectBase::getString("statusText", value);
    }

    void mimeType(String* value)
    {
        JSONObjectBase::getString("mimeType", value);
    }

    void connectionReused(bool* value)
    {
        JSONObjectBase::getBoolean("connectionReused", value);
    }

    void connectionId(double* value)
    {
        JSONObjectBase::getNumber("connectionId", value);
    }

    void encodedDataLength(double* value)
    {
        JSONObjectBase::getNumber("encodedDataLength", value);
    }

    void setHeadersText(const String& value)
    {
        this->setString("headersText", value);
    }

    void setRequestHeaders(PassRefPtr<JSONObject> value)
    {
        this->setValue("requestHeaders", value);
    }

    void setRequestHeadersText(const String& value)
    {
        this->setString("requestHeadersText", value);
    }

    void setRemoteIPAddress(const String& value)
    {
        this->setString("remoteIPAddress", value);
    }

    void setRemotePort(int value)
    {
        this->setNumber("remotePort", value);
    }

    void setFromDiskCache(bool value)
    {
        this->setBoolean("fromDiskCache", value);
    }

    void setFromServiceWorker(bool value)
    {
        this->setBoolean("fromServiceWorker", value);
    }

    void setTiming(PassRefPtr<TypeBuilder::Network::ResourceTiming> value)
    {
        this->setValue("timing", value);
    }

    void setProtocol(const String& value)
    {
        this->setString("protocol", value);
    }

    // Property names for type generated as open.
    static const char Url[];
    static const char Status[];
    static const char StatusText[];
    static const char Headers[];
    static const char MimeType[];
    static const char ConnectionReused[];
    static const char ConnectionId[];
    static const char EncodedDataLength[];
    static const char HeadersText[];
    static const char RequestHeaders[];
    static const char RequestHeadersText[];
    static const char RemoteIPAddress[];
    static const char RemotePort[];
    static const char FromDiskCache[];
    static const char FromServiceWorker[];
    static const char Timing[];
    static const char Protocol[];
};

/* WebSocket request data. */
class WebSocketRequest : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        HeadersSet = 1 << 0,
        AllFieldsSet = (HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*WebSocketRequest*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class WebSocketRequest;
    public:

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<JSONObject> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setValue("headers", value);
            return castState<HeadersSet>();
        }

        operator RefPtr<WebSocketRequest>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(WebSocketRequest) == sizeof(JSONObject), "WebSocketRequest should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<WebSocketRequest>*>(&m_result);
        }

        PassRefPtr<WebSocketRequest> release()
        {
            return RefPtr<WebSocketRequest>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketRequest> result = WebSocketRequest::create()
     *     .setHeaders(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* WebSocket response data. */
class WebSocketResponse : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StatusSet = 1 << 0,
        StatusTextSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (StatusSet | StatusTextSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*WebSocketResponse*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class WebSocketResponse;
    public:

        Builder<STATE | StatusSet>& setStatus(double value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setNumber("status", value);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            static_assert(!(STATE & StatusTextSet), "property statusText should not be set yet");
            m_result->setString("statusText", value);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<JSONObject> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setValue("headers", value);
            return castState<HeadersSet>();
        }

        operator RefPtr<WebSocketResponse>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(WebSocketResponse) == sizeof(JSONObject), "WebSocketResponse should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<WebSocketResponse>*>(&m_result);
        }

        PassRefPtr<WebSocketResponse> release()
        {
            return RefPtr<WebSocketResponse>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketResponse> result = WebSocketResponse::create()
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void status(double* value)
    {
        JSONObjectBase::getNumber("status", value);
    }

    void statusText(String* value)
    {
        JSONObjectBase::getString("statusText", value);
    }

    void setHeadersText(const String& value)
    {
        this->setString("headersText", value);
    }

    void setRequestHeaders(PassRefPtr<JSONObject> value)
    {
        this->setValue("requestHeaders", value);
    }

    void setRequestHeadersText(const String& value)
    {
        this->setString("requestHeadersText", value);
    }
};

/* WebSocket frame data. */
class WebSocketFrame : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        OpcodeSet = 1 << 0,
        MaskSet = 1 << 1,
        PayloadDataSet = 1 << 2,
        AllFieldsSet = (OpcodeSet | MaskSet | PayloadDataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*WebSocketFrame*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class WebSocketFrame;
    public:

        Builder<STATE | OpcodeSet>& setOpcode(double value)
        {
            static_assert(!(STATE & OpcodeSet), "property opcode should not be set yet");
            m_result->setNumber("opcode", value);
            return castState<OpcodeSet>();
        }

        Builder<STATE | MaskSet>& setMask(bool value)
        {
            static_assert(!(STATE & MaskSet), "property mask should not be set yet");
            m_result->setBoolean("mask", value);
            return castState<MaskSet>();
        }

        Builder<STATE | PayloadDataSet>& setPayloadData(const String& value)
        {
            static_assert(!(STATE & PayloadDataSet), "property payloadData should not be set yet");
            m_result->setString("payloadData", value);
            return castState<PayloadDataSet>();
        }

        operator RefPtr<WebSocketFrame>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(WebSocketFrame) == sizeof(JSONObject), "WebSocketFrame should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<WebSocketFrame>*>(&m_result);
        }

        PassRefPtr<WebSocketFrame> release()
        {
            return RefPtr<WebSocketFrame>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketFrame> result = WebSocketFrame::create()
     *     .setOpcode(...)
     *     .setMask(...)
     *     .setPayloadData(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void opcode(double* value)
    {
        JSONObjectBase::getNumber("opcode", value);
    }

    void mask(bool* value)
    {
        JSONObjectBase::getBoolean("mask", value);
    }

    void payloadData(String* value)
    {
        JSONObjectBase::getString("payloadData", value);
    }
};

/* Information about the cached resource. */
class CachedResource : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        TypeSet = 1 << 1,
        BodySizeSet = 1 << 2,
        AllFieldsSet = (UrlSet | TypeSet | BodySizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CachedResource*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CachedResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | TypeSet>& setType(TypeBuilder::Page::ResourceType::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | BodySizeSet>& setBodySize(double value)
        {
            static_assert(!(STATE & BodySizeSet), "property bodySize should not be set yet");
            m_result->setNumber("bodySize", value);
            return castState<BodySizeSet>();
        }

        operator RefPtr<CachedResource>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CachedResource) == sizeof(JSONObject), "CachedResource should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CachedResource>*>(&m_result);
        }

        PassRefPtr<CachedResource> release()
        {
            return RefPtr<CachedResource>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CachedResource> result = CachedResource::create()
     *     .setUrl(...)
     *     .setType(...)
     *     .setBodySize(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void bodySize(double* value)
    {
        JSONObjectBase::getNumber("bodySize", value);
    }

    void setResponse(PassRefPtr<TypeBuilder::Network::Response> value)
    {
        this->setValue("response", value);
    }
};

/* Information about the request initiator. */
class Initiator : public JSONObjectBase {
public:
    // Named after property name 'type' while generating Initiator.
    struct Type {
        enum Enum {
            Parser = 58,
            Script = 59,
            Other = 40,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Initiator*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Initiator;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<Initiator>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Initiator) == sizeof(JSONObject), "Initiator should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Initiator>*>(&m_result);
        }

        PassRefPtr<Initiator> release()
        {
            return RefPtr<Initiator>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Initiator> result = Initiator::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setStackTrace(PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue("stackTrace", value);
    }

    void setUrl(const String& value)
    {
        this->setString("url", value);
    }

    void setLineNumber(double value)
    {
        this->setNumber("lineNumber", value);
    }

    void setAsyncStackTrace(PassRefPtr<TypeBuilder::Console::AsyncStackTrace> value)
    {
        this->setValue("asyncStackTrace", value);
    }
};

/* Cookie object */
class Cookie : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        DomainSet = 1 << 2,
        PathSet = 1 << 3,
        ExpiresSet = 1 << 4,
        SizeSet = 1 << 5,
        HttpOnlySet = 1 << 6,
        SecureSet = 1 << 7,
        SessionSet = 1 << 8,
        AllFieldsSet = (NameSet | ValueSet | DomainSet | PathSet | ExpiresSet | SizeSet | HttpOnlySet | SecureSet | SessionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Cookie*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Cookie;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            static_assert(!(STATE & DomainSet), "property domain should not be set yet");
            m_result->setString("domain", value);
            return castState<DomainSet>();
        }

        Builder<STATE | PathSet>& setPath(const String& value)
        {
            static_assert(!(STATE & PathSet), "property path should not be set yet");
            m_result->setString("path", value);
            return castState<PathSet>();
        }

        Builder<STATE | ExpiresSet>& setExpires(double value)
        {
            static_assert(!(STATE & ExpiresSet), "property expires should not be set yet");
            m_result->setNumber("expires", value);
            return castState<ExpiresSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            static_assert(!(STATE & SizeSet), "property size should not be set yet");
            m_result->setNumber("size", value);
            return castState<SizeSet>();
        }

        Builder<STATE | HttpOnlySet>& setHttpOnly(bool value)
        {
            static_assert(!(STATE & HttpOnlySet), "property httpOnly should not be set yet");
            m_result->setBoolean("httpOnly", value);
            return castState<HttpOnlySet>();
        }

        Builder<STATE | SecureSet>& setSecure(bool value)
        {
            static_assert(!(STATE & SecureSet), "property secure should not be set yet");
            m_result->setBoolean("secure", value);
            return castState<SecureSet>();
        }

        Builder<STATE | SessionSet>& setSession(bool value)
        {
            static_assert(!(STATE & SessionSet), "property session should not be set yet");
            m_result->setBoolean("session", value);
            return castState<SessionSet>();
        }

        operator RefPtr<Cookie>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Cookie) == sizeof(JSONObject), "Cookie should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Cookie>*>(&m_result);
        }

        PassRefPtr<Cookie> release()
        {
            return RefPtr<Cookie>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Cookie> result = Cookie::create()
     *     .setName(...)
     *     .setValue(...)
     *     .setDomain(...)
     *     .setPath(...)
     *     .setExpires(...)
     *     .setSize(...)
     *     .setHttpOnly(...)
     *     .setSecure(...)
     *     .setSession(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void value(String* value)
    {
        JSONObjectBase::getString("value", value);
    }

    void domain(String* value)
    {
        JSONObjectBase::getString("domain", value);
    }

    void path(String* value)
    {
        JSONObjectBase::getString("path", value);
    }

    void expires(double* value)
    {
        JSONObjectBase::getNumber("expires", value);
    }

    void size(int* value)
    {
        JSONObjectBase::getNumber("size", value);
    }

    void httpOnly(bool* value)
    {
        JSONObjectBase::getBoolean("httpOnly", value);
    }

    void secure(bool* value)
    {
        JSONObjectBase::getBoolean("secure", value);
    }

    void session(bool* value)
    {
        JSONObjectBase::getBoolean("session", value);
    }
};

} // Network

namespace Database {
/* Database object. */
class Database : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        DomainSet = 1 << 1,
        NameSet = 1 << 2,
        VersionSet = 1 << 3,
        AllFieldsSet = (IdSet | DomainSet | NameSet | VersionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Database*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Database;
    public:

        Builder<STATE | IdSet>& setId(const TypeBuilder::Database::DatabaseId& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setString("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            static_assert(!(STATE & DomainSet), "property domain should not be set yet");
            m_result->setString("domain", value);
            return castState<DomainSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(const String& value)
        {
            static_assert(!(STATE & VersionSet), "property version should not be set yet");
            m_result->setString("version", value);
            return castState<VersionSet>();
        }

        operator RefPtr<Database>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Database) == sizeof(JSONObject), "Database should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Database>*>(&m_result);
        }

        PassRefPtr<Database> release()
        {
            return RefPtr<Database>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Database> result = Database::create()
     *     .setId(...)
     *     .setDomain(...)
     *     .setName(...)
     *     .setVersion(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void id(TypeBuilder::Database::DatabaseId* value)
    {
        JSONObjectBase::getString("id", value);
    }

    void domain(String* value)
    {
        JSONObjectBase::getString("domain", value);
    }

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void version(String* value)
    {
        JSONObjectBase::getString("version", value);
    }
};

/* Database error. */
class Error : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MessageSet = 1 << 0,
        CodeSet = 1 << 1,
        AllFieldsSet = (MessageSet | CodeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Error*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Error;
    public:

        Builder<STATE | MessageSet>& setMessage(const String& value)
        {
            static_assert(!(STATE & MessageSet), "property message should not be set yet");
            m_result->setString("message", value);
            return castState<MessageSet>();
        }

        Builder<STATE | CodeSet>& setCode(int value)
        {
            static_assert(!(STATE & CodeSet), "property code should not be set yet");
            m_result->setNumber("code", value);
            return castState<CodeSet>();
        }

        operator RefPtr<Error>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Error) == sizeof(JSONObject), "Error should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Error>*>(&m_result);
        }

        PassRefPtr<Error> release()
        {
            return RefPtr<Error>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Error> result = Error::create()
     *     .setMessage(...)
     *     .setCode(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void message(String* value)
    {
        JSONObjectBase::getString("message", value);
    }

    void code(int* value)
    {
        JSONObjectBase::getNumber("code", value);
    }
};

} // Database

namespace IndexedDB {
/* Database with an array of object stores. */
class DatabaseWithObjectStores : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        VersionSet = 1 << 1,
        IntVersionSet = 1 << 2,
        ObjectStoresSet = 1 << 3,
        AllFieldsSet = (NameSet | VersionSet | IntVersionSet | ObjectStoresSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*DatabaseWithObjectStores*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class DatabaseWithObjectStores;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(const String& value)
        {
            static_assert(!(STATE & VersionSet), "property version should not be set yet");
            m_result->setString("version", value);
            return castState<VersionSet>();
        }

        Builder<STATE | IntVersionSet>& setIntVersion(int value)
        {
            static_assert(!(STATE & IntVersionSet), "property intVersion should not be set yet");
            m_result->setNumber("intVersion", value);
            return castState<IntVersionSet>();
        }

        Builder<STATE | ObjectStoresSet>& setObjectStores(PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::ObjectStore> > value)
        {
            static_assert(!(STATE & ObjectStoresSet), "property objectStores should not be set yet");
            m_result->setValue("objectStores", value);
            return castState<ObjectStoresSet>();
        }

        operator RefPtr<DatabaseWithObjectStores>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(DatabaseWithObjectStores) == sizeof(JSONObject), "DatabaseWithObjectStores should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<DatabaseWithObjectStores>*>(&m_result);
        }

        PassRefPtr<DatabaseWithObjectStores> release()
        {
            return RefPtr<DatabaseWithObjectStores>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DatabaseWithObjectStores> result = DatabaseWithObjectStores::create()
     *     .setName(...)
     *     .setVersion(...)
     *     .setIntVersion(...)
     *     .setObjectStores(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void version(String* value)
    {
        JSONObjectBase::getString("version", value);
    }

    void intVersion(int* value)
    {
        JSONObjectBase::getNumber("intVersion", value);
    }
};

/* Object store. */
class ObjectStore : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        AutoIncrementSet = 1 << 2,
        IndexesSet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | AutoIncrementSet | IndexesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ObjectStore*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ObjectStore;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(PassRefPtr<TypeBuilder::IndexedDB::KeyPath> value)
        {
            static_assert(!(STATE & KeyPathSet), "property keyPath should not be set yet");
            m_result->setValue("keyPath", value);
            return castState<KeyPathSet>();
        }

        Builder<STATE | AutoIncrementSet>& setAutoIncrement(bool value)
        {
            static_assert(!(STATE & AutoIncrementSet), "property autoIncrement should not be set yet");
            m_result->setBoolean("autoIncrement", value);
            return castState<AutoIncrementSet>();
        }

        Builder<STATE | IndexesSet>& setIndexes(PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::ObjectStoreIndex> > value)
        {
            static_assert(!(STATE & IndexesSet), "property indexes should not be set yet");
            m_result->setValue("indexes", value);
            return castState<IndexesSet>();
        }

        operator RefPtr<ObjectStore>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ObjectStore) == sizeof(JSONObject), "ObjectStore should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ObjectStore>*>(&m_result);
        }

        PassRefPtr<ObjectStore> release()
        {
            return RefPtr<ObjectStore>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ObjectStore> result = ObjectStore::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setAutoIncrement(...)
     *     .setIndexes(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void autoIncrement(bool* value)
    {
        JSONObjectBase::getBoolean("autoIncrement", value);
    }
};

/* Object store index. */
class ObjectStoreIndex : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        UniqueSet = 1 << 2,
        MultiEntrySet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | UniqueSet | MultiEntrySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ObjectStoreIndex*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ObjectStoreIndex;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(PassRefPtr<TypeBuilder::IndexedDB::KeyPath> value)
        {
            static_assert(!(STATE & KeyPathSet), "property keyPath should not be set yet");
            m_result->setValue("keyPath", value);
            return castState<KeyPathSet>();
        }

        Builder<STATE | UniqueSet>& setUnique(bool value)
        {
            static_assert(!(STATE & UniqueSet), "property unique should not be set yet");
            m_result->setBoolean("unique", value);
            return castState<UniqueSet>();
        }

        Builder<STATE | MultiEntrySet>& setMultiEntry(bool value)
        {
            static_assert(!(STATE & MultiEntrySet), "property multiEntry should not be set yet");
            m_result->setBoolean("multiEntry", value);
            return castState<MultiEntrySet>();
        }

        operator RefPtr<ObjectStoreIndex>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ObjectStoreIndex) == sizeof(JSONObject), "ObjectStoreIndex should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ObjectStoreIndex>*>(&m_result);
        }

        PassRefPtr<ObjectStoreIndex> release()
        {
            return RefPtr<ObjectStoreIndex>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ObjectStoreIndex> result = ObjectStoreIndex::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setUnique(...)
     *     .setMultiEntry(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void unique(bool* value)
    {
        JSONObjectBase::getBoolean("unique", value);
    }

    void multiEntry(bool* value)
    {
        JSONObjectBase::getBoolean("multiEntry", value);
    }
};

/* Key. */
class Key : public JSONObjectBase {
public:
    // Named after property name 'type' while generating Key.
    struct Type {
        enum Enum {
            Number = 18,
            String = 17,
            Date = 25,
            Array = 21,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Key*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Key;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<Key>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Key) == sizeof(JSONObject), "Key should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Key>*>(&m_result);
        }

        PassRefPtr<Key> release()
        {
            return RefPtr<Key>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Key> result = Key::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setNumber(double value)
    {
        this->setNumber("number", value);
    }
    using JSONObjectBase::setNumber;


    void setString(const String& value)
    {
        this->setString("string", value);
    }
    using JSONObjectBase::setString;


    void setDate(double value)
    {
        this->setNumber("date", value);
    }

    void setArray(PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::Key> > value)
    {
        this->setValue("array", value);
    }
    using JSONObjectBase::setArray;

};

/* Key range. */
class KeyRange : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LowerOpenSet = 1 << 0,
        UpperOpenSet = 1 << 1,
        AllFieldsSet = (LowerOpenSet | UpperOpenSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*KeyRange*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class KeyRange;
    public:

        Builder<STATE | LowerOpenSet>& setLowerOpen(bool value)
        {
            static_assert(!(STATE & LowerOpenSet), "property lowerOpen should not be set yet");
            m_result->setBoolean("lowerOpen", value);
            return castState<LowerOpenSet>();
        }

        Builder<STATE | UpperOpenSet>& setUpperOpen(bool value)
        {
            static_assert(!(STATE & UpperOpenSet), "property upperOpen should not be set yet");
            m_result->setBoolean("upperOpen", value);
            return castState<UpperOpenSet>();
        }

        operator RefPtr<KeyRange>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(KeyRange) == sizeof(JSONObject), "KeyRange should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<KeyRange>*>(&m_result);
        }

        PassRefPtr<KeyRange> release()
        {
            return RefPtr<KeyRange>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<KeyRange> result = KeyRange::create()
     *     .setLowerOpen(...)
     *     .setUpperOpen(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void lowerOpen(bool* value)
    {
        JSONObjectBase::getBoolean("lowerOpen", value);
    }

    void upperOpen(bool* value)
    {
        JSONObjectBase::getBoolean("upperOpen", value);
    }

    void setLower(PassRefPtr<TypeBuilder::IndexedDB::Key> value)
    {
        this->setValue("lower", value);
    }

    void setUpper(PassRefPtr<TypeBuilder::IndexedDB::Key> value)
    {
        this->setValue("upper", value);
    }
};

/* Data entry. */
class DataEntry : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        KeySet = 1 << 0,
        PrimaryKeySet = 1 << 1,
        ValueSet = 1 << 2,
        AllFieldsSet = (KeySet | PrimaryKeySet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*DataEntry*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class DataEntry;
    public:

        Builder<STATE | KeySet>& setKey(const String& value)
        {
            static_assert(!(STATE & KeySet), "property key should not be set yet");
            m_result->setString("key", value);
            return castState<KeySet>();
        }

        Builder<STATE | PrimaryKeySet>& setPrimaryKey(const String& value)
        {
            static_assert(!(STATE & PrimaryKeySet), "property primaryKey should not be set yet");
            m_result->setString("primaryKey", value);
            return castState<PrimaryKeySet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<DataEntry>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(DataEntry) == sizeof(JSONObject), "DataEntry should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<DataEntry>*>(&m_result);
        }

        PassRefPtr<DataEntry> release()
        {
            return RefPtr<DataEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DataEntry> result = DataEntry::create()
     *     .setKey(...)
     *     .setPrimaryKey(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void key(String* value)
    {
        JSONObjectBase::getString("key", value);
    }

    void primaryKey(String* value)
    {
        JSONObjectBase::getString("primaryKey", value);
    }

    void value(String* value)
    {
        JSONObjectBase::getString("value", value);
    }
};

/* Key path. */
class KeyPath : public JSONObjectBase {
public:
    // Named after property name 'type' while generating KeyPath.
    struct Type {
        enum Enum {
            Null = 22,
            String = 17,
            Array = 21,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*KeyPath*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class KeyPath;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<KeyPath>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(KeyPath) == sizeof(JSONObject), "KeyPath should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<KeyPath>*>(&m_result);
        }

        PassRefPtr<KeyPath> release()
        {
            return RefPtr<KeyPath>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<KeyPath> result = KeyPath::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setString(const String& value)
    {
        this->setString("string", value);
    }
    using JSONObjectBase::setString;


    void setArray(PassRefPtr<TypeBuilder::Array<String> > value)
    {
        this->setValue("array", value);
    }
    using JSONObjectBase::setArray;

};

} // IndexedDB

namespace CacheStorage {
/* Data entry. */
class DataEntry : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RequestSet = 1 << 0,
        ResponseSet = 1 << 1,
        AllFieldsSet = (RequestSet | ResponseSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*DataEntry*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class DataEntry;
    public:

        Builder<STATE | RequestSet>& setRequest(const String& value)
        {
            static_assert(!(STATE & RequestSet), "property request should not be set yet");
            m_result->setString("request", value);
            return castState<RequestSet>();
        }

        Builder<STATE | ResponseSet>& setResponse(const String& value)
        {
            static_assert(!(STATE & ResponseSet), "property response should not be set yet");
            m_result->setString("response", value);
            return castState<ResponseSet>();
        }

        operator RefPtr<DataEntry>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(DataEntry) == sizeof(JSONObject), "DataEntry should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<DataEntry>*>(&m_result);
        }

        PassRefPtr<DataEntry> release()
        {
            return RefPtr<DataEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DataEntry> result = DataEntry::create()
     *     .setRequest(...)
     *     .setResponse(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void request(String* value)
    {
        JSONObjectBase::getString("request", value);
    }

    void response(String* value)
    {
        JSONObjectBase::getString("response", value);
    }
};

/* Cache identifier. */
class Cache : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CacheIdSet = 1 << 0,
        SecurityOriginSet = 1 << 1,
        CacheNameSet = 1 << 2,
        AllFieldsSet = (CacheIdSet | SecurityOriginSet | CacheNameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Cache*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Cache;
    public:

        Builder<STATE | CacheIdSet>& setCacheId(const TypeBuilder::CacheStorage::CacheId& value)
        {
            static_assert(!(STATE & CacheIdSet), "property cacheId should not be set yet");
            m_result->setString("cacheId", value);
            return castState<CacheIdSet>();
        }

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            static_assert(!(STATE & SecurityOriginSet), "property securityOrigin should not be set yet");
            m_result->setString("securityOrigin", value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | CacheNameSet>& setCacheName(const String& value)
        {
            static_assert(!(STATE & CacheNameSet), "property cacheName should not be set yet");
            m_result->setString("cacheName", value);
            return castState<CacheNameSet>();
        }

        operator RefPtr<Cache>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Cache) == sizeof(JSONObject), "Cache should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Cache>*>(&m_result);
        }

        PassRefPtr<Cache> release()
        {
            return RefPtr<Cache>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Cache> result = Cache::create()
     *     .setCacheId(...)
     *     .setSecurityOrigin(...)
     *     .setCacheName(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void cacheId(TypeBuilder::CacheStorage::CacheId* value)
    {
        JSONObjectBase::getString("cacheId", value);
    }

    void securityOrigin(String* value)
    {
        JSONObjectBase::getString("securityOrigin", value);
    }

    void cacheName(String* value)
    {
        JSONObjectBase::getString("cacheName", value);
    }
};

} // CacheStorage

namespace DOMStorage {
/* DOM Storage identifier. */
class StorageId : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SecurityOriginSet = 1 << 0,
        IsLocalStorageSet = 1 << 1,
        AllFieldsSet = (SecurityOriginSet | IsLocalStorageSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*StorageId*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class StorageId;
    public:

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            static_assert(!(STATE & SecurityOriginSet), "property securityOrigin should not be set yet");
            m_result->setString("securityOrigin", value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | IsLocalStorageSet>& setIsLocalStorage(bool value)
        {
            static_assert(!(STATE & IsLocalStorageSet), "property isLocalStorage should not be set yet");
            m_result->setBoolean("isLocalStorage", value);
            return castState<IsLocalStorageSet>();
        }

        operator RefPtr<StorageId>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(StorageId) == sizeof(JSONObject), "StorageId should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<StorageId>*>(&m_result);
        }

        PassRefPtr<StorageId> release()
        {
            return RefPtr<StorageId>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<StorageId> result = StorageId::create()
     *     .setSecurityOrigin(...)
     *     .setIsLocalStorage(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void securityOrigin(String* value)
    {
        JSONObjectBase::getString("securityOrigin", value);
    }

    void isLocalStorage(bool* value)
    {
        JSONObjectBase::getBoolean("isLocalStorage", value);
    }
};

} // DOMStorage

namespace ApplicationCache {
/* Detailed application cache resource information. */
class ApplicationCacheResource : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        SizeSet = 1 << 1,
        TypeSet = 1 << 2,
        AllFieldsSet = (UrlSet | SizeSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ApplicationCacheResource*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ApplicationCacheResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            static_assert(!(STATE & SizeSet), "property size should not be set yet");
            m_result->setNumber("size", value);
            return castState<SizeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        operator RefPtr<ApplicationCacheResource>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ApplicationCacheResource) == sizeof(JSONObject), "ApplicationCacheResource should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ApplicationCacheResource>*>(&m_result);
        }

        PassRefPtr<ApplicationCacheResource> release()
        {
            return RefPtr<ApplicationCacheResource>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ApplicationCacheResource> result = ApplicationCacheResource::create()
     *     .setUrl(...)
     *     .setSize(...)
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void size(int* value)
    {
        JSONObjectBase::getNumber("size", value);
    }

    void type(String* value)
    {
        JSONObjectBase::getString("type", value);
    }
};

/* Detailed application cache information. */
class ApplicationCache : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ManifestURLSet = 1 << 0,
        SizeSet = 1 << 1,
        CreationTimeSet = 1 << 2,
        UpdateTimeSet = 1 << 3,
        ResourcesSet = 1 << 4,
        AllFieldsSet = (ManifestURLSet | SizeSet | CreationTimeSet | UpdateTimeSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ApplicationCache*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ApplicationCache;
    public:

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& value)
        {
            static_assert(!(STATE & ManifestURLSet), "property manifestURL should not be set yet");
            m_result->setString("manifestURL", value);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | SizeSet>& setSize(double value)
        {
            static_assert(!(STATE & SizeSet), "property size should not be set yet");
            m_result->setNumber("size", value);
            return castState<SizeSet>();
        }

        Builder<STATE | CreationTimeSet>& setCreationTime(double value)
        {
            static_assert(!(STATE & CreationTimeSet), "property creationTime should not be set yet");
            m_result->setNumber("creationTime", value);
            return castState<CreationTimeSet>();
        }

        Builder<STATE | UpdateTimeSet>& setUpdateTime(double value)
        {
            static_assert(!(STATE & UpdateTimeSet), "property updateTime should not be set yet");
            m_result->setNumber("updateTime", value);
            return castState<UpdateTimeSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(PassRefPtr<TypeBuilder::Array<TypeBuilder::ApplicationCache::ApplicationCacheResource> > value)
        {
            static_assert(!(STATE & ResourcesSet), "property resources should not be set yet");
            m_result->setValue("resources", value);
            return castState<ResourcesSet>();
        }

        operator RefPtr<ApplicationCache>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ApplicationCache) == sizeof(JSONObject), "ApplicationCache should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ApplicationCache>*>(&m_result);
        }

        PassRefPtr<ApplicationCache> release()
        {
            return RefPtr<ApplicationCache>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ApplicationCache> result = ApplicationCache::create()
     *     .setManifestURL(...)
     *     .setSize(...)
     *     .setCreationTime(...)
     *     .setUpdateTime(...)
     *     .setResources(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void manifestURL(String* value)
    {
        JSONObjectBase::getString("manifestURL", value);
    }

    void size(double* value)
    {
        JSONObjectBase::getNumber("size", value);
    }

    void creationTime(double* value)
    {
        JSONObjectBase::getNumber("creationTime", value);
    }

    void updateTime(double* value)
    {
        JSONObjectBase::getNumber("updateTime", value);
    }
};

/* Frame identifier - manifest URL pair. */
class FrameWithManifest : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FrameIdSet = 1 << 0,
        ManifestURLSet = 1 << 1,
        StatusSet = 1 << 2,
        AllFieldsSet = (FrameIdSet | ManifestURLSet | StatusSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*FrameWithManifest*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class FrameWithManifest;
    public:

        Builder<STATE | FrameIdSet>& setFrameId(const TypeBuilder::Page::FrameId& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setString("frameId", value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& value)
        {
            static_assert(!(STATE & ManifestURLSet), "property manifestURL should not be set yet");
            m_result->setString("manifestURL", value);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | StatusSet>& setStatus(int value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setNumber("status", value);
            return castState<StatusSet>();
        }

        operator RefPtr<FrameWithManifest>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(FrameWithManifest) == sizeof(JSONObject), "FrameWithManifest should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<FrameWithManifest>*>(&m_result);
        }

        PassRefPtr<FrameWithManifest> release()
        {
            return RefPtr<FrameWithManifest>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FrameWithManifest> result = FrameWithManifest::create()
     *     .setFrameId(...)
     *     .setManifestURL(...)
     *     .setStatus(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void frameId(TypeBuilder::Page::FrameId* value)
    {
        JSONObjectBase::getString("frameId", value);
    }

    void manifestURL(String* value)
    {
        JSONObjectBase::getString("manifestURL", value);
    }

    void status(int* value)
    {
        JSONObjectBase::getNumber("status", value);
    }
};

} // ApplicationCache

namespace FileSystem {
/* Represents a browser side file or directory. */
class Entry : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        NameSet = 1 << 1,
        IsDirectorySet = 1 << 2,
        AllFieldsSet = (UrlSet | NameSet | IsDirectorySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Entry*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Entry;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | IsDirectorySet>& setIsDirectory(bool value)
        {
            static_assert(!(STATE & IsDirectorySet), "property isDirectory should not be set yet");
            m_result->setBoolean("isDirectory", value);
            return castState<IsDirectorySet>();
        }

        operator RefPtr<Entry>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Entry) == sizeof(JSONObject), "Entry should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Entry>*>(&m_result);
        }

        PassRefPtr<Entry> release()
        {
            return RefPtr<Entry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Entry> result = Entry::create()
     *     .setUrl(...)
     *     .setName(...)
     *     .setIsDirectory(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void isDirectory(bool* value)
    {
        JSONObjectBase::getBoolean("isDirectory", value);
    }

    void setMimeType(const String& value)
    {
        this->setString("mimeType", value);
    }

    void setResourceType(TypeBuilder::Page::ResourceType::Enum value)
    {
        this->setString("resourceType", TypeBuilder::getEnumConstantValue(value));
    }

    void setIsTextFile(bool value)
    {
        this->setBoolean("isTextFile", value);
    }
};

/* Represents metadata of a file or entry. */
class Metadata : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ModificationTimeSet = 1 << 0,
        SizeSet = 1 << 1,
        AllFieldsSet = (ModificationTimeSet | SizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Metadata*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Metadata;
    public:

        Builder<STATE | ModificationTimeSet>& setModificationTime(double value)
        {
            static_assert(!(STATE & ModificationTimeSet), "property modificationTime should not be set yet");
            m_result->setNumber("modificationTime", value);
            return castState<ModificationTimeSet>();
        }

        Builder<STATE | SizeSet>& setSize(double value)
        {
            static_assert(!(STATE & SizeSet), "property size should not be set yet");
            m_result->setNumber("size", value);
            return castState<SizeSet>();
        }

        operator RefPtr<Metadata>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Metadata) == sizeof(JSONObject), "Metadata should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Metadata>*>(&m_result);
        }

        PassRefPtr<Metadata> release()
        {
            return RefPtr<Metadata>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Metadata> result = Metadata::create()
     *     .setModificationTime(...)
     *     .setSize(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void modificationTime(double* value)
    {
        JSONObjectBase::getNumber("modificationTime", value);
    }

    void size(double* value)
    {
        JSONObjectBase::getNumber("size", value);
    }
};

} // FileSystem

namespace DOM {
/* Backend node with a friendly name. */
class BackendNode : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NodeTypeSet = 1 << 0,
        NodeNameSet = 1 << 1,
        BackendNodeIdSet = 1 << 2,
        AllFieldsSet = (NodeTypeSet | NodeNameSet | BackendNodeIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*BackendNode*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class BackendNode;
    public:

        Builder<STATE | NodeTypeSet>& setNodeType(int value)
        {
            static_assert(!(STATE & NodeTypeSet), "property nodeType should not be set yet");
            m_result->setNumber("nodeType", value);
            return castState<NodeTypeSet>();
        }

        Builder<STATE | NodeNameSet>& setNodeName(const String& value)
        {
            static_assert(!(STATE & NodeNameSet), "property nodeName should not be set yet");
            m_result->setString("nodeName", value);
            return castState<NodeNameSet>();
        }

        Builder<STATE | BackendNodeIdSet>& setBackendNodeId(int value)
        {
            static_assert(!(STATE & BackendNodeIdSet), "property backendNodeId should not be set yet");
            m_result->setNumber("backendNodeId", value);
            return castState<BackendNodeIdSet>();
        }

        operator RefPtr<BackendNode>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(BackendNode) == sizeof(JSONObject), "BackendNode should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<BackendNode>*>(&m_result);
        }

        PassRefPtr<BackendNode> release()
        {
            return RefPtr<BackendNode>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<BackendNode> result = BackendNode::create()
     *     .setNodeType(...)
     *     .setNodeName(...)
     *     .setBackendNodeId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void nodeType(int* value)
    {
        JSONObjectBase::getNumber("nodeType", value);
    }

    void nodeName(String* value)
    {
        JSONObjectBase::getString("nodeName", value);
    }

    void backendNodeId(int* value)
    {
        JSONObjectBase::getNumber("backendNodeId", value);
    }
};

/* Pseudo element type. */
struct PseudoType {
    enum Enum {
        First_line = 60,
        First_letter = 61,
        Before = 62,
        After = 63,
        Backdrop = 64,
        Selection = 65,
        First_line_inherited = 66,
        Scrollbar = 67,
        Scrollbar_thumb = 68,
        Scrollbar_button = 69,
        Scrollbar_track = 70,
        Scrollbar_track_piece = 71,
        Scrollbar_corner = 72,
        Resizer = 73,
        Input_list_button = 74,
    };
}; // struct PseudoType

/* Shadow root type. */
struct ShadowRootType {
    enum Enum {
        User_agent = 75,
        Author = 76,
    };
}; // struct ShadowRootType

/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class Node : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NodeIdSet = 1 << 0,
        NodeTypeSet = 1 << 1,
        NodeNameSet = 1 << 2,
        LocalNameSet = 1 << 3,
        NodeValueSet = 1 << 4,
        AllFieldsSet = (NodeIdSet | NodeTypeSet | NodeNameSet | LocalNameSet | NodeValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Node*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Node;
    public:

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNumber("nodeId", value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | NodeTypeSet>& setNodeType(int value)
        {
            static_assert(!(STATE & NodeTypeSet), "property nodeType should not be set yet");
            m_result->setNumber("nodeType", value);
            return castState<NodeTypeSet>();
        }

        Builder<STATE | NodeNameSet>& setNodeName(const String& value)
        {
            static_assert(!(STATE & NodeNameSet), "property nodeName should not be set yet");
            m_result->setString("nodeName", value);
            return castState<NodeNameSet>();
        }

        Builder<STATE | LocalNameSet>& setLocalName(const String& value)
        {
            static_assert(!(STATE & LocalNameSet), "property localName should not be set yet");
            m_result->setString("localName", value);
            return castState<LocalNameSet>();
        }

        Builder<STATE | NodeValueSet>& setNodeValue(const String& value)
        {
            static_assert(!(STATE & NodeValueSet), "property nodeValue should not be set yet");
            m_result->setString("nodeValue", value);
            return castState<NodeValueSet>();
        }

        operator RefPtr<Node>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Node) == sizeof(JSONObject), "Node should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Node>*>(&m_result);
        }

        PassRefPtr<Node> release()
        {
            return RefPtr<Node>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Node> result = Node::create()
     *     .setNodeId(...)
     *     .setNodeType(...)
     *     .setNodeName(...)
     *     .setLocalName(...)
     *     .setNodeValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void nodeId(int* value)
    {
        JSONObjectBase::getNumber("nodeId", value);
    }

    void nodeType(int* value)
    {
        JSONObjectBase::getNumber("nodeType", value);
    }

    void nodeName(String* value)
    {
        JSONObjectBase::getString("nodeName", value);
    }

    void localName(String* value)
    {
        JSONObjectBase::getString("localName", value);
    }

    void nodeValue(String* value)
    {
        JSONObjectBase::getString("nodeValue", value);
    }

    void setChildNodeCount(int value)
    {
        this->setNumber("childNodeCount", value);
    }

    void setChildren(PassRefPtr<TypeBuilder::Array<TypeBuilder::DOM::Node> > value)
    {
        this->setValue("children", value);
    }

    void setAttributes(PassRefPtr<TypeBuilder::Array<String> > value)
    {
        this->setValue("attributes", value);
    }

    void setDocumentURL(const String& value)
    {
        this->setString("documentURL", value);
    }

    void setBaseURL(const String& value)
    {
        this->setString("baseURL", value);
    }

    void setPublicId(const String& value)
    {
        this->setString("publicId", value);
    }

    void setSystemId(const String& value)
    {
        this->setString("systemId", value);
    }

    void setInternalSubset(const String& value)
    {
        this->setString("internalSubset", value);
    }

    void setXmlVersion(const String& value)
    {
        this->setString("xmlVersion", value);
    }

    void setName(const String& value)
    {
        this->setString("name", value);
    }

    void setValue(const String& value)
    {
        this->setString("value", value);
    }
    using JSONObjectBase::setValue;


    void setPseudoType(TypeBuilder::DOM::PseudoType::Enum value)
    {
        this->setString("pseudoType", TypeBuilder::getEnumConstantValue(value));
    }

    void setShadowRootType(TypeBuilder::DOM::ShadowRootType::Enum value)
    {
        this->setString("shadowRootType", TypeBuilder::getEnumConstantValue(value));
    }

    void setFrameId(const TypeBuilder::Page::FrameId& value)
    {
        this->setString("frameId", value);
    }

    void setContentDocument(PassRefPtr<TypeBuilder::DOM::Node> value)
    {
        this->setValue("contentDocument", value);
    }

    void setShadowRoots(PassRefPtr<TypeBuilder::Array<TypeBuilder::DOM::Node> > value)
    {
        this->setValue("shadowRoots", value);
    }

    void setTemplateContent(PassRefPtr<TypeBuilder::DOM::Node> value)
    {
        this->setValue("templateContent", value);
    }

    void setPseudoElements(PassRefPtr<TypeBuilder::Array<TypeBuilder::DOM::Node> > value)
    {
        this->setValue("pseudoElements", value);
    }

    void setImportedDocument(PassRefPtr<TypeBuilder::DOM::Node> value)
    {
        this->setValue("importedDocument", value);
    }

    void setDistributedNodes(PassRefPtr<TypeBuilder::Array<TypeBuilder::DOM::BackendNode> > value)
    {
        this->setValue("distributedNodes", value);
    }
};

/* A structure holding an RGBA color. */
// Type originally was named 'RGBA'.
class Rgba : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RSet = 1 << 0,
        GSet = 1 << 1,
        BSet = 1 << 2,
        AllFieldsSet = (RSet | GSet | BSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Rgba*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Rgba;
    public:

        Builder<STATE | RSet>& setR(int value)
        {
            static_assert(!(STATE & RSet), "property r should not be set yet");
            m_result->setNumber("r", value);
            return castState<RSet>();
        }

        Builder<STATE | GSet>& setG(int value)
        {
            static_assert(!(STATE & GSet), "property g should not be set yet");
            m_result->setNumber("g", value);
            return castState<GSet>();
        }

        Builder<STATE | BSet>& setB(int value)
        {
            static_assert(!(STATE & BSet), "property b should not be set yet");
            m_result->setNumber("b", value);
            return castState<BSet>();
        }

        operator RefPtr<Rgba>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Rgba) == sizeof(JSONObject), "Rgba should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Rgba>*>(&m_result);
        }

        PassRefPtr<Rgba> release()
        {
            return RefPtr<Rgba>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Rgba> result = Rgba::create()
     *     .setR(...)
     *     .setG(...)
     *     .setB(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void r(int* value)
    {
        JSONObjectBase::getNumber("r", value);
    }

    void g(int* value)
    {
        JSONObjectBase::getNumber("g", value);
    }

    void b(int* value)
    {
        JSONObjectBase::getNumber("b", value);
    }

    void setA(double value)
    {
        this->setNumber("a", value);
    }
};

/* Box model. */
class BoxModel : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ContentSet = 1 << 0,
        PaddingSet = 1 << 1,
        BorderSet = 1 << 2,
        MarginSet = 1 << 3,
        WidthSet = 1 << 4,
        HeightSet = 1 << 5,
        AllFieldsSet = (ContentSet | PaddingSet | BorderSet | MarginSet | WidthSet | HeightSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*BoxModel*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class BoxModel;
    public:

        Builder<STATE | ContentSet>& setContent(PassRefPtr<TypeBuilder::Array<double> > value)
        {
            static_assert(!(STATE & ContentSet), "property content should not be set yet");
            m_result->setValue("content", value);
            return castState<ContentSet>();
        }

        Builder<STATE | PaddingSet>& setPadding(PassRefPtr<TypeBuilder::Array<double> > value)
        {
            static_assert(!(STATE & PaddingSet), "property padding should not be set yet");
            m_result->setValue("padding", value);
            return castState<PaddingSet>();
        }

        Builder<STATE | BorderSet>& setBorder(PassRefPtr<TypeBuilder::Array<double> > value)
        {
            static_assert(!(STATE & BorderSet), "property border should not be set yet");
            m_result->setValue("border", value);
            return castState<BorderSet>();
        }

        Builder<STATE | MarginSet>& setMargin(PassRefPtr<TypeBuilder::Array<double> > value)
        {
            static_assert(!(STATE & MarginSet), "property margin should not be set yet");
            m_result->setValue("margin", value);
            return castState<MarginSet>();
        }

        Builder<STATE | WidthSet>& setWidth(int value)
        {
            static_assert(!(STATE & WidthSet), "property width should not be set yet");
            m_result->setNumber("width", value);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(int value)
        {
            static_assert(!(STATE & HeightSet), "property height should not be set yet");
            m_result->setNumber("height", value);
            return castState<HeightSet>();
        }

        operator RefPtr<BoxModel>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(BoxModel) == sizeof(JSONObject), "BoxModel should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<BoxModel>*>(&m_result);
        }

        PassRefPtr<BoxModel> release()
        {
            return RefPtr<BoxModel>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<BoxModel> result = BoxModel::create()
     *     .setContent(...)
     *     .setPadding(...)
     *     .setBorder(...)
     *     .setMargin(...)
     *     .setWidth(...)
     *     .setHeight(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void width(int* value)
    {
        JSONObjectBase::getNumber("width", value);
    }

    void height(int* value)
    {
        JSONObjectBase::getNumber("height", value);
    }

    void setShapeOutside(PassRefPtr<TypeBuilder::DOM::ShapeOutsideInfo> value)
    {
        this->setValue("shapeOutside", value);
    }
};

/* CSS Shape Outside details. */
class ShapeOutsideInfo : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        BoundsSet = 1 << 0,
        ShapeSet = 1 << 1,
        MarginShapeSet = 1 << 2,
        AllFieldsSet = (BoundsSet | ShapeSet | MarginShapeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ShapeOutsideInfo*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ShapeOutsideInfo;
    public:

        Builder<STATE | BoundsSet>& setBounds(PassRefPtr<TypeBuilder::Array<double> > value)
        {
            static_assert(!(STATE & BoundsSet), "property bounds should not be set yet");
            m_result->setValue("bounds", value);
            return castState<BoundsSet>();
        }

        Builder<STATE | ShapeSet>& setShape(PassRefPtr<TypeBuilder::Array<JSONValue> > value)
        {
            static_assert(!(STATE & ShapeSet), "property shape should not be set yet");
            m_result->setValue("shape", value);
            return castState<ShapeSet>();
        }

        Builder<STATE | MarginShapeSet>& setMarginShape(PassRefPtr<TypeBuilder::Array<JSONValue> > value)
        {
            static_assert(!(STATE & MarginShapeSet), "property marginShape should not be set yet");
            m_result->setValue("marginShape", value);
            return castState<MarginShapeSet>();
        }

        operator RefPtr<ShapeOutsideInfo>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ShapeOutsideInfo) == sizeof(JSONObject), "ShapeOutsideInfo should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ShapeOutsideInfo>*>(&m_result);
        }

        PassRefPtr<ShapeOutsideInfo> release()
        {
            return RefPtr<ShapeOutsideInfo>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ShapeOutsideInfo> result = ShapeOutsideInfo::create()
     *     .setBounds(...)
     *     .setShape(...)
     *     .setMarginShape(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Rectangle. */
class Rect : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        XSet = 1 << 0,
        YSet = 1 << 1,
        WidthSet = 1 << 2,
        HeightSet = 1 << 3,
        AllFieldsSet = (XSet | YSet | WidthSet | HeightSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Rect*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Rect;
    public:

        Builder<STATE | XSet>& setX(double value)
        {
            static_assert(!(STATE & XSet), "property x should not be set yet");
            m_result->setNumber("x", value);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(double value)
        {
            static_assert(!(STATE & YSet), "property y should not be set yet");
            m_result->setNumber("y", value);
            return castState<YSet>();
        }

        Builder<STATE | WidthSet>& setWidth(double value)
        {
            static_assert(!(STATE & WidthSet), "property width should not be set yet");
            m_result->setNumber("width", value);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(double value)
        {
            static_assert(!(STATE & HeightSet), "property height should not be set yet");
            m_result->setNumber("height", value);
            return castState<HeightSet>();
        }

        operator RefPtr<Rect>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Rect) == sizeof(JSONObject), "Rect should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Rect>*>(&m_result);
        }

        PassRefPtr<Rect> release()
        {
            return RefPtr<Rect>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Rect> result = Rect::create()
     *     .setX(...)
     *     .setY(...)
     *     .setWidth(...)
     *     .setHeight(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void x(double* value)
    {
        JSONObjectBase::getNumber("x", value);
    }

    void y(double* value)
    {
        JSONObjectBase::getNumber("y", value);
    }

    void width(double* value)
    {
        JSONObjectBase::getNumber("width", value);
    }

    void height(double* value)
    {
        JSONObjectBase::getNumber("height", value);
    }
};

/* Configuration data for the highlighting of page elements. */
class HighlightConfig : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*HighlightConfig*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class HighlightConfig;
    public:

        operator RefPtr<HighlightConfig>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(HighlightConfig) == sizeof(JSONObject), "HighlightConfig should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<HighlightConfig>*>(&m_result);
        }

        PassRefPtr<HighlightConfig> release()
        {
            return RefPtr<HighlightConfig>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<HighlightConfig> result = HighlightConfig::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setShowInfo(bool value)
    {
        this->setBoolean("showInfo", value);
    }

    void setShowRulers(bool value)
    {
        this->setBoolean("showRulers", value);
    }

    void setShowExtensionLines(bool value)
    {
        this->setBoolean("showExtensionLines", value);
    }

    void setShowLayoutEditor(bool value)
    {
        this->setBoolean("showLayoutEditor", value);
    }

    void setContentColor(PassRefPtr<TypeBuilder::DOM::Rgba> value)
    {
        this->setValue("contentColor", value);
    }

    void setPaddingColor(PassRefPtr<TypeBuilder::DOM::Rgba> value)
    {
        this->setValue("paddingColor", value);
    }

    void setBorderColor(PassRefPtr<TypeBuilder::DOM::Rgba> value)
    {
        this->setValue("borderColor", value);
    }

    void setMarginColor(PassRefPtr<TypeBuilder::DOM::Rgba> value)
    {
        this->setValue("marginColor", value);
    }

    void setEventTargetColor(PassRefPtr<TypeBuilder::DOM::Rgba> value)
    {
        this->setValue("eventTargetColor", value);
    }

    void setShapeColor(PassRefPtr<TypeBuilder::DOM::Rgba> value)
    {
        this->setValue("shapeColor", value);
    }

    void setShapeMarginColor(PassRefPtr<TypeBuilder::DOM::Rgba> value)
    {
        this->setValue("shapeMarginColor", value);
    }
};

} // DOM

namespace CSS {
/* Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via inspector" rules), "regular" for regular stylesheets. */
struct StyleSheetOrigin {
    enum Enum {
        Injected = 77,
        User_agent = 75,
        Inspector = 78,
        Regular = 79,
    };
}; // struct StyleSheetOrigin

/* CSS rule collection for a single pseudo style. */
class PseudoIdMatches : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        PseudoIdSet = 1 << 0,
        MatchesSet = 1 << 1,
        AllFieldsSet = (PseudoIdSet | MatchesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PseudoIdMatches*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class PseudoIdMatches;
    public:

        Builder<STATE | PseudoIdSet>& setPseudoId(int value)
        {
            static_assert(!(STATE & PseudoIdSet), "property pseudoId should not be set yet");
            m_result->setNumber("pseudoId", value);
            return castState<PseudoIdSet>();
        }

        Builder<STATE | MatchesSet>& setMatches(PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::RuleMatch> > value)
        {
            static_assert(!(STATE & MatchesSet), "property matches should not be set yet");
            m_result->setValue("matches", value);
            return castState<MatchesSet>();
        }

        operator RefPtr<PseudoIdMatches>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(PseudoIdMatches) == sizeof(JSONObject), "PseudoIdMatches should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<PseudoIdMatches>*>(&m_result);
        }

        PassRefPtr<PseudoIdMatches> release()
        {
            return RefPtr<PseudoIdMatches>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PseudoIdMatches> result = PseudoIdMatches::create()
     *     .setPseudoId(...)
     *     .setMatches(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void pseudoId(int* value)
    {
        JSONObjectBase::getNumber("pseudoId", value);
    }
};

/* Inherited CSS rule collection from ancestor node. */
class InheritedStyleEntry : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MatchedCSSRulesSet = 1 << 0,
        AllFieldsSet = (MatchedCSSRulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*InheritedStyleEntry*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class InheritedStyleEntry;
    public:

        Builder<STATE | MatchedCSSRulesSet>& setMatchedCSSRules(PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::RuleMatch> > value)
        {
            static_assert(!(STATE & MatchedCSSRulesSet), "property matchedCSSRules should not be set yet");
            m_result->setValue("matchedCSSRules", value);
            return castState<MatchedCSSRulesSet>();
        }

        operator RefPtr<InheritedStyleEntry>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(InheritedStyleEntry) == sizeof(JSONObject), "InheritedStyleEntry should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<InheritedStyleEntry>*>(&m_result);
        }

        PassRefPtr<InheritedStyleEntry> release()
        {
            return RefPtr<InheritedStyleEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<InheritedStyleEntry> result = InheritedStyleEntry::create()
     *     .setMatchedCSSRules(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setInlineStyle(PassRefPtr<TypeBuilder::CSS::CSSStyle> value)
    {
        this->setValue("inlineStyle", value);
    }
};

/* Match data for a CSS rule. */
class RuleMatch : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RuleSet = 1 << 0,
        MatchingSelectorsSet = 1 << 1,
        AllFieldsSet = (RuleSet | MatchingSelectorsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*RuleMatch*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class RuleMatch;
    public:

        Builder<STATE | RuleSet>& setRule(PassRefPtr<TypeBuilder::CSS::CSSRule> value)
        {
            static_assert(!(STATE & RuleSet), "property rule should not be set yet");
            m_result->setValue("rule", value);
            return castState<RuleSet>();
        }

        Builder<STATE | MatchingSelectorsSet>& setMatchingSelectors(PassRefPtr<TypeBuilder::Array<int> > value)
        {
            static_assert(!(STATE & MatchingSelectorsSet), "property matchingSelectors should not be set yet");
            m_result->setValue("matchingSelectors", value);
            return castState<MatchingSelectorsSet>();
        }

        operator RefPtr<RuleMatch>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(RuleMatch) == sizeof(JSONObject), "RuleMatch should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<RuleMatch>*>(&m_result);
        }

        PassRefPtr<RuleMatch> release()
        {
            return RefPtr<RuleMatch>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<RuleMatch> result = RuleMatch::create()
     *     .setRule(...)
     *     .setMatchingSelectors(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Data for a simple selector (these are delimited by commas in a selector list). */
class Selector : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ValueSet = 1 << 0,
        AllFieldsSet = (ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Selector*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Selector;
    public:

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<Selector>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Selector) == sizeof(JSONObject), "Selector should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Selector>*>(&m_result);
        }

        PassRefPtr<Selector> release()
        {
            return RefPtr<Selector>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Selector> result = Selector::create()
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void value(String* value)
    {
        JSONObjectBase::getString("value", value);
    }

    void setRange(PassRefPtr<TypeBuilder::CSS::SourceRange> value)
    {
        this->setValue("range", value);
    }
};

/* Selector list data. */
class SelectorList : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorsSet = 1 << 0,
        TextSet = 1 << 1,
        AllFieldsSet = (SelectorsSet | TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SelectorList*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class SelectorList;
    public:

        Builder<STATE | SelectorsSet>& setSelectors(PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::Selector> > value)
        {
            static_assert(!(STATE & SelectorsSet), "property selectors should not be set yet");
            m_result->setValue("selectors", value);
            return castState<SelectorsSet>();
        }

        Builder<STATE | TextSet>& setText(const String& value)
        {
            static_assert(!(STATE & TextSet), "property text should not be set yet");
            m_result->setString("text", value);
            return castState<TextSet>();
        }

        operator RefPtr<SelectorList>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(SelectorList) == sizeof(JSONObject), "SelectorList should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<SelectorList>*>(&m_result);
        }

        PassRefPtr<SelectorList> release()
        {
            return RefPtr<SelectorList>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SelectorList> result = SelectorList::create()
     *     .setSelectors(...)
     *     .setText(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void text(String* value)
    {
        JSONObjectBase::getString("text", value);
    }
};

/* CSS stylesheet metainformation. */
class CSSStyleSheetHeader : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        FrameIdSet = 1 << 1,
        SourceURLSet = 1 << 2,
        OriginSet = 1 << 3,
        TitleSet = 1 << 4,
        DisabledSet = 1 << 5,
        IsInlineSet = 1 << 6,
        StartLineSet = 1 << 7,
        StartColumnSet = 1 << 8,
        AllFieldsSet = (StyleSheetIdSet | FrameIdSet | SourceURLSet | OriginSet | TitleSet | DisabledSet | IsInlineSet | StartLineSet | StartColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSStyleSheetHeader*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CSSStyleSheetHeader;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const TypeBuilder::CSS::StyleSheetId& value)
        {
            static_assert(!(STATE & StyleSheetIdSet), "property styleSheetId should not be set yet");
            m_result->setString("styleSheetId", value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const TypeBuilder::Page::FrameId& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setString("frameId", value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | SourceURLSet>& setSourceURL(const String& value)
        {
            static_assert(!(STATE & SourceURLSet), "property sourceURL should not be set yet");
            m_result->setString("sourceURL", value);
            return castState<SourceURLSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(TypeBuilder::CSS::StyleSheetOrigin::Enum value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->setString("origin", TypeBuilder::getEnumConstantValue(value));
            return castState<OriginSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            static_assert(!(STATE & TitleSet), "property title should not be set yet");
            m_result->setString("title", value);
            return castState<TitleSet>();
        }

        Builder<STATE | DisabledSet>& setDisabled(bool value)
        {
            static_assert(!(STATE & DisabledSet), "property disabled should not be set yet");
            m_result->setBoolean("disabled", value);
            return castState<DisabledSet>();
        }

        Builder<STATE | IsInlineSet>& setIsInline(bool value)
        {
            static_assert(!(STATE & IsInlineSet), "property isInline should not be set yet");
            m_result->setBoolean("isInline", value);
            return castState<IsInlineSet>();
        }

        Builder<STATE | StartLineSet>& setStartLine(double value)
        {
            static_assert(!(STATE & StartLineSet), "property startLine should not be set yet");
            m_result->setNumber("startLine", value);
            return castState<StartLineSet>();
        }

        Builder<STATE | StartColumnSet>& setStartColumn(double value)
        {
            static_assert(!(STATE & StartColumnSet), "property startColumn should not be set yet");
            m_result->setNumber("startColumn", value);
            return castState<StartColumnSet>();
        }

        operator RefPtr<CSSStyleSheetHeader>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CSSStyleSheetHeader) == sizeof(JSONObject), "CSSStyleSheetHeader should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CSSStyleSheetHeader>*>(&m_result);
        }

        PassRefPtr<CSSStyleSheetHeader> release()
        {
            return RefPtr<CSSStyleSheetHeader>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleSheetHeader> result = CSSStyleSheetHeader::create()
     *     .setStyleSheetId(...)
     *     .setFrameId(...)
     *     .setSourceURL(...)
     *     .setOrigin(...)
     *     .setTitle(...)
     *     .setDisabled(...)
     *     .setIsInline(...)
     *     .setStartLine(...)
     *     .setStartColumn(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void styleSheetId(TypeBuilder::CSS::StyleSheetId* value)
    {
        JSONObjectBase::getString("styleSheetId", value);
    }

    void frameId(TypeBuilder::Page::FrameId* value)
    {
        JSONObjectBase::getString("frameId", value);
    }

    void sourceURL(String* value)
    {
        JSONObjectBase::getString("sourceURL", value);
    }

    void title(String* value)
    {
        JSONObjectBase::getString("title", value);
    }

    void disabled(bool* value)
    {
        JSONObjectBase::getBoolean("disabled", value);
    }

    void isInline(bool* value)
    {
        JSONObjectBase::getBoolean("isInline", value);
    }

    void startLine(double* value)
    {
        JSONObjectBase::getNumber("startLine", value);
    }

    void startColumn(double* value)
    {
        JSONObjectBase::getNumber("startColumn", value);
    }

    void setSourceMapURL(const String& value)
    {
        this->setString("sourceMapURL", value);
    }

    void setOwnerNode(int value)
    {
        this->setNumber("ownerNode", value);
    }

    void setHasSourceURL(bool value)
    {
        this->setBoolean("hasSourceURL", value);
    }
};

/* CSS rule representation. */
class CSSRule : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorListSet = 1 << 0,
        OriginSet = 1 << 1,
        StyleSet = 1 << 2,
        AllFieldsSet = (SelectorListSet | OriginSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSRule*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CSSRule;
    public:

        Builder<STATE | SelectorListSet>& setSelectorList(PassRefPtr<TypeBuilder::CSS::SelectorList> value)
        {
            static_assert(!(STATE & SelectorListSet), "property selectorList should not be set yet");
            m_result->setValue("selectorList", value);
            return castState<SelectorListSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(TypeBuilder::CSS::StyleSheetOrigin::Enum value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->setString("origin", TypeBuilder::getEnumConstantValue(value));
            return castState<OriginSet>();
        }

        Builder<STATE | StyleSet>& setStyle(PassRefPtr<TypeBuilder::CSS::CSSStyle> value)
        {
            static_assert(!(STATE & StyleSet), "property style should not be set yet");
            m_result->setValue("style", value);
            return castState<StyleSet>();
        }

        operator RefPtr<CSSRule>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CSSRule) == sizeof(JSONObject), "CSSRule should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CSSRule>*>(&m_result);
        }

        PassRefPtr<CSSRule> release()
        {
            return RefPtr<CSSRule>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSRule> result = CSSRule::create()
     *     .setSelectorList(...)
     *     .setOrigin(...)
     *     .setStyle(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setStyleSheetId(const TypeBuilder::CSS::StyleSheetId& value)
    {
        this->setString("styleSheetId", value);
    }

    void setMedia(PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSMedia> > value)
    {
        this->setValue("media", value);
    }
};

/* Text range within a resource. All numbers are zero-based. */
class SourceRange : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartLineSet = 1 << 0,
        StartColumnSet = 1 << 1,
        EndLineSet = 1 << 2,
        EndColumnSet = 1 << 3,
        AllFieldsSet = (StartLineSet | StartColumnSet | EndLineSet | EndColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SourceRange*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class SourceRange;
    public:

        Builder<STATE | StartLineSet>& setStartLine(int value)
        {
            static_assert(!(STATE & StartLineSet), "property startLine should not be set yet");
            m_result->setNumber("startLine", value);
            return castState<StartLineSet>();
        }

        Builder<STATE | StartColumnSet>& setStartColumn(int value)
        {
            static_assert(!(STATE & StartColumnSet), "property startColumn should not be set yet");
            m_result->setNumber("startColumn", value);
            return castState<StartColumnSet>();
        }

        Builder<STATE | EndLineSet>& setEndLine(int value)
        {
            static_assert(!(STATE & EndLineSet), "property endLine should not be set yet");
            m_result->setNumber("endLine", value);
            return castState<EndLineSet>();
        }

        Builder<STATE | EndColumnSet>& setEndColumn(int value)
        {
            static_assert(!(STATE & EndColumnSet), "property endColumn should not be set yet");
            m_result->setNumber("endColumn", value);
            return castState<EndColumnSet>();
        }

        operator RefPtr<SourceRange>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(SourceRange) == sizeof(JSONObject), "SourceRange should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<SourceRange>*>(&m_result);
        }

        PassRefPtr<SourceRange> release()
        {
            return RefPtr<SourceRange>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SourceRange> result = SourceRange::create()
     *     .setStartLine(...)
     *     .setStartColumn(...)
     *     .setEndLine(...)
     *     .setEndColumn(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void startLine(int* value)
    {
        JSONObjectBase::getNumber("startLine", value);
    }

    void startColumn(int* value)
    {
        JSONObjectBase::getNumber("startColumn", value);
    }

    void endLine(int* value)
    {
        JSONObjectBase::getNumber("endLine", value);
    }

    void endColumn(int* value)
    {
        JSONObjectBase::getNumber("endColumn", value);
    }
};

class ShorthandEntry : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ShorthandEntry*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ShorthandEntry;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<ShorthandEntry>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ShorthandEntry) == sizeof(JSONObject), "ShorthandEntry should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ShorthandEntry>*>(&m_result);
        }

        PassRefPtr<ShorthandEntry> release()
        {
            return RefPtr<ShorthandEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ShorthandEntry> result = ShorthandEntry::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void value(String* value)
    {
        JSONObjectBase::getString("value", value);
    }

    void setImportant(bool value)
    {
        this->setBoolean("important", value);
    }
};

class CSSComputedStyleProperty : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSComputedStyleProperty*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CSSComputedStyleProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<CSSComputedStyleProperty>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CSSComputedStyleProperty) == sizeof(JSONObject), "CSSComputedStyleProperty should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CSSComputedStyleProperty>*>(&m_result);
        }

        PassRefPtr<CSSComputedStyleProperty> release()
        {
            return RefPtr<CSSComputedStyleProperty>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSComputedStyleProperty> result = CSSComputedStyleProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void value(String* value)
    {
        JSONObjectBase::getString("value", value);
    }
};

/* CSS style representation. */
class CSSStyle : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CssPropertiesSet = 1 << 0,
        ShorthandEntriesSet = 1 << 1,
        AllFieldsSet = (CssPropertiesSet | ShorthandEntriesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSStyle*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CSSStyle;
    public:

        Builder<STATE | CssPropertiesSet>& setCssProperties(PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSProperty> > value)
        {
            static_assert(!(STATE & CssPropertiesSet), "property cssProperties should not be set yet");
            m_result->setValue("cssProperties", value);
            return castState<CssPropertiesSet>();
        }

        Builder<STATE | ShorthandEntriesSet>& setShorthandEntries(PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::ShorthandEntry> > value)
        {
            static_assert(!(STATE & ShorthandEntriesSet), "property shorthandEntries should not be set yet");
            m_result->setValue("shorthandEntries", value);
            return castState<ShorthandEntriesSet>();
        }

        operator RefPtr<CSSStyle>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CSSStyle) == sizeof(JSONObject), "CSSStyle should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CSSStyle>*>(&m_result);
        }

        PassRefPtr<CSSStyle> release()
        {
            return RefPtr<CSSStyle>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyle> result = CSSStyle::create()
     *     .setCssProperties(...)
     *     .setShorthandEntries(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setStyleSheetId(const TypeBuilder::CSS::StyleSheetId& value)
    {
        this->setString("styleSheetId", value);
    }

    void setCssText(const String& value)
    {
        this->setString("cssText", value);
    }

    void setRange(PassRefPtr<TypeBuilder::CSS::SourceRange> value)
    {
        this->setValue("range", value);
    }
};

/* CSS property declaration data. */
class CSSProperty : public JSONObject {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSProperty*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CSSProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<CSSProperty>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CSSProperty) == sizeof(JSONObject), "CSSProperty should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CSSProperty>*>(&m_result);
        }

        PassRefPtr<CSSProperty> release()
        {
            return RefPtr<CSSProperty>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSProperty> result = CSSProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void value(String* value)
    {
        JSONObjectBase::getString("value", value);
    }

    void setImportant(bool value)
    {
        this->setBoolean("important", value);
    }

    void setImplicit(bool value)
    {
        this->setBoolean("implicit", value);
    }

    void setText(const String& value)
    {
        this->setString("text", value);
    }

    void setParsedOk(bool value)
    {
        this->setBoolean("parsedOk", value);
    }

    void setDisabled(bool value)
    {
        this->setBoolean("disabled", value);
    }

    void setRange(PassRefPtr<TypeBuilder::CSS::SourceRange> value)
    {
        this->setValue("range", value);
    }

    // Property names for type generated as open.
    static const char Name[];
    static const char Value[];
    static const char Important[];
    static const char Implicit[];
    static const char Text[];
    static const char ParsedOk[];
    static const char Disabled[];
    static const char Range[];
};

/* CSS media rule descriptor. */
class CSSMedia : public JSONObjectBase {
public:
    // Named after property name 'source' while generating CSSMedia.
    struct Source {
        enum Enum {
            MediaRule = 80,
            ImportRule = 81,
            LinkedSheet = 82,
            InlineSheet = 83,
        };
    }; // struct Source

    enum {
        NoFieldsSet = 0,
        TextSet = 1 << 0,
        SourceSet = 1 << 1,
        AllFieldsSet = (TextSet | SourceSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSMedia*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CSSMedia;
    public:

        Builder<STATE | TextSet>& setText(const String& value)
        {
            static_assert(!(STATE & TextSet), "property text should not be set yet");
            m_result->setString("text", value);
            return castState<TextSet>();
        }

        Builder<STATE | SourceSet>& setSource(Source::Enum value)
        {
            static_assert(!(STATE & SourceSet), "property source should not be set yet");
            m_result->setString("source", TypeBuilder::getEnumConstantValue(value));
            return castState<SourceSet>();
        }

        operator RefPtr<CSSMedia>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CSSMedia) == sizeof(JSONObject), "CSSMedia should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CSSMedia>*>(&m_result);
        }

        PassRefPtr<CSSMedia> release()
        {
            return RefPtr<CSSMedia>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSMedia> result = CSSMedia::create()
     *     .setText(...)
     *     .setSource(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void text(String* value)
    {
        JSONObjectBase::getString("text", value);
    }

    void setSourceURL(const String& value)
    {
        this->setString("sourceURL", value);
    }

    void setRange(PassRefPtr<TypeBuilder::CSS::SourceRange> value)
    {
        this->setValue("range", value);
    }

    void setParentStyleSheetId(const TypeBuilder::CSS::StyleSheetId& value)
    {
        this->setString("parentStyleSheetId", value);
    }

    void setMediaList(PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::MediaQuery> > value)
    {
        this->setValue("mediaList", value);
    }
};

/* Media query descriptor. */
class MediaQuery : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ExpressionsSet = 1 << 0,
        ActiveSet = 1 << 1,
        AllFieldsSet = (ExpressionsSet | ActiveSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*MediaQuery*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class MediaQuery;
    public:

        Builder<STATE | ExpressionsSet>& setExpressions(PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::MediaQueryExpression> > value)
        {
            static_assert(!(STATE & ExpressionsSet), "property expressions should not be set yet");
            m_result->setValue("expressions", value);
            return castState<ExpressionsSet>();
        }

        Builder<STATE | ActiveSet>& setActive(bool value)
        {
            static_assert(!(STATE & ActiveSet), "property active should not be set yet");
            m_result->setBoolean("active", value);
            return castState<ActiveSet>();
        }

        operator RefPtr<MediaQuery>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(MediaQuery) == sizeof(JSONObject), "MediaQuery should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<MediaQuery>*>(&m_result);
        }

        PassRefPtr<MediaQuery> release()
        {
            return RefPtr<MediaQuery>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<MediaQuery> result = MediaQuery::create()
     *     .setExpressions(...)
     *     .setActive(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void active(bool* value)
    {
        JSONObjectBase::getBoolean("active", value);
    }
};

/* Media query expression descriptor. */
class MediaQueryExpression : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ValueSet = 1 << 0,
        UnitSet = 1 << 1,
        FeatureSet = 1 << 2,
        AllFieldsSet = (ValueSet | UnitSet | FeatureSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*MediaQueryExpression*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class MediaQueryExpression;
    public:

        Builder<STATE | ValueSet>& setValue(double value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setNumber("value", value);
            return castState<ValueSet>();
        }

        Builder<STATE | UnitSet>& setUnit(const String& value)
        {
            static_assert(!(STATE & UnitSet), "property unit should not be set yet");
            m_result->setString("unit", value);
            return castState<UnitSet>();
        }

        Builder<STATE | FeatureSet>& setFeature(const String& value)
        {
            static_assert(!(STATE & FeatureSet), "property feature should not be set yet");
            m_result->setString("feature", value);
            return castState<FeatureSet>();
        }

        operator RefPtr<MediaQueryExpression>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(MediaQueryExpression) == sizeof(JSONObject), "MediaQueryExpression should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<MediaQueryExpression>*>(&m_result);
        }

        PassRefPtr<MediaQueryExpression> release()
        {
            return RefPtr<MediaQueryExpression>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<MediaQueryExpression> result = MediaQueryExpression::create()
     *     .setValue(...)
     *     .setUnit(...)
     *     .setFeature(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void value(double* value)
    {
        JSONObjectBase::getNumber("value", value);
    }

    void unit(String* value)
    {
        JSONObjectBase::getString("unit", value);
    }

    void feature(String* value)
    {
        JSONObjectBase::getString("feature", value);
    }

    void setValueRange(PassRefPtr<TypeBuilder::CSS::SourceRange> value)
    {
        this->setValue("valueRange", value);
    }

    void setComputedLength(double value)
    {
        this->setNumber("computedLength", value);
    }
};

/* Information about amount of glyphs that were rendered with given font. */
class PlatformFontUsage : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FamilyNameSet = 1 << 0,
        GlyphCountSet = 1 << 1,
        AllFieldsSet = (FamilyNameSet | GlyphCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PlatformFontUsage*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class PlatformFontUsage;
    public:

        Builder<STATE | FamilyNameSet>& setFamilyName(const String& value)
        {
            static_assert(!(STATE & FamilyNameSet), "property familyName should not be set yet");
            m_result->setString("familyName", value);
            return castState<FamilyNameSet>();
        }

        Builder<STATE | GlyphCountSet>& setGlyphCount(double value)
        {
            static_assert(!(STATE & GlyphCountSet), "property glyphCount should not be set yet");
            m_result->setNumber("glyphCount", value);
            return castState<GlyphCountSet>();
        }

        operator RefPtr<PlatformFontUsage>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(PlatformFontUsage) == sizeof(JSONObject), "PlatformFontUsage should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<PlatformFontUsage>*>(&m_result);
        }

        PassRefPtr<PlatformFontUsage> release()
        {
            return RefPtr<PlatformFontUsage>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PlatformFontUsage> result = PlatformFontUsage::create()
     *     .setFamilyName(...)
     *     .setGlyphCount(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void familyName(String* value)
    {
        JSONObjectBase::getString("familyName", value);
    }

    void glyphCount(double* value)
    {
        JSONObjectBase::getNumber("glyphCount", value);
    }
};

} // CSS

namespace Timeline {
/* Timeline record contains information about the recorded activity. */
class TimelineEvent : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        DataSet = 1 << 1,
        StartTimeSet = 1 << 2,
        AllFieldsSet = (TypeSet | DataSet | StartTimeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*TimelineEvent*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class TimelineEvent;
    public:

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | DataSet>& setData(PassRefPtr<JSONObject> value)
        {
            static_assert(!(STATE & DataSet), "property data should not be set yet");
            m_result->setValue("data", value);
            return castState<DataSet>();
        }

        Builder<STATE | StartTimeSet>& setStartTime(double value)
        {
            static_assert(!(STATE & StartTimeSet), "property startTime should not be set yet");
            m_result->setNumber("startTime", value);
            return castState<StartTimeSet>();
        }

        operator RefPtr<TimelineEvent>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(TimelineEvent) == sizeof(JSONObject), "TimelineEvent should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<TimelineEvent>*>(&m_result);
        }

        PassRefPtr<TimelineEvent> release()
        {
            return RefPtr<TimelineEvent>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<TimelineEvent> result = TimelineEvent::create()
     *     .setType(...)
     *     .setData(...)
     *     .setStartTime(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void type(String* value)
    {
        JSONObjectBase::getString("type", value);
    }

    void startTime(double* value)
    {
        JSONObjectBase::getNumber("startTime", value);
    }

    void setEndTime(double value)
    {
        this->setNumber("endTime", value);
    }

    void setChildren(PassRefPtr<TypeBuilder::Array<TypeBuilder::Timeline::TimelineEvent> > value)
    {
        this->setValue("children", value);
    }

    void setThread(const String& value)
    {
        this->setString("thread", value);
    }

    void setStackTrace(PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue("stackTrace", value);
    }

    void setFrameId(const String& value)
    {
        this->setString("frameId", value);
    }
};

} // Timeline

namespace Debugger {
/* Location in the source code. */
class Location : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ScriptIdSet = 1 << 0,
        LineNumberSet = 1 << 1,
        AllFieldsSet = (ScriptIdSet | LineNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Location*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Location;
    public:

        Builder<STATE | ScriptIdSet>& setScriptId(const TypeBuilder::Debugger::ScriptId& value)
        {
            static_assert(!(STATE & ScriptIdSet), "property scriptId should not be set yet");
            m_result->setString("scriptId", value);
            return castState<ScriptIdSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        operator RefPtr<Location>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Location) == sizeof(JSONObject), "Location should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Location>*>(&m_result);
        }

        PassRefPtr<Location> release()
        {
            return RefPtr<Location>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Location> result = Location::create()
     *     .setScriptId(...)
     *     .setLineNumber(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void scriptId(TypeBuilder::Debugger::ScriptId* value)
    {
        JSONObjectBase::getString("scriptId", value);
    }

    void lineNumber(int* value)
    {
        JSONObjectBase::getNumber("lineNumber", value);
    }

    void setColumnNumber(int value)
    {
        this->setNumber("columnNumber", value);
    }
    static PassRefPtr<Location> runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(object.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(Location) == sizeof(JSONObjectBase), "Location should be the same size as JSONObjectBase");
        return static_cast<Location*>(static_cast<JSONObjectBase*>(object.get()));
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* Information about the function. */
class FunctionDetails : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FunctionNameSet = 1 << 0,
        IsGeneratorSet = 1 << 1,
        AllFieldsSet = (FunctionNameSet | IsGeneratorSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*FunctionDetails*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class FunctionDetails;
    public:

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            static_assert(!(STATE & FunctionNameSet), "property functionName should not be set yet");
            m_result->setString("functionName", value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | IsGeneratorSet>& setIsGenerator(bool value)
        {
            static_assert(!(STATE & IsGeneratorSet), "property isGenerator should not be set yet");
            m_result->setBoolean("isGenerator", value);
            return castState<IsGeneratorSet>();
        }

        operator RefPtr<FunctionDetails>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(FunctionDetails) == sizeof(JSONObject), "FunctionDetails should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<FunctionDetails>*>(&m_result);
        }

        PassRefPtr<FunctionDetails> release()
        {
            return RefPtr<FunctionDetails>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FunctionDetails> result = FunctionDetails::create()
     *     .setFunctionName(...)
     *     .setIsGenerator(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void functionName(String* value)
    {
        JSONObjectBase::getString("functionName", value);
    }

    void isGenerator(bool* value)
    {
        JSONObjectBase::getBoolean("isGenerator", value);
    }

    void setLocation(PassRefPtr<TypeBuilder::Debugger::Location> value)
    {
        this->setValue("location", value);
    }

    void setScopeChain(PassRefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Scope> > value)
    {
        this->setValue("scopeChain", value);
    }
    static PassRefPtr<FunctionDetails> runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(object.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(FunctionDetails) == sizeof(JSONObjectBase), "FunctionDetails should be the same size as JSONObjectBase");
        return static_cast<FunctionDetails*>(static_cast<JSONObjectBase*>(object.get()));
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* Information about the generator object. */
class GeneratorObjectDetails : public JSONObjectBase {
public:
    // Named after property name 'status' while generating GeneratorObjectDetails.
    struct Status {
        enum Enum {
            Running = 84,
            Suspended = 85,
            Closed = 86,
        };
#if ENABLE(ASSERT)
        static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
    }; // struct Status

    enum {
        NoFieldsSet = 0,
        FunctionSet = 1 << 0,
        FunctionNameSet = 1 << 1,
        StatusSet = 1 << 2,
        AllFieldsSet = (FunctionSet | FunctionNameSet | StatusSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*GeneratorObjectDetails*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class GeneratorObjectDetails;
    public:

        Builder<STATE | FunctionSet>& setFunction(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
        {
            static_assert(!(STATE & FunctionSet), "property function should not be set yet");
            m_result->setValue("function", value);
            return castState<FunctionSet>();
        }

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            static_assert(!(STATE & FunctionNameSet), "property functionName should not be set yet");
            m_result->setString("functionName", value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | StatusSet>& setStatus(Status::Enum value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setString("status", TypeBuilder::getEnumConstantValue(value));
            return castState<StatusSet>();
        }

        operator RefPtr<GeneratorObjectDetails>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(GeneratorObjectDetails) == sizeof(JSONObject), "GeneratorObjectDetails should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<GeneratorObjectDetails>*>(&m_result);
        }

        PassRefPtr<GeneratorObjectDetails> release()
        {
            return RefPtr<GeneratorObjectDetails>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<GeneratorObjectDetails> result = GeneratorObjectDetails::create()
     *     .setFunction(...)
     *     .setFunctionName(...)
     *     .setStatus(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void functionName(String* value)
    {
        JSONObjectBase::getString("functionName", value);
    }

    void setLocation(PassRefPtr<TypeBuilder::Debugger::Location> value)
    {
        this->setValue("location", value);
    }
    static PassRefPtr<GeneratorObjectDetails> runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(object.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(GeneratorObjectDetails) == sizeof(JSONObjectBase), "GeneratorObjectDetails should be the same size as JSONObjectBase");
        return static_cast<GeneratorObjectDetails*>(static_cast<JSONObjectBase*>(object.get()));
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* Collection entry. */
class CollectionEntry : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ValueSet = 1 << 0,
        AllFieldsSet = (ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CollectionEntry*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CollectionEntry;
    public:

        Builder<STATE | ValueSet>& setValue(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<CollectionEntry>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CollectionEntry) == sizeof(JSONObject), "CollectionEntry should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CollectionEntry>*>(&m_result);
        }

        PassRefPtr<CollectionEntry> release()
        {
            return RefPtr<CollectionEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CollectionEntry> result = CollectionEntry::create()
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setKey(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue("key", value);
    }
    static PassRefPtr<CollectionEntry> runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(object.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(CollectionEntry) == sizeof(JSONObjectBase), "CollectionEntry should be the same size as JSONObjectBase");
        return static_cast<CollectionEntry*>(static_cast<JSONObjectBase*>(object.get()));
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* JavaScript call frame. Array of call frames form the call stack. */
class CallFrame : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CallFrameIdSet = 1 << 0,
        FunctionNameSet = 1 << 1,
        LocationSet = 1 << 2,
        ScopeChainSet = 1 << 3,
        ThisSet = 1 << 4,
        AllFieldsSet = (CallFrameIdSet | FunctionNameSet | LocationSet | ScopeChainSet | ThisSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CallFrame*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CallFrame;
    public:

        Builder<STATE | CallFrameIdSet>& setCallFrameId(const TypeBuilder::Debugger::CallFrameId& value)
        {
            static_assert(!(STATE & CallFrameIdSet), "property callFrameId should not be set yet");
            m_result->setString("callFrameId", value);
            return castState<CallFrameIdSet>();
        }

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            static_assert(!(STATE & FunctionNameSet), "property functionName should not be set yet");
            m_result->setString("functionName", value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | LocationSet>& setLocation(PassRefPtr<TypeBuilder::Debugger::Location> value)
        {
            static_assert(!(STATE & LocationSet), "property location should not be set yet");
            m_result->setValue("location", value);
            return castState<LocationSet>();
        }

        Builder<STATE | ScopeChainSet>& setScopeChain(PassRefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Scope> > value)
        {
            static_assert(!(STATE & ScopeChainSet), "property scopeChain should not be set yet");
            m_result->setValue("scopeChain", value);
            return castState<ScopeChainSet>();
        }

        Builder<STATE | ThisSet>& setThis(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
        {
            static_assert(!(STATE & ThisSet), "property this should not be set yet");
            m_result->setValue("this", value);
            return castState<ThisSet>();
        }

        operator RefPtr<CallFrame>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CallFrame) == sizeof(JSONObject), "CallFrame should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CallFrame>*>(&m_result);
        }

        PassRefPtr<CallFrame> release()
        {
            return RefPtr<CallFrame>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallFrame> result = CallFrame::create()
     *     .setCallFrameId(...)
     *     .setFunctionName(...)
     *     .setLocation(...)
     *     .setScopeChain(...)
     *     .setThis(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void callFrameId(TypeBuilder::Debugger::CallFrameId* value)
    {
        JSONObjectBase::getString("callFrameId", value);
    }

    void functionName(String* value)
    {
        JSONObjectBase::getString("functionName", value);
    }

    void setFunctionLocation(PassRefPtr<TypeBuilder::Debugger::Location> value)
    {
        this->setValue("functionLocation", value);
    }

    void setReturnValue(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue("returnValue", value);
    }
    static PassRefPtr<CallFrame> runtimeCast(PassRefPtr<JSONValue> value)
    {
        RefPtr<JSONObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if ENABLE(ASSERT)
        assertCorrectValue(object.get());
#endif  // ENABLE(ASSERT)
        static_assert(sizeof(CallFrame) == sizeof(JSONObjectBase), "CallFrame should be the same size as JSONObjectBase");
        return static_cast<CallFrame*>(static_cast<JSONObjectBase*>(object.get()));
    }

#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* JavaScript call stack, including async stack traces. */
class StackTrace : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CallFramesSet = 1 << 0,
        AllFieldsSet = (CallFramesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*StackTrace*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class StackTrace;
    public:

        Builder<STATE | CallFramesSet>& setCallFrames(PassRefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > value)
        {
            static_assert(!(STATE & CallFramesSet), "property callFrames should not be set yet");
            m_result->setValue("callFrames", value);
            return castState<CallFramesSet>();
        }

        operator RefPtr<StackTrace>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(StackTrace) == sizeof(JSONObject), "StackTrace should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<StackTrace>*>(&m_result);
        }

        PassRefPtr<StackTrace> release()
        {
            return RefPtr<StackTrace>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<StackTrace> result = StackTrace::create()
     *     .setCallFrames(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setDescription(const String& value)
    {
        this->setString("description", value);
    }

    void setAsyncStackTrace(PassRefPtr<TypeBuilder::Debugger::StackTrace> value)
    {
        this->setValue("asyncStackTrace", value);
    }
};

/* Scope description. */
class Scope : public JSONObjectBase {
public:
    // Named after property name 'type' while generating Scope.
    struct Type {
        enum Enum {
            Global = 87,
            Local = 88,
            With = 89,
            Closure = 90,
            Catch = 91,
            Block = 92,
            Script = 59,
        };
#if ENABLE(ASSERT)
        static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        ObjectSet = 1 << 1,
        AllFieldsSet = (TypeSet | ObjectSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Scope*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Scope;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | ObjectSet>& setObject(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
        {
            static_assert(!(STATE & ObjectSet), "property object should not be set yet");
            m_result->setValue("object", value);
            return castState<ObjectSet>();
        }

        operator RefPtr<Scope>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Scope) == sizeof(JSONObject), "Scope should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Scope>*>(&m_result);
        }

        PassRefPtr<Scope> release()
        {
            return RefPtr<Scope>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Scope> result = Scope::create()
     *     .setType(...)
     *     .setObject(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
#if ENABLE(ASSERT)
    static void assertCorrectValue(JSONValue* value);
#endif  // ENABLE(ASSERT)
};

/* Detailed information on exception (or error) that was thrown during script compilation or execution. */
class ExceptionDetails : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TextSet = 1 << 0,
        AllFieldsSet = (TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ExceptionDetails*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ExceptionDetails;
    public:

        Builder<STATE | TextSet>& setText(const String& value)
        {
            static_assert(!(STATE & TextSet), "property text should not be set yet");
            m_result->setString("text", value);
            return castState<TextSet>();
        }

        operator RefPtr<ExceptionDetails>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ExceptionDetails) == sizeof(JSONObject), "ExceptionDetails should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ExceptionDetails>*>(&m_result);
        }

        PassRefPtr<ExceptionDetails> release()
        {
            return RefPtr<ExceptionDetails>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ExceptionDetails> result = ExceptionDetails::create()
     *     .setText(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void text(String* value)
    {
        JSONObjectBase::getString("text", value);
    }

    void setUrl(const String& value)
    {
        this->setString("url", value);
    }

    void setScriptId(const String& value)
    {
        this->setString("scriptId", value);
    }

    void setLine(int value)
    {
        this->setNumber("line", value);
    }

    void setColumn(int value)
    {
        this->setNumber("column", value);
    }

    void setStackTrace(PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue("stackTrace", value);
    }
};

/* Error data for setScriptSource command. compileError is a case type for uncompilable script source error. */
class SetScriptSourceError : public JSONObjectBase {
public:
    // Named after property name 'compileError' while generating SetScriptSourceError.
    class CompileError : public JSONObjectBase {
    public:
        enum {
            NoFieldsSet = 0,
            MessageSet = 1 << 0,
            LineNumberSet = 1 << 1,
            ColumnNumberSet = 1 << 2,
            AllFieldsSet = (MessageSet | LineNumberSet | ColumnNumberSet)
        };

        template<int STATE>
        class Builder {
        private:
            RefPtr<JSONObject> m_result;

            template<int STEP> Builder<STATE | STEP>& castState()
            {
                return *reinterpret_cast<Builder<STATE | STEP>*>(this);
            }

            Builder(PassRefPtr</*CompileError*/JSONObject> ptr)
            {
                static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
                m_result = ptr;
            }
            friend class CompileError;
        public:
    
            Builder<STATE | MessageSet>& setMessage(const String& value)
            {
                static_assert(!(STATE & MessageSet), "property message should not be set yet");
                m_result->setString("message", value);
                return castState<MessageSet>();
            }
    
            Builder<STATE | LineNumberSet>& setLineNumber(int value)
            {
                static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
                m_result->setNumber("lineNumber", value);
                return castState<LineNumberSet>();
            }
    
            Builder<STATE | ColumnNumberSet>& setColumnNumber(int value)
            {
                static_assert(!(STATE & ColumnNumberSet), "property columnNumber should not be set yet");
                m_result->setNumber("columnNumber", value);
                return castState<ColumnNumberSet>();
            }
    
            operator RefPtr<CompileError>& ()
            {
                static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
                static_assert(sizeof(CompileError) == sizeof(JSONObject), "CompileError should be the same size as JSONObject");
                return *reinterpret_cast<RefPtr<CompileError>*>(&m_result);
            }

            PassRefPtr<CompileError> release()
            {
                return RefPtr<CompileError>(*this).release();
            }
        };

        /*
         * Synthetic constructor:
         * RefPtr<CompileError> result = CompileError::create()
         *     .setMessage(...)
         *     .setLineNumber(...)
         *     .setColumnNumber(...);
         */
        static Builder<NoFieldsSet> create()
        {
            return Builder<NoFieldsSet>(JSONObject::create());
        }
        typedef TypeBuilder::StructItemTraits ItemTraits;

        void message(String* value)
        {
            JSONObjectBase::getString("message", value);
        }

        void lineNumber(int* value)
        {
            JSONObjectBase::getNumber("lineNumber", value);
        }

        void columnNumber(int* value)
        {
            JSONObjectBase::getNumber("columnNumber", value);
        }
    };

    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SetScriptSourceError*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class SetScriptSourceError;
    public:

        operator RefPtr<SetScriptSourceError>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(SetScriptSourceError) == sizeof(JSONObject), "SetScriptSourceError should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<SetScriptSourceError>*>(&m_result);
        }

        PassRefPtr<SetScriptSourceError> release()
        {
            return RefPtr<SetScriptSourceError>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SetScriptSourceError> result = SetScriptSourceError::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setCompileError(PassRefPtr<CompileError> value)
    {
        this->setValue("compileError", value);
    }
};

/* Information about the promise. All fields but id are optional and if present they reflect the new state of the property on the promise with given id. */
class PromiseDetails : public JSONObjectBase {
public:
    // Named after property name 'status' while generating PromiseDetails.
    struct Status {
        enum Enum {
            Pending = 93,
            Resolved = 94,
            Rejected = 95,
        };
    }; // struct Status

    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        AllFieldsSet = (IdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PromiseDetails*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class PromiseDetails;
    public:

        Builder<STATE | IdSet>& setId(int value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setNumber("id", value);
            return castState<IdSet>();
        }

        operator RefPtr<PromiseDetails>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(PromiseDetails) == sizeof(JSONObject), "PromiseDetails should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<PromiseDetails>*>(&m_result);
        }

        PassRefPtr<PromiseDetails> release()
        {
            return RefPtr<PromiseDetails>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PromiseDetails> result = PromiseDetails::create()
     *     .setId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void id(int* value)
    {
        JSONObjectBase::getNumber("id", value);
    }

    void setStatus(Status::Enum value)
    {
        this->setString("status", TypeBuilder::getEnumConstantValue(value));
    }

    void setParentId(int value)
    {
        this->setNumber("parentId", value);
    }

    void setCallFrame(PassRefPtr<TypeBuilder::Console::CallFrame> value)
    {
        this->setValue("callFrame", value);
    }

    void setCreationTime(double value)
    {
        this->setNumber("creationTime", value);
    }

    void setSettlementTime(double value)
    {
        this->setNumber("settlementTime", value);
    }

    void setCreationStack(PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue("creationStack", value);
    }

    void setAsyncCreationStack(PassRefPtr<TypeBuilder::Console::AsyncStackTrace> value)
    {
        this->setValue("asyncCreationStack", value);
    }

    void setSettlementStack(PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue("settlementStack", value);
    }

    void setAsyncSettlementStack(PassRefPtr<TypeBuilder::Console::AsyncStackTrace> value)
    {
        this->setValue("asyncSettlementStack", value);
    }
};

/* Information about the async operation. */
class AsyncOperation : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        DescriptionSet = 1 << 1,
        AllFieldsSet = (IdSet | DescriptionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*AsyncOperation*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class AsyncOperation;
    public:

        Builder<STATE | IdSet>& setId(int value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setNumber("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | DescriptionSet>& setDescription(const String& value)
        {
            static_assert(!(STATE & DescriptionSet), "property description should not be set yet");
            m_result->setString("description", value);
            return castState<DescriptionSet>();
        }

        operator RefPtr<AsyncOperation>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(AsyncOperation) == sizeof(JSONObject), "AsyncOperation should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<AsyncOperation>*>(&m_result);
        }

        PassRefPtr<AsyncOperation> release()
        {
            return RefPtr<AsyncOperation>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<AsyncOperation> result = AsyncOperation::create()
     *     .setId(...)
     *     .setDescription(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void id(int* value)
    {
        JSONObjectBase::getNumber("id", value);
    }

    void description(String* value)
    {
        JSONObjectBase::getString("description", value);
    }

    void setStackTrace(PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue("stackTrace", value);
    }

    void setAsyncStackTrace(PassRefPtr<TypeBuilder::Console::AsyncStackTrace> value)
    {
        this->setValue("asyncStackTrace", value);
    }
};

/* Search match for resource. */
class SearchMatch : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LineNumberSet = 1 << 0,
        LineContentSet = 1 << 1,
        AllFieldsSet = (LineNumberSet | LineContentSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SearchMatch*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class SearchMatch;
    public:

        Builder<STATE | LineNumberSet>& setLineNumber(double value)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | LineContentSet>& setLineContent(const String& value)
        {
            static_assert(!(STATE & LineContentSet), "property lineContent should not be set yet");
            m_result->setString("lineContent", value);
            return castState<LineContentSet>();
        }

        operator RefPtr<SearchMatch>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(SearchMatch) == sizeof(JSONObject), "SearchMatch should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<SearchMatch>*>(&m_result);
        }

        PassRefPtr<SearchMatch> release()
        {
            return RefPtr<SearchMatch>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SearchMatch> result = SearchMatch::create()
     *     .setLineNumber(...)
     *     .setLineContent(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void lineNumber(double* value)
    {
        JSONObjectBase::getNumber("lineNumber", value);
    }

    void lineContent(String* value)
    {
        JSONObjectBase::getString("lineContent", value);
    }
};

} // Debugger

namespace DOMDebugger {
/* DOM breakpoint type. */
struct DOMBreakpointType {
    enum Enum {
        Subtree_modified = 96,
        Attribute_modified = 97,
        Node_removed = 98,
    };
}; // struct DOMBreakpointType

/* Object event listener. */
class EventListener : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        UseCaptureSet = 1 << 1,
        LocationSet = 1 << 2,
        AllFieldsSet = (TypeSet | UseCaptureSet | LocationSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*EventListener*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class EventListener;
    public:

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | UseCaptureSet>& setUseCapture(bool value)
        {
            static_assert(!(STATE & UseCaptureSet), "property useCapture should not be set yet");
            m_result->setBoolean("useCapture", value);
            return castState<UseCaptureSet>();
        }

        Builder<STATE | LocationSet>& setLocation(PassRefPtr<TypeBuilder::Debugger::Location> value)
        {
            static_assert(!(STATE & LocationSet), "property location should not be set yet");
            m_result->setValue("location", value);
            return castState<LocationSet>();
        }

        operator RefPtr<EventListener>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(EventListener) == sizeof(JSONObject), "EventListener should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<EventListener>*>(&m_result);
        }

        PassRefPtr<EventListener> release()
        {
            return RefPtr<EventListener>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<EventListener> result = EventListener::create()
     *     .setType(...)
     *     .setUseCapture(...)
     *     .setLocation(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void type(String* value)
    {
        JSONObjectBase::getString("type", value);
    }

    void useCapture(bool* value)
    {
        JSONObjectBase::getBoolean("useCapture", value);
    }

    void setHandler(PassRefPtr<TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue("handler", value);
    }
};

} // DOMDebugger

namespace Profiler {
/* CPU Profile node. Holds callsite information, execution statistics and child nodes. */
class CPUProfileNode : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FunctionNameSet = 1 << 0,
        ScriptIdSet = 1 << 1,
        UrlSet = 1 << 2,
        LineNumberSet = 1 << 3,
        ColumnNumberSet = 1 << 4,
        HitCountSet = 1 << 5,
        CallUIDSet = 1 << 6,
        ChildrenSet = 1 << 7,
        DeoptReasonSet = 1 << 8,
        IdSet = 1 << 9,
        PositionTicksSet = 1 << 10,
        AllFieldsSet = (FunctionNameSet | ScriptIdSet | UrlSet | LineNumberSet | ColumnNumberSet | HitCountSet | CallUIDSet | ChildrenSet | DeoptReasonSet | IdSet | PositionTicksSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CPUProfileNode*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CPUProfileNode;
    public:

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            static_assert(!(STATE & FunctionNameSet), "property functionName should not be set yet");
            m_result->setString("functionName", value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | ScriptIdSet>& setScriptId(const TypeBuilder::Debugger::ScriptId& value)
        {
            static_assert(!(STATE & ScriptIdSet), "property scriptId should not be set yet");
            m_result->setString("scriptId", value);
            return castState<ScriptIdSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(int value)
        {
            static_assert(!(STATE & ColumnNumberSet), "property columnNumber should not be set yet");
            m_result->setNumber("columnNumber", value);
            return castState<ColumnNumberSet>();
        }

        Builder<STATE | HitCountSet>& setHitCount(int value)
        {
            static_assert(!(STATE & HitCountSet), "property hitCount should not be set yet");
            m_result->setNumber("hitCount", value);
            return castState<HitCountSet>();
        }

        Builder<STATE | CallUIDSet>& setCallUID(double value)
        {
            static_assert(!(STATE & CallUIDSet), "property callUID should not be set yet");
            m_result->setNumber("callUID", value);
            return castState<CallUIDSet>();
        }

        Builder<STATE | ChildrenSet>& setChildren(PassRefPtr<TypeBuilder::Array<TypeBuilder::Profiler::CPUProfileNode> > value)
        {
            static_assert(!(STATE & ChildrenSet), "property children should not be set yet");
            m_result->setValue("children", value);
            return castState<ChildrenSet>();
        }

        Builder<STATE | DeoptReasonSet>& setDeoptReason(const String& value)
        {
            static_assert(!(STATE & DeoptReasonSet), "property deoptReason should not be set yet");
            m_result->setString("deoptReason", value);
            return castState<DeoptReasonSet>();
        }

        Builder<STATE | IdSet>& setId(int value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setNumber("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | PositionTicksSet>& setPositionTicks(PassRefPtr<TypeBuilder::Array<TypeBuilder::Profiler::PositionTickInfo> > value)
        {
            static_assert(!(STATE & PositionTicksSet), "property positionTicks should not be set yet");
            m_result->setValue("positionTicks", value);
            return castState<PositionTicksSet>();
        }

        operator RefPtr<CPUProfileNode>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CPUProfileNode) == sizeof(JSONObject), "CPUProfileNode should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CPUProfileNode>*>(&m_result);
        }

        PassRefPtr<CPUProfileNode> release()
        {
            return RefPtr<CPUProfileNode>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CPUProfileNode> result = CPUProfileNode::create()
     *     .setFunctionName(...)
     *     .setScriptId(...)
     *     .setUrl(...)
     *     .setLineNumber(...)
     *     .setColumnNumber(...)
     *     .setHitCount(...)
     *     .setCallUID(...)
     *     .setChildren(...)
     *     .setDeoptReason(...)
     *     .setId(...)
     *     .setPositionTicks(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void functionName(String* value)
    {
        JSONObjectBase::getString("functionName", value);
    }

    void scriptId(TypeBuilder::Debugger::ScriptId* value)
    {
        JSONObjectBase::getString("scriptId", value);
    }

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }

    void lineNumber(int* value)
    {
        JSONObjectBase::getNumber("lineNumber", value);
    }

    void columnNumber(int* value)
    {
        JSONObjectBase::getNumber("columnNumber", value);
    }

    void hitCount(int* value)
    {
        JSONObjectBase::getNumber("hitCount", value);
    }

    void callUID(double* value)
    {
        JSONObjectBase::getNumber("callUID", value);
    }

    void deoptReason(String* value)
    {
        JSONObjectBase::getString("deoptReason", value);
    }

    void id(int* value)
    {
        JSONObjectBase::getNumber("id", value);
    }
};

/* Profile. */
class CPUProfile : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        HeadSet = 1 << 0,
        StartTimeSet = 1 << 1,
        EndTimeSet = 1 << 2,
        AllFieldsSet = (HeadSet | StartTimeSet | EndTimeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CPUProfile*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class CPUProfile;
    public:

        Builder<STATE | HeadSet>& setHead(PassRefPtr<TypeBuilder::Profiler::CPUProfileNode> value)
        {
            static_assert(!(STATE & HeadSet), "property head should not be set yet");
            m_result->setValue("head", value);
            return castState<HeadSet>();
        }

        Builder<STATE | StartTimeSet>& setStartTime(double value)
        {
            static_assert(!(STATE & StartTimeSet), "property startTime should not be set yet");
            m_result->setNumber("startTime", value);
            return castState<StartTimeSet>();
        }

        Builder<STATE | EndTimeSet>& setEndTime(double value)
        {
            static_assert(!(STATE & EndTimeSet), "property endTime should not be set yet");
            m_result->setNumber("endTime", value);
            return castState<EndTimeSet>();
        }

        operator RefPtr<CPUProfile>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(CPUProfile) == sizeof(JSONObject), "CPUProfile should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<CPUProfile>*>(&m_result);
        }

        PassRefPtr<CPUProfile> release()
        {
            return RefPtr<CPUProfile>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CPUProfile> result = CPUProfile::create()
     *     .setHead(...)
     *     .setStartTime(...)
     *     .setEndTime(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void startTime(double* value)
    {
        JSONObjectBase::getNumber("startTime", value);
    }

    void endTime(double* value)
    {
        JSONObjectBase::getNumber("endTime", value);
    }

    void setSamples(PassRefPtr<TypeBuilder::Array<int> > value)
    {
        this->setValue("samples", value);
    }

    void setTimestamps(PassRefPtr<TypeBuilder::Array<double> > value)
    {
        this->setValue("timestamps", value);
    }
};

/* Specifies a number of samples attributed to a certain source position. */
class PositionTickInfo : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LineSet = 1 << 0,
        TicksSet = 1 << 1,
        AllFieldsSet = (LineSet | TicksSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PositionTickInfo*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class PositionTickInfo;
    public:

        Builder<STATE | LineSet>& setLine(int value)
        {
            static_assert(!(STATE & LineSet), "property line should not be set yet");
            m_result->setNumber("line", value);
            return castState<LineSet>();
        }

        Builder<STATE | TicksSet>& setTicks(int value)
        {
            static_assert(!(STATE & TicksSet), "property ticks should not be set yet");
            m_result->setNumber("ticks", value);
            return castState<TicksSet>();
        }

        operator RefPtr<PositionTickInfo>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(PositionTickInfo) == sizeof(JSONObject), "PositionTickInfo should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<PositionTickInfo>*>(&m_result);
        }

        PassRefPtr<PositionTickInfo> release()
        {
            return RefPtr<PositionTickInfo>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PositionTickInfo> result = PositionTickInfo::create()
     *     .setLine(...)
     *     .setTicks(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void line(int* value)
    {
        JSONObjectBase::getNumber("line", value);
    }

    void ticks(int* value)
    {
        JSONObjectBase::getNumber("ticks", value);
    }
};

} // Profiler

namespace ServiceWorker {
/* ServiceWorker registration. */
class ServiceWorkerRegistration : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RegistrationIdSet = 1 << 0,
        ScopeURLSet = 1 << 1,
        AllFieldsSet = (RegistrationIdSet | ScopeURLSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ServiceWorkerRegistration*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ServiceWorkerRegistration;
    public:

        Builder<STATE | RegistrationIdSet>& setRegistrationId(const String& value)
        {
            static_assert(!(STATE & RegistrationIdSet), "property registrationId should not be set yet");
            m_result->setString("registrationId", value);
            return castState<RegistrationIdSet>();
        }

        Builder<STATE | ScopeURLSet>& setScopeURL(const String& value)
        {
            static_assert(!(STATE & ScopeURLSet), "property scopeURL should not be set yet");
            m_result->setString("scopeURL", value);
            return castState<ScopeURLSet>();
        }

        operator RefPtr<ServiceWorkerRegistration>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ServiceWorkerRegistration) == sizeof(JSONObject), "ServiceWorkerRegistration should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ServiceWorkerRegistration>*>(&m_result);
        }

        PassRefPtr<ServiceWorkerRegistration> release()
        {
            return RefPtr<ServiceWorkerRegistration>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ServiceWorkerRegistration> result = ServiceWorkerRegistration::create()
     *     .setRegistrationId(...)
     *     .setScopeURL(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void registrationId(String* value)
    {
        JSONObjectBase::getString("registrationId", value);
    }

    void scopeURL(String* value)
    {
        JSONObjectBase::getString("scopeURL", value);
    }

    void setIsDeleted(bool value)
    {
        this->setBoolean("isDeleted", value);
    }
};

struct ServiceWorkerVersionRunningStatus {
    enum Enum {
        Stopped = 99,
        Starting = 100,
        Running = 84,
        Stopping = 101,
    };
}; // struct ServiceWorkerVersionRunningStatus

struct ServiceWorkerVersionStatus {
    enum Enum {
        New = 102,
        Installing = 103,
        Installed = 104,
        Activating = 105,
        Activated = 106,
        Redundant = 107,
    };
}; // struct ServiceWorkerVersionStatus

/* ServiceWorker version. */
class ServiceWorkerVersion : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        VersionIdSet = 1 << 0,
        RegistrationIdSet = 1 << 1,
        ScriptURLSet = 1 << 2,
        RunningStatusSet = 1 << 3,
        StatusSet = 1 << 4,
        AllFieldsSet = (VersionIdSet | RegistrationIdSet | ScriptURLSet | RunningStatusSet | StatusSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ServiceWorkerVersion*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ServiceWorkerVersion;
    public:

        Builder<STATE | VersionIdSet>& setVersionId(const String& value)
        {
            static_assert(!(STATE & VersionIdSet), "property versionId should not be set yet");
            m_result->setString("versionId", value);
            return castState<VersionIdSet>();
        }

        Builder<STATE | RegistrationIdSet>& setRegistrationId(const String& value)
        {
            static_assert(!(STATE & RegistrationIdSet), "property registrationId should not be set yet");
            m_result->setString("registrationId", value);
            return castState<RegistrationIdSet>();
        }

        Builder<STATE | ScriptURLSet>& setScriptURL(const String& value)
        {
            static_assert(!(STATE & ScriptURLSet), "property scriptURL should not be set yet");
            m_result->setString("scriptURL", value);
            return castState<ScriptURLSet>();
        }

        Builder<STATE | RunningStatusSet>& setRunningStatus(TypeBuilder::ServiceWorker::ServiceWorkerVersionRunningStatus::Enum value)
        {
            static_assert(!(STATE & RunningStatusSet), "property runningStatus should not be set yet");
            m_result->setString("runningStatus", TypeBuilder::getEnumConstantValue(value));
            return castState<RunningStatusSet>();
        }

        Builder<STATE | StatusSet>& setStatus(TypeBuilder::ServiceWorker::ServiceWorkerVersionStatus::Enum value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setString("status", TypeBuilder::getEnumConstantValue(value));
            return castState<StatusSet>();
        }

        operator RefPtr<ServiceWorkerVersion>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ServiceWorkerVersion) == sizeof(JSONObject), "ServiceWorkerVersion should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ServiceWorkerVersion>*>(&m_result);
        }

        PassRefPtr<ServiceWorkerVersion> release()
        {
            return RefPtr<ServiceWorkerVersion>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ServiceWorkerVersion> result = ServiceWorkerVersion::create()
     *     .setVersionId(...)
     *     .setRegistrationId(...)
     *     .setScriptURL(...)
     *     .setRunningStatus(...)
     *     .setStatus(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void versionId(String* value)
    {
        JSONObjectBase::getString("versionId", value);
    }

    void registrationId(String* value)
    {
        JSONObjectBase::getString("registrationId", value);
    }

    void scriptURL(String* value)
    {
        JSONObjectBase::getString("scriptURL", value);
    }

    void setScriptLastModified(double value)
    {
        this->setNumber("scriptLastModified", value);
    }

    void setScriptResponseTime(double value)
    {
        this->setNumber("scriptResponseTime", value);
    }

    void setControlledClients(PassRefPtr<TypeBuilder::Array<TypeBuilder::ServiceWorker::TargetID> > value)
    {
        this->setValue("controlledClients", value);
    }
};

/* ServiceWorker error message. */
class ServiceWorkerErrorMessage : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ErrorMessageSet = 1 << 0,
        RegistrationIdSet = 1 << 1,
        VersionIdSet = 1 << 2,
        SourceURLSet = 1 << 3,
        LineNumberSet = 1 << 4,
        ColumnNumberSet = 1 << 5,
        AllFieldsSet = (ErrorMessageSet | RegistrationIdSet | VersionIdSet | SourceURLSet | LineNumberSet | ColumnNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ServiceWorkerErrorMessage*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ServiceWorkerErrorMessage;
    public:

        Builder<STATE | ErrorMessageSet>& setErrorMessage(const String& value)
        {
            static_assert(!(STATE & ErrorMessageSet), "property errorMessage should not be set yet");
            m_result->setString("errorMessage", value);
            return castState<ErrorMessageSet>();
        }

        Builder<STATE | RegistrationIdSet>& setRegistrationId(const String& value)
        {
            static_assert(!(STATE & RegistrationIdSet), "property registrationId should not be set yet");
            m_result->setString("registrationId", value);
            return castState<RegistrationIdSet>();
        }

        Builder<STATE | VersionIdSet>& setVersionId(const String& value)
        {
            static_assert(!(STATE & VersionIdSet), "property versionId should not be set yet");
            m_result->setString("versionId", value);
            return castState<VersionIdSet>();
        }

        Builder<STATE | SourceURLSet>& setSourceURL(const String& value)
        {
            static_assert(!(STATE & SourceURLSet), "property sourceURL should not be set yet");
            m_result->setString("sourceURL", value);
            return castState<SourceURLSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(int value)
        {
            static_assert(!(STATE & ColumnNumberSet), "property columnNumber should not be set yet");
            m_result->setNumber("columnNumber", value);
            return castState<ColumnNumberSet>();
        }

        operator RefPtr<ServiceWorkerErrorMessage>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ServiceWorkerErrorMessage) == sizeof(JSONObject), "ServiceWorkerErrorMessage should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ServiceWorkerErrorMessage>*>(&m_result);
        }

        PassRefPtr<ServiceWorkerErrorMessage> release()
        {
            return RefPtr<ServiceWorkerErrorMessage>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ServiceWorkerErrorMessage> result = ServiceWorkerErrorMessage::create()
     *     .setErrorMessage(...)
     *     .setRegistrationId(...)
     *     .setVersionId(...)
     *     .setSourceURL(...)
     *     .setLineNumber(...)
     *     .setColumnNumber(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void errorMessage(String* value)
    {
        JSONObjectBase::getString("errorMessage", value);
    }

    void registrationId(String* value)
    {
        JSONObjectBase::getString("registrationId", value);
    }

    void versionId(String* value)
    {
        JSONObjectBase::getString("versionId", value);
    }

    void sourceURL(String* value)
    {
        JSONObjectBase::getString("sourceURL", value);
    }

    void lineNumber(int* value)
    {
        JSONObjectBase::getNumber("lineNumber", value);
    }

    void columnNumber(int* value)
    {
        JSONObjectBase::getNumber("columnNumber", value);
    }
};

class TargetInfo : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        TypeSet = 1 << 1,
        TitleSet = 1 << 2,
        UrlSet = 1 << 3,
        AllFieldsSet = (IdSet | TypeSet | TitleSet | UrlSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*TargetInfo*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class TargetInfo;
    public:

        Builder<STATE | IdSet>& setId(const TypeBuilder::ServiceWorker::TargetID& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setString("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            static_assert(!(STATE & TitleSet), "property title should not be set yet");
            m_result->setString("title", value);
            return castState<TitleSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        operator RefPtr<TargetInfo>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(TargetInfo) == sizeof(JSONObject), "TargetInfo should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<TargetInfo>*>(&m_result);
        }

        PassRefPtr<TargetInfo> release()
        {
            return RefPtr<TargetInfo>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<TargetInfo> result = TargetInfo::create()
     *     .setId(...)
     *     .setType(...)
     *     .setTitle(...)
     *     .setUrl(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void id(TypeBuilder::ServiceWorker::TargetID* value)
    {
        JSONObjectBase::getString("id", value);
    }

    void type(String* value)
    {
        JSONObjectBase::getString("type", value);
    }

    void title(String* value)
    {
        JSONObjectBase::getString("title", value);
    }

    void url(String* value)
    {
        JSONObjectBase::getString("url", value);
    }
};

} // ServiceWorker

namespace Input {
class TouchPoint : public JSONObjectBase {
public:
    // Named after property name 'state' while generating TouchPoint.
    struct State {
        enum Enum {
            TouchPressed = 108,
            TouchReleased = 109,
            TouchMoved = 110,
            TouchStationary = 111,
            TouchCancelled = 112,
        };
    }; // struct State

    enum {
        NoFieldsSet = 0,
        StateSet = 1 << 0,
        XSet = 1 << 1,
        YSet = 1 << 2,
        AllFieldsSet = (StateSet | XSet | YSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*TouchPoint*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class TouchPoint;
    public:

        Builder<STATE | StateSet>& setState(State::Enum value)
        {
            static_assert(!(STATE & StateSet), "property state should not be set yet");
            m_result->setString("state", TypeBuilder::getEnumConstantValue(value));
            return castState<StateSet>();
        }

        Builder<STATE | XSet>& setX(int value)
        {
            static_assert(!(STATE & XSet), "property x should not be set yet");
            m_result->setNumber("x", value);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(int value)
        {
            static_assert(!(STATE & YSet), "property y should not be set yet");
            m_result->setNumber("y", value);
            return castState<YSet>();
        }

        operator RefPtr<TouchPoint>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(TouchPoint) == sizeof(JSONObject), "TouchPoint should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<TouchPoint>*>(&m_result);
        }

        PassRefPtr<TouchPoint> release()
        {
            return RefPtr<TouchPoint>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<TouchPoint> result = TouchPoint::create()
     *     .setState(...)
     *     .setX(...)
     *     .setY(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void x(int* value)
    {
        JSONObjectBase::getNumber("x", value);
    }

    void y(int* value)
    {
        JSONObjectBase::getNumber("y", value);
    }

    void setRadiusX(int value)
    {
        this->setNumber("radiusX", value);
    }

    void setRadiusY(int value)
    {
        this->setNumber("radiusY", value);
    }

    void setRotationAngle(double value)
    {
        this->setNumber("rotationAngle", value);
    }

    void setForce(double value)
    {
        this->setNumber("force", value);
    }

    void setId(double value)
    {
        this->setNumber("id", value);
    }
};

struct GestureSourceType {
    enum Enum {
        Default = 113,
        Touch = 114,
        Mouse = 115,
    };
}; // struct GestureSourceType

} // Input

namespace LayerTree {
/* Rectangle where scrolling happens on the main thread. */
class ScrollRect : public JSONObjectBase {
public:
    // Named after property name 'type' while generating ScrollRect.
    struct Type {
        enum Enum {
            RepaintsOnScroll = 116,
            TouchEventHandler = 117,
            WheelEventHandler = 118,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        RectSet = 1 << 0,
        TypeSet = 1 << 1,
        AllFieldsSet = (RectSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ScrollRect*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class ScrollRect;
    public:

        Builder<STATE | RectSet>& setRect(PassRefPtr<TypeBuilder::DOM::Rect> value)
        {
            static_assert(!(STATE & RectSet), "property rect should not be set yet");
            m_result->setValue("rect", value);
            return castState<RectSet>();
        }

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<ScrollRect>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(ScrollRect) == sizeof(JSONObject), "ScrollRect should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<ScrollRect>*>(&m_result);
        }

        PassRefPtr<ScrollRect> release()
        {
            return RefPtr<ScrollRect>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ScrollRect> result = ScrollRect::create()
     *     .setRect(...)
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Serialized fragment of layer picture along with its offset within the layer. */
class PictureTile : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        XSet = 1 << 0,
        YSet = 1 << 1,
        PictureSet = 1 << 2,
        AllFieldsSet = (XSet | YSet | PictureSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PictureTile*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class PictureTile;
    public:

        Builder<STATE | XSet>& setX(double value)
        {
            static_assert(!(STATE & XSet), "property x should not be set yet");
            m_result->setNumber("x", value);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(double value)
        {
            static_assert(!(STATE & YSet), "property y should not be set yet");
            m_result->setNumber("y", value);
            return castState<YSet>();
        }

        Builder<STATE | PictureSet>& setPicture(const String& value)
        {
            static_assert(!(STATE & PictureSet), "property picture should not be set yet");
            m_result->setString("picture", value);
            return castState<PictureSet>();
        }

        operator RefPtr<PictureTile>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(PictureTile) == sizeof(JSONObject), "PictureTile should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<PictureTile>*>(&m_result);
        }

        PassRefPtr<PictureTile> release()
        {
            return RefPtr<PictureTile>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PictureTile> result = PictureTile::create()
     *     .setX(...)
     *     .setY(...)
     *     .setPicture(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void x(double* value)
    {
        JSONObjectBase::getNumber("x", value);
    }

    void y(double* value)
    {
        JSONObjectBase::getNumber("y", value);
    }

    void picture(String* value)
    {
        JSONObjectBase::getString("picture", value);
    }
};

/* Information about a compositing layer. */
class Layer : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LayerIdSet = 1 << 0,
        OffsetXSet = 1 << 1,
        OffsetYSet = 1 << 2,
        WidthSet = 1 << 3,
        HeightSet = 1 << 4,
        PaintCountSet = 1 << 5,
        DrawsContentSet = 1 << 6,
        AllFieldsSet = (LayerIdSet | OffsetXSet | OffsetYSet | WidthSet | HeightSet | PaintCountSet | DrawsContentSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Layer*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Layer;
    public:

        Builder<STATE | LayerIdSet>& setLayerId(const TypeBuilder::LayerTree::LayerId& value)
        {
            static_assert(!(STATE & LayerIdSet), "property layerId should not be set yet");
            m_result->setString("layerId", value);
            return castState<LayerIdSet>();
        }

        Builder<STATE | OffsetXSet>& setOffsetX(double value)
        {
            static_assert(!(STATE & OffsetXSet), "property offsetX should not be set yet");
            m_result->setNumber("offsetX", value);
            return castState<OffsetXSet>();
        }

        Builder<STATE | OffsetYSet>& setOffsetY(double value)
        {
            static_assert(!(STATE & OffsetYSet), "property offsetY should not be set yet");
            m_result->setNumber("offsetY", value);
            return castState<OffsetYSet>();
        }

        Builder<STATE | WidthSet>& setWidth(double value)
        {
            static_assert(!(STATE & WidthSet), "property width should not be set yet");
            m_result->setNumber("width", value);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(double value)
        {
            static_assert(!(STATE & HeightSet), "property height should not be set yet");
            m_result->setNumber("height", value);
            return castState<HeightSet>();
        }

        Builder<STATE | PaintCountSet>& setPaintCount(int value)
        {
            static_assert(!(STATE & PaintCountSet), "property paintCount should not be set yet");
            m_result->setNumber("paintCount", value);
            return castState<PaintCountSet>();
        }

        Builder<STATE | DrawsContentSet>& setDrawsContent(bool value)
        {
            static_assert(!(STATE & DrawsContentSet), "property drawsContent should not be set yet");
            m_result->setBoolean("drawsContent", value);
            return castState<DrawsContentSet>();
        }

        operator RefPtr<Layer>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Layer) == sizeof(JSONObject), "Layer should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Layer>*>(&m_result);
        }

        PassRefPtr<Layer> release()
        {
            return RefPtr<Layer>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Layer> result = Layer::create()
     *     .setLayerId(...)
     *     .setOffsetX(...)
     *     .setOffsetY(...)
     *     .setWidth(...)
     *     .setHeight(...)
     *     .setPaintCount(...)
     *     .setDrawsContent(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void layerId(TypeBuilder::LayerTree::LayerId* value)
    {
        JSONObjectBase::getString("layerId", value);
    }

    void offsetX(double* value)
    {
        JSONObjectBase::getNumber("offsetX", value);
    }

    void offsetY(double* value)
    {
        JSONObjectBase::getNumber("offsetY", value);
    }

    void width(double* value)
    {
        JSONObjectBase::getNumber("width", value);
    }

    void height(double* value)
    {
        JSONObjectBase::getNumber("height", value);
    }

    void paintCount(int* value)
    {
        JSONObjectBase::getNumber("paintCount", value);
    }

    void drawsContent(bool* value)
    {
        JSONObjectBase::getBoolean("drawsContent", value);
    }

    void setParentLayerId(const TypeBuilder::LayerTree::LayerId& value)
    {
        this->setString("parentLayerId", value);
    }

    void setBackendNodeId(int value)
    {
        this->setNumber("backendNodeId", value);
    }

    void setTransform(PassRefPtr<TypeBuilder::Array<double> > value)
    {
        this->setValue("transform", value);
    }

    void setAnchorX(double value)
    {
        this->setNumber("anchorX", value);
    }

    void setAnchorY(double value)
    {
        this->setNumber("anchorY", value);
    }

    void setAnchorZ(double value)
    {
        this->setNumber("anchorZ", value);
    }

    void setInvisible(bool value)
    {
        this->setBoolean("invisible", value);
    }

    void setScrollRects(PassRefPtr<TypeBuilder::Array<TypeBuilder::LayerTree::ScrollRect> > value)
    {
        this->setValue("scrollRects", value);
    }
};

} // LayerTree

namespace ScreenOrientation {
/* Orientation type */
struct OrientationType {
    enum Enum {
        PortraitPrimary = 119,
        PortraitSecondary = 120,
        LandscapePrimary = 121,
        LandscapeSecondary = 122,
    };
}; // struct OrientationType

} // ScreenOrientation

namespace Power {
/* PowerEvent item */
class PowerEvent : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        TimestampSet = 1 << 1,
        ValueSet = 1 << 2,
        AllFieldsSet = (TypeSet | TimestampSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PowerEvent*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class PowerEvent;
    public:

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | TimestampSet>& setTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->setNumber("timestamp", value);
            return castState<TimestampSet>();
        }

        Builder<STATE | ValueSet>& setValue(double value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setNumber("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<PowerEvent>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(PowerEvent) == sizeof(JSONObject), "PowerEvent should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<PowerEvent>*>(&m_result);
        }

        PassRefPtr<PowerEvent> release()
        {
            return RefPtr<PowerEvent>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PowerEvent> result = PowerEvent::create()
     *     .setType(...)
     *     .setTimestamp(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void type(String* value)
    {
        JSONObjectBase::getString("type", value);
    }

    void timestamp(double* value)
    {
        JSONObjectBase::getNumber("timestamp", value);
    }

    void value(double* value)
    {
        JSONObjectBase::getNumber("value", value);
    }
};

} // Power

namespace Animation {
/* Animation instance. */
class Animation : public JSONObjectBase {
public:
    // Named after property name 'type' while generating Animation.
    struct Type {
        enum Enum {
            CSSTransition = 123,
            CSSAnimation = 124,
            WebAnimation = 125,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        PausedStateSet = 1 << 1,
        PlayStateSet = 1 << 2,
        PlaybackRateSet = 1 << 3,
        StartTimeSet = 1 << 4,
        CurrentTimeSet = 1 << 5,
        SourceSet = 1 << 6,
        TypeSet = 1 << 7,
        AllFieldsSet = (IdSet | PausedStateSet | PlayStateSet | PlaybackRateSet | StartTimeSet | CurrentTimeSet | SourceSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Animation*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class Animation;
    public:

        Builder<STATE | IdSet>& setId(const String& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setString("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | PausedStateSet>& setPausedState(bool value)
        {
            static_assert(!(STATE & PausedStateSet), "property pausedState should not be set yet");
            m_result->setBoolean("pausedState", value);
            return castState<PausedStateSet>();
        }

        Builder<STATE | PlayStateSet>& setPlayState(const String& value)
        {
            static_assert(!(STATE & PlayStateSet), "property playState should not be set yet");
            m_result->setString("playState", value);
            return castState<PlayStateSet>();
        }

        Builder<STATE | PlaybackRateSet>& setPlaybackRate(double value)
        {
            static_assert(!(STATE & PlaybackRateSet), "property playbackRate should not be set yet");
            m_result->setNumber("playbackRate", value);
            return castState<PlaybackRateSet>();
        }

        Builder<STATE | StartTimeSet>& setStartTime(double value)
        {
            static_assert(!(STATE & StartTimeSet), "property startTime should not be set yet");
            m_result->setNumber("startTime", value);
            return castState<StartTimeSet>();
        }

        Builder<STATE | CurrentTimeSet>& setCurrentTime(double value)
        {
            static_assert(!(STATE & CurrentTimeSet), "property currentTime should not be set yet");
            m_result->setNumber("currentTime", value);
            return castState<CurrentTimeSet>();
        }

        Builder<STATE | SourceSet>& setSource(PassRefPtr<TypeBuilder::Animation::AnimationEffect> value)
        {
            static_assert(!(STATE & SourceSet), "property source should not be set yet");
            m_result->setValue("source", value);
            return castState<SourceSet>();
        }

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<Animation>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(Animation) == sizeof(JSONObject), "Animation should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<Animation>*>(&m_result);
        }

        PassRefPtr<Animation> release()
        {
            return RefPtr<Animation>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Animation> result = Animation::create()
     *     .setId(...)
     *     .setPausedState(...)
     *     .setPlayState(...)
     *     .setPlaybackRate(...)
     *     .setStartTime(...)
     *     .setCurrentTime(...)
     *     .setSource(...)
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void id(String* value)
    {
        JSONObjectBase::getString("id", value);
    }

    void pausedState(bool* value)
    {
        JSONObjectBase::getBoolean("pausedState", value);
    }

    void playState(String* value)
    {
        JSONObjectBase::getString("playState", value);
    }

    void playbackRate(double* value)
    {
        JSONObjectBase::getNumber("playbackRate", value);
    }

    void startTime(double* value)
    {
        JSONObjectBase::getNumber("startTime", value);
    }

    void currentTime(double* value)
    {
        JSONObjectBase::getNumber("currentTime", value);
    }
};

/* AnimationEffect instance */
class AnimationEffect : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        DelaySet = 1 << 0,
        EndDelaySet = 1 << 1,
        PlaybackRateSet = 1 << 2,
        IterationStartSet = 1 << 3,
        IterationsSet = 1 << 4,
        DurationSet = 1 << 5,
        DirectionSet = 1 << 6,
        FillSet = 1 << 7,
        NameSet = 1 << 8,
        BackendNodeIdSet = 1 << 9,
        EasingSet = 1 << 10,
        AllFieldsSet = (DelaySet | EndDelaySet | PlaybackRateSet | IterationStartSet | IterationsSet | DurationSet | DirectionSet | FillSet | NameSet | BackendNodeIdSet | EasingSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*AnimationEffect*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class AnimationEffect;
    public:

        Builder<STATE | DelaySet>& setDelay(double value)
        {
            static_assert(!(STATE & DelaySet), "property delay should not be set yet");
            m_result->setNumber("delay", value);
            return castState<DelaySet>();
        }

        Builder<STATE | EndDelaySet>& setEndDelay(double value)
        {
            static_assert(!(STATE & EndDelaySet), "property endDelay should not be set yet");
            m_result->setNumber("endDelay", value);
            return castState<EndDelaySet>();
        }

        Builder<STATE | PlaybackRateSet>& setPlaybackRate(double value)
        {
            static_assert(!(STATE & PlaybackRateSet), "property playbackRate should not be set yet");
            m_result->setNumber("playbackRate", value);
            return castState<PlaybackRateSet>();
        }

        Builder<STATE | IterationStartSet>& setIterationStart(double value)
        {
            static_assert(!(STATE & IterationStartSet), "property iterationStart should not be set yet");
            m_result->setNumber("iterationStart", value);
            return castState<IterationStartSet>();
        }

        Builder<STATE | IterationsSet>& setIterations(double value)
        {
            static_assert(!(STATE & IterationsSet), "property iterations should not be set yet");
            m_result->setNumber("iterations", value);
            return castState<IterationsSet>();
        }

        Builder<STATE | DurationSet>& setDuration(double value)
        {
            static_assert(!(STATE & DurationSet), "property duration should not be set yet");
            m_result->setNumber("duration", value);
            return castState<DurationSet>();
        }

        Builder<STATE | DirectionSet>& setDirection(const String& value)
        {
            static_assert(!(STATE & DirectionSet), "property direction should not be set yet");
            m_result->setString("direction", value);
            return castState<DirectionSet>();
        }

        Builder<STATE | FillSet>& setFill(const String& value)
        {
            static_assert(!(STATE & FillSet), "property fill should not be set yet");
            m_result->setString("fill", value);
            return castState<FillSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | BackendNodeIdSet>& setBackendNodeId(int value)
        {
            static_assert(!(STATE & BackendNodeIdSet), "property backendNodeId should not be set yet");
            m_result->setNumber("backendNodeId", value);
            return castState<BackendNodeIdSet>();
        }

        Builder<STATE | EasingSet>& setEasing(const String& value)
        {
            static_assert(!(STATE & EasingSet), "property easing should not be set yet");
            m_result->setString("easing", value);
            return castState<EasingSet>();
        }

        operator RefPtr<AnimationEffect>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(AnimationEffect) == sizeof(JSONObject), "AnimationEffect should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<AnimationEffect>*>(&m_result);
        }

        PassRefPtr<AnimationEffect> release()
        {
            return RefPtr<AnimationEffect>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<AnimationEffect> result = AnimationEffect::create()
     *     .setDelay(...)
     *     .setEndDelay(...)
     *     .setPlaybackRate(...)
     *     .setIterationStart(...)
     *     .setIterations(...)
     *     .setDuration(...)
     *     .setDirection(...)
     *     .setFill(...)
     *     .setName(...)
     *     .setBackendNodeId(...)
     *     .setEasing(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void delay(double* value)
    {
        JSONObjectBase::getNumber("delay", value);
    }

    void endDelay(double* value)
    {
        JSONObjectBase::getNumber("endDelay", value);
    }

    void playbackRate(double* value)
    {
        JSONObjectBase::getNumber("playbackRate", value);
    }

    void iterationStart(double* value)
    {
        JSONObjectBase::getNumber("iterationStart", value);
    }

    void iterations(double* value)
    {
        JSONObjectBase::getNumber("iterations", value);
    }

    void duration(double* value)
    {
        JSONObjectBase::getNumber("duration", value);
    }

    void direction(String* value)
    {
        JSONObjectBase::getString("direction", value);
    }

    void fill(String* value)
    {
        JSONObjectBase::getString("fill", value);
    }

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void backendNodeId(int* value)
    {
        JSONObjectBase::getNumber("backendNodeId", value);
    }

    void easing(String* value)
    {
        JSONObjectBase::getString("easing", value);
    }

    void setKeyframesRule(PassRefPtr<TypeBuilder::Animation::KeyframesRule> value)
    {
        this->setValue("keyframesRule", value);
    }
};

/* Keyframes Rule */
class KeyframesRule : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        KeyframesSet = 1 << 0,
        AllFieldsSet = (KeyframesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*KeyframesRule*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class KeyframesRule;
    public:

        Builder<STATE | KeyframesSet>& setKeyframes(PassRefPtr<TypeBuilder::Array<TypeBuilder::Animation::KeyframeStyle> > value)
        {
            static_assert(!(STATE & KeyframesSet), "property keyframes should not be set yet");
            m_result->setValue("keyframes", value);
            return castState<KeyframesSet>();
        }

        operator RefPtr<KeyframesRule>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(KeyframesRule) == sizeof(JSONObject), "KeyframesRule should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<KeyframesRule>*>(&m_result);
        }

        PassRefPtr<KeyframesRule> release()
        {
            return RefPtr<KeyframesRule>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<KeyframesRule> result = KeyframesRule::create()
     *     .setKeyframes(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setName(const String& value)
    {
        this->setString("name", value);
    }
};

/* Keyframe Style */
class KeyframeStyle : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        OffsetSet = 1 << 0,
        EasingSet = 1 << 1,
        AllFieldsSet = (OffsetSet | EasingSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*KeyframeStyle*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class KeyframeStyle;
    public:

        Builder<STATE | OffsetSet>& setOffset(const String& value)
        {
            static_assert(!(STATE & OffsetSet), "property offset should not be set yet");
            m_result->setString("offset", value);
            return castState<OffsetSet>();
        }

        Builder<STATE | EasingSet>& setEasing(const String& value)
        {
            static_assert(!(STATE & EasingSet), "property easing should not be set yet");
            m_result->setString("easing", value);
            return castState<EasingSet>();
        }

        operator RefPtr<KeyframeStyle>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(KeyframeStyle) == sizeof(JSONObject), "KeyframeStyle should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<KeyframeStyle>*>(&m_result);
        }

        PassRefPtr<KeyframeStyle> release()
        {
            return RefPtr<KeyframeStyle>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<KeyframeStyle> result = KeyframeStyle::create()
     *     .setOffset(...)
     *     .setEasing(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void offset(String* value)
    {
        JSONObjectBase::getString("offset", value);
    }

    void easing(String* value)
    {
        JSONObjectBase::getString("easing", value);
    }
};

} // Animation

namespace Accessibility {
/* Enum of possible property types. */
struct AXValueType {
    enum Enum {
        Boolean = 19,
        Tristate = 126,
        BooleanOrUndefined = 127,
        Idref = 128,
        IdrefList = 129,
        Integer = 130,
        Number = 18,
        String = 17,
        Token = 131,
        TokenList = 132,
        DomRelation = 133,
        Role = 134,
        InternalRole = 135,
    };
}; // struct AXValueType

/* Enum of possible property sources. */
struct AXPropertySourceType {
    enum Enum {
        Attribute = 136,
        Implicit = 137,
        Style = 138,
    };
}; // struct AXPropertySourceType

/* A single source for a computed AX property. */
class AXPropertySource : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        SourceTypeSet = 1 << 1,
        ValueSet = 1 << 2,
        TypeSet = 1 << 3,
        AllFieldsSet = (NameSet | SourceTypeSet | ValueSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*AXPropertySource*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class AXPropertySource;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | SourceTypeSet>& setSourceType(TypeBuilder::Accessibility::AXPropertySourceType::Enum value)
        {
            static_assert(!(STATE & SourceTypeSet), "property sourceType should not be set yet");
            m_result->setString("sourceType", TypeBuilder::getEnumConstantValue(value));
            return castState<SourceTypeSet>();
        }

        Builder<STATE | ValueSet>& setValue(PassRefPtr<JSONValue> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue("value", value);
            return castState<ValueSet>();
        }

        Builder<STATE | TypeSet>& setType(TypeBuilder::Accessibility::AXValueType::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<AXPropertySource>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(AXPropertySource) == sizeof(JSONObject), "AXPropertySource should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<AXPropertySource>*>(&m_result);
        }

        PassRefPtr<AXPropertySource> release()
        {
            return RefPtr<AXPropertySource>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<AXPropertySource> result = AXPropertySource::create()
     *     .setName(...)
     *     .setSourceType(...)
     *     .setValue(...)
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }

    void setInvalid(bool value)
    {
        this->setBoolean("invalid", value);
    }

    void setInvalidReason(const String& value)
    {
        this->setString("invalidReason", value);
    }
};

class AXRelatedNode : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        BackendNodeIdSet = 1 << 0,
        AllFieldsSet = (BackendNodeIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*AXRelatedNode*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class AXRelatedNode;
    public:

        Builder<STATE | BackendNodeIdSet>& setBackendNodeId(int value)
        {
            static_assert(!(STATE & BackendNodeIdSet), "property backendNodeId should not be set yet");
            m_result->setNumber("backendNodeId", value);
            return castState<BackendNodeIdSet>();
        }

        operator RefPtr<AXRelatedNode>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(AXRelatedNode) == sizeof(JSONObject), "AXRelatedNode should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<AXRelatedNode>*>(&m_result);
        }

        PassRefPtr<AXRelatedNode> release()
        {
            return RefPtr<AXRelatedNode>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<AXRelatedNode> result = AXRelatedNode::create()
     *     .setBackendNodeId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void backendNodeId(int* value)
    {
        JSONObjectBase::getNumber("backendNodeId", value);
    }

    void setIdref(const String& value)
    {
        this->setString("idref", value);
    }
};

class AXProperty : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*AXProperty*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class AXProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(PassRefPtr<TypeBuilder::Accessibility::AXValue> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<AXProperty>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(AXProperty) == sizeof(JSONObject), "AXProperty should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<AXProperty>*>(&m_result);
        }

        PassRefPtr<AXProperty> release()
        {
            return RefPtr<AXProperty>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<AXProperty> result = AXProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void name(String* value)
    {
        JSONObjectBase::getString("name", value);
    }
};

/* A single computed AX property. */
class AXValue : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*AXValue*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class AXValue;
    public:

        Builder<STATE | TypeSet>& setType(TypeBuilder::Accessibility::AXValueType::Enum value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<AXValue>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(AXValue) == sizeof(JSONObject), "AXValue should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<AXValue>*>(&m_result);
        }

        PassRefPtr<AXValue> release()
        {
            return RefPtr<AXValue>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<AXValue> result = AXValue::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setValue(PassRefPtr<JSONValue> value)
    {
        this->setValue("value", value);
    }
    using JSONObjectBase::setValue;


    void setRelatedNodeValue(PassRefPtr<TypeBuilder::Accessibility::AXRelatedNode> value)
    {
        this->setValue("relatedNodeValue", value);
    }

    void setRelatedNodeArrayValue(PassRefPtr<TypeBuilder::Array<TypeBuilder::Accessibility::AXRelatedNode> > value)
    {
        this->setValue("relatedNodeArrayValue", value);
    }

    void setSources(PassRefPtr<TypeBuilder::Array<TypeBuilder::Accessibility::AXPropertySource> > value)
    {
        this->setValue("sources", value);
    }
};

/* States which apply to every AX node. */
struct AXGlobalStates {
    enum Enum {
        Disabled = 139,
        Hidden = 140,
        HiddenRoot = 141,
        Invalid = 142,
    };
}; // struct AXGlobalStates

/* Attributes which apply to nodes in live regions. */
struct AXLiveRegionAttributes {
    enum Enum {
        Live = 143,
        Atomic = 144,
        Relevant = 145,
        Busy = 146,
        Root = 147,
    };
}; // struct AXLiveRegionAttributes

struct AXWidgetAttributes {
    enum Enum {
        Autocomplete = 148,
        Haspopup = 149,
        Level = 150,
        Multiselectable = 151,
        Orientation = 152,
        Multiline = 153,
        Readonly = 154,
        Required = 155,
        Valuemin = 156,
        Valuemax = 157,
        Valuetext = 158,
    };
}; // struct AXWidgetAttributes

/* States which apply to widgets. */
struct AXWidgetStates {
    enum Enum {
        Checked = 159,
        Expanded = 160,
        Pressed = 161,
        Selected = 162,
    };
}; // struct AXWidgetStates

/* Relationships between elements other than parent/child/sibling. */
struct AXRelationshipAttributes {
    enum Enum {
        Activedescendant = 163,
        Flowto = 164,
        Controls = 165,
        Describedby = 166,
        Labelledby = 167,
        Owns = 168,
    };
}; // struct AXRelationshipAttributes

/* A node in the accessibility tree. */
class AXNode : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NodeIdSet = 1 << 0,
        IgnoredSet = 1 << 1,
        AllFieldsSet = (NodeIdSet | IgnoredSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*AXNode*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class AXNode;
    public:

        Builder<STATE | NodeIdSet>& setNodeId(const TypeBuilder::Accessibility::AXNodeId& value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setString("nodeId", value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | IgnoredSet>& setIgnored(bool value)
        {
            static_assert(!(STATE & IgnoredSet), "property ignored should not be set yet");
            m_result->setBoolean("ignored", value);
            return castState<IgnoredSet>();
        }

        operator RefPtr<AXNode>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(AXNode) == sizeof(JSONObject), "AXNode should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<AXNode>*>(&m_result);
        }

        PassRefPtr<AXNode> release()
        {
            return RefPtr<AXNode>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<AXNode> result = AXNode::create()
     *     .setNodeId(...)
     *     .setIgnored(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void nodeId(TypeBuilder::Accessibility::AXNodeId* value)
    {
        JSONObjectBase::getString("nodeId", value);
    }

    void ignored(bool* value)
    {
        JSONObjectBase::getBoolean("ignored", value);
    }

    void setIgnoredReasons(PassRefPtr<TypeBuilder::Array<TypeBuilder::Accessibility::AXProperty> > value)
    {
        this->setValue("ignoredReasons", value);
    }

    void setRole(PassRefPtr<TypeBuilder::Accessibility::AXValue> value)
    {
        this->setValue("role", value);
    }

    void setName(PassRefPtr<TypeBuilder::Accessibility::AXValue> value)
    {
        this->setValue("name", value);
    }

    void setDescription(PassRefPtr<TypeBuilder::Accessibility::AXValue> value)
    {
        this->setValue("description", value);
    }

    void setValue(PassRefPtr<TypeBuilder::Accessibility::AXValue> value)
    {
        this->setValue("value", value);
    }
    using JSONObjectBase::setValue;


    void setHelp(PassRefPtr<TypeBuilder::Accessibility::AXValue> value)
    {
        this->setValue("help", value);
    }

    void setProperties(PassRefPtr<TypeBuilder::Array<TypeBuilder::Accessibility::AXProperty> > value)
    {
        this->setValue("properties", value);
    }
};

} // Accessibility

namespace Security {
/* The security level of a page or resource. */
struct SecurityState {
    enum Enum {
        Unknown = 169,
        Http = 170,
        Insecure = 171,
        Warning = 43,
        Secure = 172,
    };
}; // struct SecurityState

/* An explanation of an factor contributing to the security state. */
class SecurityStateExplanation : public JSONObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SecurityStateSet = 1 << 0,
        SummarySet = 1 << 1,
        DescriptionSet = 1 << 2,
        AllFieldsSet = (SecurityStateSet | SummarySet | DescriptionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSONObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SecurityStateExplanation*/JSONObject> ptr)
        {
            static_assert(STATE == NoFieldsSet, "builder should not be created in non-init state");
            m_result = ptr;
        }
        friend class SecurityStateExplanation;
    public:

        Builder<STATE | SecurityStateSet>& setSecurityState(TypeBuilder::Security::SecurityState::Enum value)
        {
            static_assert(!(STATE & SecurityStateSet), "property securityState should not be set yet");
            m_result->setString("securityState", TypeBuilder::getEnumConstantValue(value));
            return castState<SecurityStateSet>();
        }

        Builder<STATE | SummarySet>& setSummary(const String& value)
        {
            static_assert(!(STATE & SummarySet), "property summary should not be set yet");
            m_result->setString("summary", value);
            return castState<SummarySet>();
        }

        Builder<STATE | DescriptionSet>& setDescription(const String& value)
        {
            static_assert(!(STATE & DescriptionSet), "property description should not be set yet");
            m_result->setString("description", value);
            return castState<DescriptionSet>();
        }

        operator RefPtr<SecurityStateExplanation>& ()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            static_assert(sizeof(SecurityStateExplanation) == sizeof(JSONObject), "SecurityStateExplanation should be the same size as JSONObject");
            return *reinterpret_cast<RefPtr<SecurityStateExplanation>*>(&m_result);
        }

        PassRefPtr<SecurityStateExplanation> release()
        {
            return RefPtr<SecurityStateExplanation>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SecurityStateExplanation> result = SecurityStateExplanation::create()
     *     .setSecurityState(...)
     *     .setSummary(...)
     *     .setDescription(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSONObject::create());
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void summary(String* value)
    {
        JSONObjectBase::getString("summary", value);
    }

    void description(String* value)
    {
        JSONObjectBase::getString("description", value);
    }
};

} // Security


} // namespace TypeBuilder


} // namespace blink

#endif // !defined(InspectorTypeBuilder_h)

