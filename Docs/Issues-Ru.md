Я действительно больше не могу это смотреть, вот почему я опубликовал эту статью, владелец кода, взгляните #122
Закрытый
ugksoft открыла этот выпуск 17 июля 2018 г. · 71 комментарий
Комментарии
@ugksoft
ugksoft прокомментировала 17 июля 2018 г. •
Главным образом потому, что я больше не могу это смотреть, я просто написал это. Некоторые из них слишком знакомы. Я руководствуюсь здравым смыслом, но они показывают меня ребенком.,
Может быть, вы также понимаете, что вы не делаете этого только потому, что вам лень. Это не ваше блюдо.,
Во избежание недоразумений, ссор и т.д., пожалуйста, объясните

Вы являетесь cdecl по умолчанию для всех библиотек DLL!!! , В Windows стандартным правилом является stdcall!!!!!!!, Включая обратный вызов stdcall,
Теперь я собираюсь изменить cdecl. Чужие программы неизбежно будут сообщать об ошибках. Посмотрите на количество ваших пользователей. Если количество невелико, вы можете гарантировать получение уведомления, или если проблема невелика, то исправьте ее с помощью stdcall и сочтите это целесообразным.
DWORD __stdcall GetTickCount();
DWORD __stdcall Sleep(dwMilliseconds:DWORD);
Существует четыре распространенных типа stdcall/pascal/fastcall/cdecl. В общем, порядок, в котором хранятся регистры параметров API, - слева направо и справа налево.,
Кто освобождает временный стек, stdcall выполняется справа налево (цель - формат (xxx, a, b.c...), когда длина является переменной..
Внутри VC или cdecll по умолчанию, когда модификаторы не добавляются, по умолчанию также используется cdecll

Я нашел это для вас, вы можете взглянуть
https://www.linuxidc.com/Linux/2010-04/25290.htm
http://www.3scard.com/index.php?m=blog&f=view&id=10
(В вашем коде нет BS, который вы имеете в виду, чистая доброта, вы не заметили обязательного stdcall, возможно, эта мгновенная осведомленность о лапше слаба, поэтому я просто подчеркнул это)

Впервые в своей жизни я увидел, как кто-то пишет библиотеку dll, и строка, которая использует внутренний класс в качестве параметра обратного вызова, является встроенным типом C++. Фактически, ее можно рассматривать как класс (класс фактически компилируется, и он обычно обрабатывается в форма записи/структуры и сохраняется в скомпилированной корзине)
Разные версии и разные компиляторы (vc, bcb или другие компиляторы c++) имеют свои собственные методы обработки такого рода данных, не связанных напрямую с памятью.
Если только вы не заставляете пользователя использовать ту же версию vc, что и вы (если Microsoft исправляет этот vc, используя string, тогда всем даже нужно исправлять одно и то же), или библиотека dll и исполняемый файл компилируются собственным компилятором пользователя, или код библиотеки dll непосредственно включен в исполняемый файл и библиотека dll больше не используется. В противном случае данные в памяти должны быть другими, и исполняемый файл не сможет нормально вызвать библиотеку dll. В это время будут возникать различные иррациональные проблемы с заголовками, и причину найти невозможно.
Метод исправления, все изменено на char* (вы можете рассмотреть wchar, но обычно char* является основным)
Как библиотека dll, она должна быть стандартизирована в соответствии со стандартами Windows, чтобы все компиляторы могли ее хорошо поддерживать.
Распространенный delphi7/DelphiXE, VC, BorandC++, Java, gcc (MinGW/Cygwin)...
Эта спецификация просто сформулирована,
A.стандартный вызов (индивидуальные причины эффективности или удобства разработки и т.д., если вы не следуете вышеизложенному, вы также должны указать в письменной форме)
B. Когда API обменивается данными, требуется 32-битное выравнивание, и некоторые перечисления, bool или другие должны быть явно объявлены, чтобы различные параметры компиляции не влияли на выравнивание памяти.
Параметры должны быть как можно более привязаны к памяти. Как правило, * AnsiChar является основным. Отдельные параметры могут быть * WideChar, но большинство из них - * ansichar.
Это совместимо с utf8 и gbk
WideChar, самое большее, всего 65 535 символов, но не так много. При обработке новых символов это неизбежно приведет к потерям, поэтому widechar не следует использовать.
Потому что, когда изначально разрабатывалась Windows, в 1990-х годах, думали, что 65535 было достаточно, теперь в utf8 есть куча мусора, может быть, однажды 4 байта
Этого может быть недостаточно, поэтому ansichar/utf8/gbk является основным!!! По крайней мере, это не будет ошибкой
C.Для всех перечислений вам необходимо принудительно указать начальную и конечную точки, то есть enum_start=0, enum_MAX=0x7fffffff,
Таким образом, избегайте компилятора и действуйте по собственной инициативе. Если на первый взгляд оно не превышает 255, используйте байт для его хранения. В программе можно обмениваться данными между файлами.
Это проблема
D.Для всех структур выравнивание должно быть задано принудительно. Обычно выравнивается в единицах по 4 байта,

#pragma pack(4) //Принудительное выравнивание по 4 байтам
структура
{
//DWORD dwsize для сложных данных рассмотрите возможность добавления dwsize, чтобы библиотека dll могла определить, для какой версии SDK был разработан исполняемый файл на основе dwsize.,
// В то же время, он также может быть использован для оценки запредельных значений во время работы. Большинство конструкций windows имеют такие размеры и значения.,
символ ver;
символический флаг;
char res1[2]; 2 здесь отсутствуют, поэтому 2 намеренно добавлены (также могут быть использованы для резервирования функции расширения в будущем),
Чтобы предотвратить сжатие компилятора, всегда вводите значение 0, когда он не используется,
Когда вы захотите использовать его в будущем, знайте, что значение 0 не используется, а значение, отличное от 0, является допустимыми данными.
символ X;
обаятельный;
символ X;
char res2[1]; В конце предотвратите сжатие компилятора, чтобы он был намеренно выровнен
}
#pragma pack()//Восстановить выравнивание компилятора по умолчанию

Таким образом, элемент res намеренно добавляется, чтобы занять указанную позицию. При нормальных обстоятельствах 32-разрядная система работает нормально.,
В случае 64-разрядного компилятора разработчик компилятора некоторое время не сможет думать об этом в будущем. По умолчанию для 64-разрядного используется выравнивание по 8 байт, или компилятору необходимо установить параметры на выравнивание по 8 байт из-за необходимости в других данных. В это время неизбежно возникнет ошибка.
Поэтому лучше всего добавить pragma pack, чтобы указать его явно

После того, как все эти значения размера установлены, из-за большого количества элементов структуры они могут быть ошибочными, например, неправильно рассчитан res[xx] и т.д.
После того, как все будет сделано, вам нужно напечататьf("Name=%s, sizeof=%d", xxx sizeof(xxx)); нажмите, подтвердите все по очереди

Однако, как правило, вам нужно изменить только файл h. Объем изменений невелик. Просто у ваших старых пользователей могут возникнуть проблемы с совместимостью.
(Им нужно взять этот заголовочный файл и перекомпилировать свою программу. Нет необходимости изменять строку в коде)

Некоторые функции, такие как wkeGetUserAgent, возвращают указатель на ansichar,
Обычно это должно быть так, что пользователю предоставляется место в памяти, а библиотека dll отвечает за заполнение данных, обычно она вызывается дважды.
При первом вызове buff=null,*size возвращает размер
Во второй раз примените размер памяти в соответствии с размером, а затем получите (buff, size), если это строковые данные, для предотвращения несчастных случаев и совместимости, обычно размер +1 применяется еще к одним данным,
(Или пользователь знает, что эти данные имеют длину 4 КБ и они неактивны, поэтому он напрямую вызывает их один раз и выделяет 4 КБ памяти. После вызова библиотеки DLL размер обновляется, чтобы сообщить эффективную длину.)
Таким образом, пользователям не нужно сомневаться в том, нужно ли освобождать возвращаемый блок памяти с помощью внешнего исполняемого файла.
Независимо от того, на каком языке, по умолчанию используется тот, кто вызывает и кто запрашивает память (exe вызывает API_Filldata (xxx), затем xxx применяется exe и освобождается exe,)
Однако диаграмма удобна, и данные char* могут быть возвращены непосредственно в произвольном формате. Большинство из них не будут ошибочными, но:
char*p=GetCurUrl; //返回www.xxx.com
int Len=strlen(p);
Куча последующих операций со стороны пользователя может отнять много времени, также может быть, что компьютер пользователя слишком зависает или по другим причинам, и в то же время веб-поток после обратного отсчета js указывает на www.newurl.com
Временные интервалы процессора, при переключении между блоками кода, невозможно гарантировать, что все равны. У некоторых больше циклов, а у некоторых меньше. При многоядерном процессоре преимущества очевидны. Когда процесс застревает, преимущества очевидны.
Затем пользователь вызывает p, затем значение p становится newurl, оно может быть выпущено вами, или это может быть небезопасно (конечная проблема)
для (int i=0... я<Лен)
{
.....
}
Чтобы решить эту проблему, необходимо письменно указать и сообщить пользователю, что результирующее значение является безопасным, постоянным и да...Подожди минутку
Но, в конце концов, это не обычный способ вызова
У пользователя нет другого выбора, кроме как решить проблему. Возможно, что после GetCurURL блок памяти newmem немедленно копирует результаты, чтобы предотвратить изменение данных веб-ядром, но это не так хорошо, как собственное приложение пользователя. Решение подходящее.

Первоначальный автор WKE, я не знаю, вы ли это, возможно, это не преднамеренный автор WKE, GG более вероятен
вроде.В dll рисование экрана фактически требует, чтобы пользователь реализовал его самостоятельно, самостоятельно применил область bmp, самостоятельно вычислил положение мыши и т.д., что является супер извращенным, пустой тратой памяти и пустой тратой ввода-вывода. Этот подход, насколько я знаю, только api andriod имеет подобную структуру отображения.,
Большинство пользователей не задумываются об этом, они просто хотят вызывать Webbrower в IE так же просто, как Webbrower в IE, потому что совместимость с webbroiwer в IE становится все хуже и хуже. Часто при отображении веб-страницы сообщается об ошибке js, или элемент не может быть найден, или тому подобное(но при запуске в стандартном IE этой проблемы нет)
Другие, если они хотят реализовать какие-то высокоуровневые и расширенные функции, на данный момент передадут пользователю функцию рисования экрана. Пользователь может захотеть встроить суперавтономную веб-страницу в исполняемый файл или даже в игру, возможно, появится возможность отображать веб-страницу страница в режиме текстуры. В это время требуются необработанные данные, такие как GetBmp и GetYUV.
Ваш wkeCreateWebWindow намного удобнее, чем оригинальный WKE. Я думаю, что оригинальный WKE неразумен, поэтому я упомянул об этом.
5.Ваша библиотека DLL экспортировала классы C++, целую кучу из них??ххххххххх@!$#@!$@#$!Экспортное название на самом деле небезопасно, а разработка неудобна.
Хорошей практикой является имитация COM и экспорт COM-интерфейса процесса (например, wmp.библиотека dll выглядит следующим образом)
Например, определите
WKECRETEWEBCORE(); Возвращает интерфейс
Интерфейс выглядит следующим образом:
Интерфейс Ixxxxxxx;
функция setpos(L, T, W, H,isshow);
функция loadUrl(url )
функция....
....
(Для получения подробной информации вы можете случайно открыть пример в vc или использовать exescope для открытия c:\windows\system32\wmp.библиотека dll

Когда пользователи используют его, им не нужно создавать какие-либо классы, им просто нужно
web=wkeCreateWebCore();
сеть.setpos(...)
сеть.loadurl(...)
функция regcallback(CB *обратный вызов,void *пользователь);
Это точно то же самое, что и стандартный код класса

Однако, когда com-метод имеет недостатки, есть некоторые места, где пользователь не знает сути, такие как указатель на указатель, и следует ли освобождать память в конце (например, DirectShow->mediatype.Формат данных), порядок вызова и т.д., это немного сбивает с толку, так что,
При его использовании старайтесь максимально придерживаться стандартного исходного типа данных. Если могут возникнуть проблемы с освобождением памяти, запишите это в текстовом виде.
При работе с обратными вызовами и классами событий используйте не метод COM, а стандартный метод C/C++.

Не используйте COM, кроме процесса (например, при загрузке кнопка меню "Пуск" зависает, или при работе некоторых программ меню "Пуск" зависает, т.е. зависает, запустите его, на результат повлияет диспетчер ресурсов и т.д.).Это все межпроцессный COM, не рекомендуется этого делать)

Слишком.Я больше не хочу этого говорить, это непонятно в одном или двух предложениях.,

@weolar
Владелец
weolar прокомментировал 17 июля 2018 г. •
Обычно я не притворяюсь, что понимаю.Изучив c++ в течение полугода, я вышел и встряхнул его.
1. Использовать ли cdecl или stdcall - это мое личное дело.За объявлением вызывающего абонента следует такое же объявление.Люди, которые совершают ошибки, - это все те, кто не читает заголовочные файлы.Я не являюсь официальной библиотекой dll Microsoft, какое вам дело до моего использования?Так много крупных проектов с открытым исходным кодом в мире, особенно на чистом C, в основном являются cdecl, такими как curl.
2. Что сказать об использовании внутренних классов, это означает, что, во-первых, вы не читали код mb, а во-вторых, вы пишете меньше кода.wkeString, который я экспортировал, - это просто указатель, и если вам нужно работать, вы можете вызвать только предоставленный api, такой как wkeGetString.Какой внутренний класс вы хотите, чтобы я экспортировал?Посмотрите на заголовочный файл Microsoft, является ли HWND также внутренним классом, который вы упомянули?
3. Приведите структуру в соответствие с этим, просто следуйте настройкам Vs по умолчанию.Другие компиляторы настроены на выравнивание Vs по умолчанию.Я изложу это в документе в следующий раз.Это не ошибка, чему ты так радуешься?
4. В наши дни все еще есть люди, которые используют память для передачи данных дважды. Я тоже пьян.Это самый глупый дизайн.Другим нужно всего лишь несколько строк, и вы должны придумать такой сложный способ получить их.Если вам нужно получить 2 нити, вам придется повторить четыре раза и 2 петли, что довольно хлопотно.Теперь, если строка, возвращаемая mb, является const char*, это означает, что следующий кадр восстановлен.Вам не нужно перерабатывать его, вы не можете сохранить его как постоянную строку, и в нем нет смысла, пока не будет изменена половина содержимого.Просто посмотрите на исходный код для этого.Конечно, это также моя вина, что я не написал этот документ, поэтому я добавлю его позже.
5. Экспортируйте классы C++, целую кучу из них??ххххххххх@!$#@!$@#$!。Я разрешал тебе пользоваться этим?Эти классы вообще не упоминаются в моей документации и заголовочных файлах. Это для внутреннего использования в моем электронном режиме.Какое тебе дело до меня?Просил ли я кого-нибудь позвонить
6. “вкэ.В dll рисование экрана на самом деле требует, чтобы пользователь реализовал это самостоятельно, самостоятельно применил область bmp, самостоятельно вычислил положение мыши и т.д., Супер извращение, пустая трата памяти, пустой ввод-вывод”, Это называется закадровым рендерингом, это для мест, которые должны быть рисуется в играх (например, для D3D требуется растровое изображение).Несмотря на громоздкость, им можно управлять более детально.Если вам это не нужно, используйте простое wkeCreateWebWindow.Оба метода имеют свое применение, и нет никакого вопроса о том, что правильно, а что нет.Чему ты так радуешься?
7, вы на самом деле хотите, чтобы я экспортировал com.Что это за возраст, кто все еще хочет использовать такой громоздкий метод экспорта.Теперь он объединен в чистый интерфейс C, есть ли проблема?

@1ocalhost
1ocalhost прокомментировал 17 июля 2018 г.
Текст арендодателя слишком эмоциональный, детский и расчетливый. У меня все равно не хватает терпения дочитать его до конца. Мне это слишком нравится. Он вонючий и длинный.。。 @weolar подметает пол, просто закройте эти проблемы напрямую ☺ ️

@ugksoft
Автор
ugksoft прокомментировала 17 июля 2018 г.
Говоря, что другие не понимают и притворяются, что понимают, я прикасался к компьютеру в течение 20 лет. Я хотел использовать его, но обнаружил, что он становится все более хаотичным. Потребовалось несколько часов, чтобы перевести ваш заголовочный файл, и, наконец, вызвал его и сообщил об ошибке. Я ненавижу это. У меня чешутся зубы, вот почему у меня есть эта статья (я использую Delphi7)

Это ваше дело - использовать cdecl или stdcll, поэтому вы можете разместить это на github. Цель в том, чтобы все могли это использовать. Естественно, это должно соответствовать стандарту.
Даже если вам нравится cdcell, вы можете, по крайней мере, написать предложение явно. Как правило, вторичные документы разработки, SDK и т.д. - все это stdcall.
Поскольку стандартом является stdcall, я сталкивался с некоторыми ситуациями, когда я сначала использовал cdcel, а затем тайно изменил его на stdcall. Вот почему я упомянул об этом.

Когда проводится HWND-урок? Очевидно, что это DWORD, wkestring является внутренним для вас, и позвольте пользователю настроить wkeGetString. Разве это не хлопотно? В любом случае, если пользователь регистрируется для обратного вызова, он должен использовать эти данные и позволить пользователю настроить wkeGetString еще раз.

3.Структура выровнена, все знают, что она установлена по умолчанию, но подтверждаете ли вы, что пользователь должен быть пользователем VS?, Пользовательская программа определенно является чистым веб-приложением?Для сложных приложений определение обычно запутанное. Лучше указать его явно. Вы не можете ошибаться в отношении своей собственной библиотеки dll/ exe, но это определенно ошибка для разных пользователей и языков.

4.Явный вызов, это в том случае, когда размер памяти неясен (для сложных приложений, когда структура беспорядочна, данные могут быть слишком большими или маленькими)
Но для обычных приложений, когда всем все ясно, просто запросите достаточное количество памяти напрямую, чтобы область памяти внутри модуля не была видна снаружи.
Предположим, void*v = getData(); Слишком много кода, пользователь не обращает внимания, и если он запишет в v, он умрет (const просто сообщает компилятору проверить синтаксис во время компиляции, на самом деле не доступен только для чтения)
Вы перерабатываете его сами, но пользователь об этом не знает. Это небезопасно в многопоточной среде.

5.??ХХХ??Xx, как правило, разработчики не пишут напрямую, и они будут использовать это, когда они пересекают языки (я этим не пользуюсь). Я просто говорю, что это не очень хорошо и его следует избегать. Ваши пользователи не должны использовать экстремальные ситуации, такие как gcc, поэтому не рассматривайте это.

Почему вы продолжаете говорить о волнении? Хотя этот вид рендеринга просто решает многие проблемы, он требует слишком много усилий. Я просто говорю, что оригинальный метод wke не очень хорош.
Большинству людей это не нужно. Они признают и хвалят вас за то, что у вас есть wkeCreateWebWindow. Вы все еще хотите сказать, что я плохой?

Экспорт com - это просто ленивый способ экспорта классов. Мне не очень нравится com. Я просто считаю его таким беспорядочным. Я дам вам идею.

Кроме того, я
Укейнит;
wkeCreateWebWindow Создать веб-окно;
Размер wkeResize;
(...Какая-то регистрация, необязательная или нет, все равно)
wkeLoadURL(htttp://aaa.com/phpinfo.php)
wkeLoadURL('http://github.com/weolar/miniblink49');
Статичные и простые страницы, все в порядке
а
wkeLoadURL('www.163.com ') Сообщает об ошибке деления на 0 "деление с плавающей запятой на ноль"
Подозревая, что это является причиной всплывающего окна, иду регистрировать его всплывающий обратный вызов, но обратного вызова нет, так что эта причина исключена.

По какой причине?

Забудь об этом, я больше не хочу этого говорить, ты сказал, что я не притворяюсь, что понимаю.,
Если у вас накоплено так много опыта, это, естественно, будет очень запутанно. Вы должны говорить обо всех аспектах, но если у вас их слишком много, это заставит людей чувствовать себя непонятыми.

Тогда я сказал, что ты, типичный ребенок, только что пришел на микширование и у тебя нет опыта. Просто ты молодой человек с хорошей энергией, поэтому ты будешь возиться с кодом для размещения на github или что-то в этом роде.
(Последняя половина предложения, семантически нейтральная,)

Я больше не хочу этого говорить.88 закрыть

@ugksoft ugksoft закрыла это как завершенное 17 июля 2018 г.
@1ocalhost
1ocalhost прокомментировал 17 июля 2018 г.
О, хороший мальчик, @ugksoft
скачать

@weolar
Владелец
weolar прокомментировал 17 июля 2018 г. •
1. Когда stdcall является стандартом?Что такое стандарт?Использование Microsoft stdcall является стандартом?Есть ли у Microsoft документ, в котором оговаривается, что все библиотеки DLL, запущенные на его компьютере, должны иметь stdcall?Мой любимый.h явно написал #define WKE_CALL_TYPE cdecl, все функции экспорта являются cdecl, есть проблема?
2. HWND - это структура typedef HWND *HWND в реализации Microsoft; что касается вашего внешнего использования, то ее можно использовать как DWORD.wkeString, который я экспортировал, также используется таким же образом.
3. Выравнивание по байтам, я напишу это четко в следующей версии.
4，??ХХХ??Xx Этот вид предназначен для моего собственного использования.И все это - вещи v8, которые на самом деле предназначены для людей, вызывающих nodejs.Конечно, он может быть использован только в таком виде.Если вы хотите распылить, просто распылите nodejs.
5. Если вы говорите, что произошла ошибка, проверьте правильность метода вызова и параметров вызова.Если все в порядке, вы можете сообщить мне об ошибках.Но я полагаю, что такой простой вызов не будет проблемой для mb.

@1ocalhost
1ocalhost прокомментировал 17 июля 2018 г.
О, хороший мальчик, подмети пол, @weolar
милый

@weolar
Владелец
weolar прокомментировал 17 июля 2018 г.
Ладно, все, успокойтесь.В настоящее время существуют две проблемы, о которых вы упомянули. Это правда, что документ mb и заголовочный файл написаны нечетко.Один из них заключается в том, что задается не выравнивание по байтам, а размер перечисления в байтах.Добавьте явное объявление в следующую версию

@weolar
Владелец
weolar прокомментировал 17 июля 2018 г.
За исключением проблем с выравниванием байтов и перечислением, другие точки распыления не принимаются

@yangyxd @yangyxd
yangyxd прокомментировал 17 июля 2018 г.
Не распыляйте без разбора, и вы прикасаетесь к компьютеру уже 20 лет. Вы не можете этого понять. Это нормально - сказать это.
Безоговорочно поддерживайте монахов.

@ugksoft ugksoft вновь открыла это 17 июля 2018 г.
@ugksoft
Автор
ugksoft прокомментировала 17 июля 2018 г.
Ответьте предыдущим нескольким людям после повторного открытия

В моем вышеприведенном содержании я, возможно, неосознанно имею в виду распыление, но содержание очень, очень, очень маленькое, главным образом потому, что я обнаружил, что автор не соблюдал его.
Все еще беспокоясь о недоразумениях, я намеренно добавила фразу "не ссорьтесь".

Правила для рек и озер в некоторых библиотеках DLL не стандартизированы, поэтому давайте опубликуем их. Цель - надеяться, что автор обратит на них внимание в следующий раз. Сейчас это изменить нельзя, но напишите определение или документ, объясняющий это.,
Поддержание кода на самом деле - это большая работа. Я не виню автора, включая лень, неопытность, ошибки или что-то еще. Винить нет смысла.

Однако самооценка автора зашкаливает, и он, в свою очередь, издевается над людьми.

Я прикасаюсь к компьютерам уже 20 лет. Это не имеет никакого отношения к умению с ними обращаться. Просто у меня большой опыт, смешанные вкусы и много старомодных слов.,
Или те, кто не говорит, что они вряд ли совершат ошибки новичков, поэтому они могут рассмотреть проблемы друг друга и сосредоточиться на простых, но непопулярных вопросах или глубоких возможностях.
Целью библиотеки DLL является
1.При совместном использовании нескольких программ в памяти остается только одна часть, что экономит память.Когда несколько процессов совместно используют одно и то же ядро, просто сопоставьте его
2.Модульная, многопользовательская независимая разработка с разделением труда, не имеет значения, как это реализуют другие, просто делайте свое дело
После создания библиотеки DLL вызывающему не нужно разбираться во внутренней ситуации, и он может небрежно выбросить ее. Он не знает реального адреса чего-либо внутри библиотеки DLL. Все значения, предоставленные библиотекой DLL, не уничтожат пространство библиотеки DLL, и код безопасен.,

Если на перенос и настройку библиотеки dll уйдет слишком много времени, использование готового модуля потеряет смысл. Некоторые необъяснимые ошибки могут заключаться в том, что определение не является стандартным, и ошибки возникают в разных пользователях / языках / средах. Эти необъяснимые ошибки могут быть не обнаружены в течение нескольких дней. причина,
Есть также некоторые разработчики Linux / Windows / микропрограммного обеспечения, которые не понимают архитектуру, что является проблемой.

При разработке аппаратного обеспечения обычно отсутствует концепция многопоточности, не говоря уже о осведомленности о безопасности данных. По его мнению, весь код выполняется последовательно, и все переменные и адреса памяти не разделяют концепцию конфликта.

Linux обычно не имеет значения многопользовательского взаимодействия, обратной совместимости и т.д., потому что программы Linux фрагментированы, независимо от проблем обратной совместимости, Linux не отличается удобством в эксплуатации, осведомленностью о безопасности эксплуатации, все является файлом, и ресурсы также отчаянно используются, так что обычно это делается относительно одноплатно, к счастью, людей много, каждый вставляет исполняемый модуль в функцию, например, IOS, так что ограничьте это, вы не можете работать так, вы не можете работать так, и вы можете использовать одну функцию.

Windows, проблема тоже очень серьезная, но внезапно она становится нехорошей.

Выбирайте эти вещи, не распыляйте, почему бы мне не создать систему? Создать систему просто, но вы не сможете ею управлять.
Драйвер должен быть разработан, но производитель его доработал, а документацию найти невозможно (например, интерфейс клавиатуры PS2, запущенный IBM, но стандартной документации нет, все смотрят на осциллограф, анализируют формат сигнала, а затем записывают прошивку)
Контекстное меню Windows, срок действия патента еще не истек (кажется, осталось еще полгода), Apple тогда поссорилась с Weiji, но это не исчезло. Apple уже много лет выпускает однокнопочную мышь, и она также хвасталась преимуществами из одной кнопки. Позже я заработал деньги, продавая iphone, и срок действия патента подходил к концу. Я обменялся патентами с Microsoft (похоже, я все равно заплатил деньги). Теперь в ocx постепенно появляется много меню, вызываемых правой кнопкой мыши.

Некоторые слова более многословны, и я боюсь, что многие люди не поймут, поэтому я намеренно написал больше. Сейчас многие новички, большинство из которых знают web, py, java и т.д., не имеют представления о принципах низкого уровня и не желают учиться ("Много новичков", не обязательно несколько человек наверху, не делите цифры, а затем распыляйте их без разбора)

stdcall, WeChat, который, насколько я помню, использовался в качестве рекомендательного метода в официальных книгах или статьях в 1990-х годах. Нельзя сказать, что это абсолютный стандарт, но в течение стольких лет все делали DLL таким образом, независимо от того, так это или нет, это явно указано для защиты от ошибок при любых обстоятельствах и обеспечивайте прямую и обратную совместимость. Это уже давно стало неписаным стандартом/правилом.

В частности, вы можете искать пакеты SDK, предоставляемые всеми приличными компаниями, такими как Haikang, Dahua, SDK от этих производителей оборудования, все файлы Microsoft H, все межъязыковые инструменты Windows и т.д.
За исключением изменения кода под Linux, такого как opencv, ffmpeg, x264.faac и т.д., является более запутанным, конкретное значение определяется значением по умолчанию средства компиляции,
Даже opencv не может видеть, каково значение retrun из api, освобождать его или нет (возвращаемое значение на самом деле может быть блоком памяти, но возвращаемое значение в файле h, предоставленном пользователю, определено как int, а не void *),
ffmpeg, время от времени структура менялась не по порядку (определите элемент ab, а позже захотите добавить его, просто подключите один и станьте acb), даже если он также разработан на C и на него ссылаются напрямую, вы не можете обновить модуль /функцию, скопировав библиотеку DLL/итак, метод.

Говорят, что HWND - это DWORD, потому что для внешних пользователей он является DWORD и его не нужно освобождать. Пользователь принимает значение и присваивает значение в стандартном методе int32 и не заботится о том, как это реализовано внутри. Это похоже на возвращаемый void* автором WKECRETEWEBVIEW. Не имеет значения, записано ли это как DWORD/Handle, в любом случае пользователь не может манипулировать этими данными. Если пользователь знает слово "Создать", его необходимо освободить вручную.,
Когда внешние пользователи переопределяют API, они могут ссылаться на оленя как на лошадь, при условии, что они гарантируют, что содержимое и метод API одинаковы при обмене данными.

Макияж
wkeLoadURL, похоже, что нет функции для автоматического заполнения http://, вам нужно указать полный адрес, прежде чем вы сможете
Вы можете подумать о том, чтобы оценить, есть ли строка '://' и действительно ли вы хотите создать заголовок. Если вы говорите это неправильно, когда я этого не говорил

Повторюсь, при пересечении языков обнаруживаются необъяснимые проблемы. Вероятно, у автора недостаточно опыта и некоторые места определены не в соответствии с правилами. Проблема вызвана неопытностью автора.